/*
SQLyog Ultimate v12.09 (64 bit)
MySQL - 5.7.26 : Database - yxadmin
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`yxadmin` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;

USE `yxadmin`;

/*Table structure for table `yx_article` */

DROP TABLE IF EXISTS `yx_article`;

CREATE TABLE `yx_article` (
  `article_id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `article_author` int(11) NOT NULL COMMENT '文章作者',
  `article_title` varchar(200) NOT NULL COMMENT '文章标题',
  `article_poster` varchar(250) NOT NULL DEFAULT '' COMMENT '文章封面',
  `article_content` text NOT NULL COMMENT '文章内容',
  `article_status` tinyint(1) NOT NULL DEFAULT '0' COMMENT '文章状态 0:正常',
  `article_add_time` datetime NOT NULL DEFAULT '0000-00-00 00:00:00' COMMENT '添加时间',
  `article_category` varchar(100) NOT NULL,
  `article_read_count` int(11) NOT NULL DEFAULT '0' COMMENT '浏览量',
  PRIMARY KEY (`article_id`)
) ENGINE=MyISAM AUTO_INCREMENT=238 DEFAULT CHARSET=utf8mb4;

/*Data for the table `yx_article` */

insert  into `yx_article`(`article_id`,`article_author`,`article_title`,`article_poster`,`article_content`,`article_status`,`article_add_time`,`article_category`,`article_read_count`) values (1,1,'Linux(centos)系统各个目录的作用详解','','&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;文件系统的类型&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;LINUX有四种基本文件系统类型：普通文件、目录文件、连接文件和特殊文件，可用file命令来识别。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;普通文件：如文本文件、C语言元代码、SHELL脚本、二进制的可执行文件等，可用cat、less、more、vi、emacs来察看内容，用mv来改名。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;目录文件：包括文件名、子目录名及其指针。它是LINUX储存文件名的唯一地方，可用ls列出目录文件。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;连接文件：是指向同一索引节点的那些目录条目。用ls来查看是，连接文件的标志用l开头，而文件面后以”-&amp;gt;”指向所连接的文件。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;特殊文件：LINUX的一些设备如磁盘、终端、打印机等都在文件系统中表示出来，则一类文件就是特殊文件，常放在/dev目录内。例如，软驱A称为/dev/fd0。LINUX无C：的概念，而是用/dev/had来自第一硬盘。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;对于linux新手来说，最感到迷惑的问题之一就是文件都存在哪里呢?特别是对于那些从windows转过来的新手来说，linux的目录结构看起来有些奇怪哦。所以，在这里讲一下linux下的主要目录以及它们都是用来干什么的。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;This is the root directory. The mothership. The home field. The one and only top directory for your whole computer. Everything, and I mean EVERYTHING starts here. When you type ‘/home’ what you’re really saying is “start at / and then go to the home directory.”&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;这就是根目录。对你的电脑来说，有且只有一个根目录。所有的东西，我是说所有的东西都是从这里开始。举个例子：当你在终端里输入“/home”，你其实是在告诉电脑，先从/(根目录)开始，再进入到home目录。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/root&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;This is where the root user lives. The root user is the god of your system. Root can do anything, up to and including removing your entire filesystem. So be careful using root.&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/root&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;这是系统管理员(root user)的目录。对于系统来说，系统管理员就好比是上帝，它能对系统做任何事情，甚至包括删除你的文件。因此，请小心使用root帐号。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/bin&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;Here’s where your standard linux utilities(read programs) live — things like “ls” and “vi” and “more”. Generally this directory is included in your path. What this means is that if you type ‘ls’, /bin is one of the places your shell will look to see if ‘ls’ means anything.&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/bin&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;这里存放了标准的(或者说是缺省的)linux的工具，比如像“ls”、“vi”还有“more”等等。通常来说，这个目录已经包含在你的“path”系 统变量里面了。什么意思呢?就是：当你在终端里输入ls，系统就会去/bin目录下面查找是不是有ls这个程序。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/etc&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;Here’s where the administrative and system configuration stuff lives. For instance, if you have samba installed, and you want to modify the samba configuration files, you’d find them in /etc/samba.&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/etc&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;这里主要存放了系统配置方面的文件。举个例子：你安装了samba这个套件，当你想要修改samba配置文件的时候，你会发现它们(配置文件)就在/etc/samba目录下。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/dev&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;Here’s where files that control peripherals live. Talking to a printer? Your computer is doing it from here. Same goes for disk drives, usb devices, and other such stuff.&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/dev&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;这里主要存放与设备(包括外设)有关的文件(unix和linux系统均把设备当成文件)。想连线打印机吗?系统就是从这个目录开始工作的。另外还有一些包括磁盘驱动、USB驱动等都放在这个目录。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/home&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;Here’s where your data is stored. Config files specific to users, your Desktop folder(whick makes your desktop what it is), and any data related to your user. Each user will have their own /home/username folder, with the exception of the root user.&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/home&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;这里主要存放你的个人数据。具体每个用户的设置文件，用户的桌面文件夹，还有用户的数据都放在这里。每个用户都有自己的用户目录，位置为：/home/用户名。当然，root用户除外。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/tmp&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;This is the Temporary folder. Think of it as a scratch directory for your Linux system. Files that won’t be needed by programs once their used once or twice are put here. Many Linux systems are set to automatically wipe the /tmp folder at certain intervals, so don’t put things you want to keep here.&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/tmp&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;这是临时目录。对于某些程序来说，有些文件被用了一次两次之后，就不会再被用到，像这样的文件就放在这里。有些linux系统会定期自动对这个目录进行清理，因此，千万不要把重要的数据放在这里。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/usr&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;Here’s where you’ll find extra utilities that don’t fit under /bin or /etc. Things like games, printer utilities, and whatnot. /usr is divided into sections like /usr/bin for programs, /usr/share for shared data like sound files or icons, /usr/lib for libraries whick cannot be directly run but are essential for running other programs.Your package manager takes care of the things in /usr for you.&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/usr&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;在这个目录下，你可以找到那些不适合放在/bin或/etc目录下的额外的工具。比如像游戏阿，一些打印工具拉等等。/usr目录包含了许多子目录： /usr/bin目录用于存放程序;/usr/share用于存放一些共享的数据，比如音乐文件或者图标等等;/usr/lib目录用于存放那些不能直接 运行的，但却是许多程序运行所必需的一些函数库文件。你的软件包管理器(应该是“新立得”吧)会自动帮你管理好/usr目录的。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/opt&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;Here’s where optional stuff is put. Trying out the latest Firefox beta? Install it to /opt where you can delete it without affecting other settings. Programs in here usually live inside a single folder whick contains all of their data, libraries, etc.&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/opt&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;这里主要存放那些可选的程序。你想尝试最新的firefox测试版吗?那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就可 以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;举个例子：刚才装的测试版firefox，就可以装到/opt/firefox_beta目录下，/opt/firefox_beta目录下面就包含了运 行firefox所需要的所有文件、库、数据等等。要删除firefox的时候，你只需删除/opt/firefox_beta目录即可，非常简单。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/usr/local&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;This is where most manually installed(ie. outside of your package manager) software goes. It has the same structure as /usr. It is a good idea to leave /usr to your package manager and put any custom scripts and things into /usr/local, since nothing important normally lives in /usr/local.&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/usr/local&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本(scripts)放到/usr/local目录下面，我想这应该是个不错的主意。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/media&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;Some distros use this folder to mount things like usb disks, cd or dvd drives and other filesystems.&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/media&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;有些linux的发行版使用这个目录来挂载那些usb接口的移动硬盘(包括U盘)、CD/DVD驱动器等等。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;补充：&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/bin 系统所需要的那些命令位于此目录，比如 ls、cp、mkdir等命令；功能和/usr/bin类似，这个目录中的文件都是可执行的、普通用户都可以使用的命令。作为基础系统所需要的最基础的命令就是放在这里（/usr/bin和/usr/sbin 类似与“/”根目录下对应的目录（/bin和/sbin），但不用于基本的启动（譬如，在紧急维护中）。大多数命令在这个目录下。 ）。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/boot Linux的内核及引导系统程序所需要的文件目录，比如 vmlinuz initrd.img 文件都位于这个目录中。在一般情况下，GRUB或LILO系统引导管理器也位于这个目录。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/lost+found 在ext2或ext3文件系统中，当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损 坏的文件系统。 有时系统发生问题，有很多的文件被移到这个目录中，可能会用手工的方式来修复，或移到文件到原来的位置上。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/mnt 这个目录一般是用于存放挂载储存设备的挂载目录的，比如有cdrom 等目录。可以参看/etc/fstab的定义。有时我们可以把让系统开机自动挂载文件系统，把挂载点放在这里也是可以的。主要看/etc/fstab中怎 么定义了；比如光驱可以挂载到/mnt/cdrom 。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/opt 表示的是可选择的意思，有些软件包也会被安装在这里，也就是自定义软件包，比如在Fedora Core 5.0中，OpenOffice就是安装在这里。有些我们自己编译的软件包，就可以安装在这个目录中；通过源码包安装的软件，可以通过 ./configure –prefix=/opt/目录 。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/proc 操作系统运行时，进程信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里。/proc目录伪装的文件系统proc的挂载目录，proc并不是真正的文件系统，它的定义可以参见 /etc/fstab 。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/sbin 大多是涉及系统管理的命令的存放，是超级权限用户root的可执行命令存放地，普通用户无权限执行这个目录下的命令，这个目录和/usr/sbin; /usr/X11R6/sbin或/usr/local/sbin目录是相似的；我们记住就行了，凡是目录sbin中包含的都是root权限才能执行的。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/usr 这个是系统存放程序的目录，比如命令、帮助文件等。这个目录下有很多的文件和目录。当我们安装一个Linux发行版官方提供的软件包时，大多安装在这里。 如果有涉及服务器配置文件的，会把配置文件安装在/etc目录中。/usr目录下包括涉及字体目录/usr/share/fonts ，帮助目录 /usr/share/man或/usr/share/doc，普通用户可执行文件目录/usr/bin 或/usr/local/bin 或/usr/X11R6/bin ，超级权限用户root的可执行命令存放目录，比如 /usr/sbin 或/usr/X11R6/sbin 或/usr/local/sbin 等；还有程序的头文件存放目录/usr/include。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/var 这个目录的内容是经常变动的，看名字就知道，我们可以理解为vary的缩写，/var下有/var/log 这是用来存放系统日志的目录。/var/www目录是定义Apache服务器站点存放目录；/var/lib 用来存放一些库文件，比如MySQL的，以及MySQL数据库的的存放地；&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;关于/opt目录的一个小技巧&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;在Linux中，/opt目录是存放某些大型软件或者某些特殊软件的目录，比如谷歌浏览器(Google Chrome)默认就是安装在/opt中。但是我们一般不会把opt单独分在一个区，因为/opt中大多数时候是空的，即使安装了软件也不会太多，而且有 些软件的容量还比较大，这样就会占用/的容量，我们可以在其它你愿意的地方建立一个目录来将/opt“转移”到别处，比如我的的/usr是单独分在一个 区，容量有50G，这么大的空间不要浪费了不是？而且/usr本来就是安装软件的地方，所以我可以/usr下建立一个叫opt的文件夹，然后右键点击这个 /usr下的opt，选择“创建链接”，得到一个名为“到 opt 的链接”文件，然后把这个文件剪切到/下，将原来的/opt删除，再将“到 opt 的链接”改名为opt就可以了，以后我们安装在/opt的软件实际上是安装到了/usr/opt下（实际上是一个符号链接）。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/usr/local 这个目录一般是用来存放用户自编译安装软件的存放目录；一般是通过源码包安装的软件，如果没有特别指定安装目录的话，一般是安装在这个目录中。这个目录下面有子目录。自己看看吧。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/usr/share 系统共用的东西存放地，比如 /usr/share/fonts 是字体目录，/usr/share/doc和/usr/share/man帮助文件。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/var/log 系统日志存放，分析日志要看这个目录的东西；&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;/var/spool 打印机、邮件、代理服务器等假脱机目录；&lt;/p&gt;\n                                                            ',0,'2015-05-05 00:00:00','17',35),(2,1,'Mysql出现Field * doesn’t have a default value解决办法','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Mysql出现Field * doesn’t have a default value&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(102, 102, 102); font-family: Arial, sans-serif; font-size: 18px;&quot;&gt;这个是mysql设置的严格模式导致的，解决办法可以修改：&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;windows修改my.ini &amp;nbsp; linux用户修改my.cnf（/etc/my.cnf）&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;查找&amp;nbsp;sql-mode=”STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION”&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;修改为&amp;nbsp;sql-mode=”NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION”&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;可以进入MySQL命令模式查看:&lt;/p&gt;&lt;pre&gt;mysql&amp;gt; show variables like &quot;sql_mode&quot;; &lt;font color=&quot;#000000&quot; face=&quot;open sans, Helvetica Neue, Helvetica, Arial, sans-serif&quot;&gt;&lt;span style=&quot;white-space: normal;&quot;&gt;\n&lt;/span&gt;&lt;/font&gt;&lt;/pre&gt;[重启MySQL服务]&lt;br&gt;',0,'2015-06-09 00:00:00','11',30),(3,1,'升级phpstudy2018默认mysql版本到5.7  ','','\n                                \n                                \n                                \n                                &lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;phpstudy2018默认自带MySQL版本是5.5，现将其升级到5.7&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;1.备份原来的MySQL文件夹phpstudy\\PHPTutorial\\MySQL重命名为MySQL5.5&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;2.将下载的mysql5.7压缩文件解压缩（官网地址：&lt;a href=&quot;https://downloads.mysql.com/archives/community/&quot; target=&quot;_blank&quot;&gt;https://downloads.mysql.com/archives/community/&lt;/a&gt;），并放在phpstudy\\PHPTutorial\\文件夹下，命名为MySQL；&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;3.将备份的MySQL5.5中的my.ini文件拷贝到phpstudy\\PHPTutorial\\MySQL\\bin目录下&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;4.以管理员身份运行cmd&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;进入phpstudy\\PHPTutorial\\MySQL\\bin目录；&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;运行&lt;/p&gt;&lt;pre style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;mysqld –initialize&lt;/pre&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;初始化MySQL；(安装时报错 MSVCR120.dall 下载&lt;a href=&quot;https://www.microsoft.com/en-us/download/details.aspx?id=40784&quot;&gt; VC redist packages for x64&lt;/a&gt;&amp;nbsp;，下载完成，点击运行即可。)&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;运行mysqld –install安装MySQL；&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;5.修改密码：&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;①修改mysql密码的时候执行mysqld –skip-grant-tables&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;②打开另一个命令窗口 运行mysql即可进入MySQL&amp;nbsp; （运行命令：update&amp;nbsp;&amp;nbsp;MySQL.user set authentication_string=password(‘root’) where user=’root’ ;）&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;③用数据库客户端连接会报错&amp;nbsp;1862: Your password has expired.（进入数据库运行名利 ：set password=password(‘新密码’); 即可）&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;6.apache或nignx能启动mysql启动不了&lt;br&gt;之前已经装过Mysql，要把系统服务里面的MySQL删除，留下MySQLa服务。&lt;br&gt;在cmd命令行下输入：sc delete mysql 即可删除。&lt;/p&gt;                                                                                                                ',2,'2018-12-03 00:00:00','23,11',63),(5,1,'【转】看完让你彻底搞懂Websocket原理 即时消息通讯','','&lt;p&gt;&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;偶然在知乎上看到一篇回帖，瞬间觉得之前看的那么多资料都不及这一篇回帖让我对&amp;nbsp;&lt;code style=&quot;margin: 0px; padding: 0px 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;websocket&lt;/code&gt;&amp;nbsp;的认识深刻有木有。所以转到我博客里，分享一下。比较喜欢看这种博客，读起来很轻松，不枯燥，没有布道师的阵仗，纯粹为分享。废话这么多了，最后再赞一个~&lt;/p&gt;&lt;h2 style=&quot;margin: 0px 0px 14px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 2.125em; line-height: 1.3em; font-family: Arial, sans-serif; vertical-align: baseline; overflow-wrap: break-word; letter-spacing: -0.7px;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; background-color: rgb(239, 239, 239);&quot;&gt;一&lt;/span&gt;&lt;span style=&quot;color: rgb(68, 68, 68);&quot;&gt;、websocket与http&lt;/span&gt;&lt;/h2&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;WebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算）&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;首先HTTP有&amp;nbsp;&lt;code style=&quot;margin: 0px; padding: 0px 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;1.1&lt;/code&gt;&amp;nbsp;和&amp;nbsp;&lt;code style=&quot;margin: 0px; padding: 0px 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;1.0&lt;/code&gt;&amp;nbsp;之说，也就是所谓的&amp;nbsp;&lt;code style=&quot;margin: 0px; padding: 0px 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;keep-alive&lt;/code&gt;&amp;nbsp;，把多个HTTP请求合并为一个，但是&amp;nbsp;&lt;code style=&quot;margin: 0px; padding: 0px 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;Websocket&lt;/code&gt;&amp;nbsp;其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充可以通过这样一张图理解&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;有交集，但是并不是全部。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;另外HTML5是指的一系列新的API，或者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。。通俗来说，你可以用HTTP协议传输非Html数据，就是这样=。=&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;再简单来说，层级不一样。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: 600; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; vertical-align: baseline;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; background-color: rgb(213, 213, 213);&quot;&gt;二&lt;/span&gt;&lt;/span&gt;、Websocket是什么样的协议，具体有什么优点&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;首先，Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。简单的举个例子吧，用目前应用比较广泛的php生命周期来解释。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;HTTP的生命周期通过&amp;nbsp;&lt;code style=&quot;margin: 0px; padding: 0px 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;Request&lt;/code&gt;&amp;nbsp;来界定，也就是一个&amp;nbsp;&lt;code style=&quot;margin: 0px; padding: 0px 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;Request&lt;/code&gt;&amp;nbsp;一个&amp;nbsp;&lt;code style=&quot;margin: 0px; padding: 0px 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;Response&lt;/code&gt;&amp;nbsp;，那么在&amp;nbsp;&lt;code style=&quot;margin: 0px; padding: 0px 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;HTTP1.0&lt;/code&gt;&amp;nbsp;中，这次HTTP请求就结束了。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。但是请记住&amp;nbsp;&lt;code style=&quot;margin: 0px; padding: 0px 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;Request = Response&lt;/code&gt;&amp;nbsp;， 在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是被动的，不能主动发起。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;教练，你BB了这么多，跟Websocket有什么关系呢？_(:з」∠)_好吧，我正准备说Websocket呢。。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;首先Websocket是基于HTTP协议的，或者说借用了HTTP的协议来完成一部分握手。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;首先我们来看个典型的&amp;nbsp;&lt;code style=&quot;margin: 0px; padding: 0px 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;Websocket&lt;/code&gt;&amp;nbsp;握手（借用Wikipedia的。。）&lt;/p&gt;\n                                                            \n&lt;pre&gt;GET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13\nOrigin: http://example.com\n&lt;/pre&gt;&lt;span style=&quot;color: rgb(102, 102, 102); font-family: Arial, sans-serif; font-size: 18px;&quot;&gt;熟悉HTTP的童鞋可能发现了，这段类似HTTP协议的握手请求中，多了几个东西。我会顺便讲解下作用。&lt;/span&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(102, 102, 102); font-family: Arial, sans-serif; font-size: 18px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;\n&lt;pre&gt;Upgrade: websocket\nConnection: Upgrade\n&lt;/pre&gt;\n\n&lt;h4&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;这个就是Websocket的核心了，告诉 Apache 、 Nginx 等服务器：注意啦，我发起的是Websocket协议，快点帮我找到对应的助理处理~不是那个老土的HTTP。&lt;/span&gt;&lt;/h4&gt;\n&lt;pre&gt;Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13\n&lt;/pre&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;首先，&amp;nbsp;&lt;code style=&quot;margin: 0px; padding: 0px 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;Sec-WebSocket-Key&lt;/code&gt;&amp;nbsp;是一个&amp;nbsp;&lt;code style=&quot;margin: 0px; padding: 0px 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;Base64 encode&lt;/code&gt;&amp;nbsp;的值，这个是浏览器随机生成的，告诉服务器：泥煤，不要忽悠窝，我要验证尼是不是真的是Websocket助理。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;然后，&amp;nbsp;&lt;code style=&quot;margin: 0px; padding: 0px 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;Sec_WebSocket-Protocol&lt;/code&gt;&amp;nbsp;是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。简单理解：今晚我要服务A，别搞错啦~&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;最后，&amp;nbsp;&lt;code style=&quot;margin: 0px; padding: 0px 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;Sec-WebSocket-Version&lt;/code&gt;&amp;nbsp;是告诉服务器所使用的&amp;nbsp;&lt;code style=&quot;margin: 0px; padding: 0px 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;Websocket Draft&lt;/code&gt;（协议版本），在最初的时候，Websocket协议还在&amp;nbsp;&lt;code style=&quot;margin: 0px; padding: 0px 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;Draft&lt;/code&gt;&amp;nbsp;阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么Firefox和Chrome用的不是一个版本之类的，当初Websocket协议太多可是一个大难题。。不过现在还好，已经定下来啦~大家都使用的一个东西~ 脱水：&amp;nbsp;服务员，我要的是13岁的噢→_→&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;然后服务器会返回下列东西，表示已经接受到请求， 成功建立Websocket啦！&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot; style=&quot;margin-top: 30px; margin-bottom: 30px; padding: 18px 20px; border-color: rgb(221, 221, 221); font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: 19px; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: url(&amp;quot;../img/pre.png&amp;quot;) center top rgb(255, 255, 255); overflow-y: hidden; color: rgb(102, 102, 102);&quot;&gt;HTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=\nSec-WebSocket-Protocol: chat&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;这里开始就是HTTP最后负责的区域了，告诉客户，我已经成功切换协议啦~&lt;/p&gt;&lt;pre style=&quot;margin-top: 30px; margin-bottom: 30px; padding: 18px 20px; border-color: rgb(221, 221, 221); font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: 19px; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: url(&amp;quot;../img/pre.png&amp;quot;) center top rgb(255, 255, 255); overflow-y: hidden; color: rgb(102, 102, 102);&quot;&gt;Upgrade: websocket\nConnection: Upgrade&lt;/pre&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;依然是固定的，告诉客户端即将升级的是&amp;nbsp;&lt;code style=&quot;margin: 0px; padding-right: 3px; padding-left: 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;Websocket&lt;/code&gt;&amp;nbsp;协议，而不是mozillasocket，lurnarsocket或者shitsocket。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;然后，&amp;nbsp;&lt;code style=&quot;margin: 0px; padding-right: 3px; padding-left: 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;Sec-WebSocket-Accept&lt;/code&gt;&amp;nbsp;这个则是经过服务器确认，并且加密过后的&amp;nbsp;&lt;code style=&quot;margin: 0px; padding-right: 3px; padding-left: 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;Sec-WebSocket-Key&lt;/code&gt;&amp;nbsp;。&amp;nbsp;服务器：好啦好啦，知道啦，给你看我的ID CARD来证明行了吧。。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;后面的，&amp;nbsp;&lt;code style=&quot;margin: 0px; padding-right: 3px; padding-left: 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;Sec-WebSocket-Protocol&lt;/code&gt;&amp;nbsp;则是表示最终使用的协议。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;至此，HTTP已经完成它所有工作了，接下来就是完全按照Websocket协议进行了。具体的协议就不在这阐述了。&lt;/p&gt;&lt;h2 style=&quot;margin: 0px 0px 14px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 2.125em; line-height: 1.3em; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(68, 68, 68); overflow-wrap: break-word; letter-spacing: -0.7px; white-space: normal;&quot;&gt;三、Websocket的作用&lt;/h2&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;在讲Websocket之前，我就顺带着讲下&amp;nbsp;&lt;code style=&quot;margin: 0px; padding-right: 3px; padding-left: 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;long poll&lt;/code&gt;&amp;nbsp;和&amp;nbsp;&lt;code style=&quot;margin: 0px; padding-right: 3px; padding-left: 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;ajax轮询&lt;/code&gt;&amp;nbsp;的原理。&lt;/p&gt;&lt;h3 style=&quot;margin: 0px 0px 14px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 1.75em; line-height: 1.3em; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(68, 68, 68); overflow-wrap: break-word; letter-spacing: -0.5px; white-space: normal;&quot;&gt;&lt;a name=&quot;t3&quot; style=&quot;margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; color: rgb(22, 207, 193); outline: 0px; transition: all 0.2s ease 0s;&quot;&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; name=&quot;t3&quot; style=&quot;margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; color: rgb(22, 207, 193); outline: 0px; transition: all 0.2s ease 0s;&quot;&gt;&lt;/a&gt;ajax轮询&lt;/h3&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;ajax轮询的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。&lt;/p&gt;&lt;div style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;&lt;div style=&quot;margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;场景再现：&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;客户端：啦啦啦，有没有新信息(Request)&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;服务端：没有（Response）&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;客户端：啦啦啦，有没有新信息(Request)&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;服务端：没有。。（Response）&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;客户端：啦啦啦，有没有新信息(Request)&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;服务端：你好烦啊，没有啊。。（Response）&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;客户端：啦啦啦，有没有新消息（Request）&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;服务端：好啦好啦，有啦给你。（Response）&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;客户端：啦啦啦，有没有新消息（Request）&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;服务端：。。。。。没。。。。没。。。没有（Response） —- loop&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;h3 style=&quot;margin: 0px 0px 14px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 1.75em; line-height: 1.3em; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(68, 68, 68); overflow-wrap: break-word; letter-spacing: -0.5px; white-space: normal;&quot;&gt;&lt;a name=&quot;t4&quot; style=&quot;margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; color: rgb(22, 207, 193); outline: 0px; transition: all 0.2s ease 0s;&quot;&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; name=&quot;t4&quot; style=&quot;margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; color: rgb(22, 207, 193); outline: 0px; transition: all 0.2s ease 0s;&quot;&gt;&lt;/a&gt;long poll&lt;/h3&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;&lt;code style=&quot;margin: 0px; padding-right: 3px; padding-left: 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;long poll&lt;/code&gt;&amp;nbsp;其实原理跟&amp;nbsp;&lt;code style=&quot;margin: 0px; padding-right: 3px; padding-left: 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;ajax轮询&lt;/code&gt;&amp;nbsp;差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。&lt;/p&gt;&lt;div style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;&lt;div style=&quot;margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;场景再现：&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request）&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;服务端：额。。 等待到有消息的时候。。来 给你（Response）&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个&lt;a target=&quot;_blank&quot; name=&quot;baidusnap2&quot; style=&quot;margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; color: rgb(22, 207, 193); outline: 0px; transition: all 0.2s ease 0s;&quot;&gt;&lt;/a&gt;特点，被动性。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;简单地说就是，服务器是一个很懒的冰箱（这是个梗）（不会、不能主动发起连接），但是上司有命令，如果有客户来，不管多么累都要好好接待。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;说完这个，我们再来说一说上面的缺陷（原谅我废话这么多吧OAQ）&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;从上面很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;ajax轮询 需要服务器有很快的处理速度和资源。（速度）long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;所以&amp;nbsp;&lt;code style=&quot;margin: 0px; padding-right: 3px; padding-left: 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;ajax轮询&lt;/code&gt;&amp;nbsp;和&amp;nbsp;&lt;code style=&quot;margin: 0px; padding-right: 3px; padding-left: 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;long poll&lt;/code&gt;&amp;nbsp;都有可能发生这种情况。&lt;/p&gt;&lt;div style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;&lt;div style=&quot;margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;客户端：啦啦啦啦，有新信息么？&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;服务端：月线正忙，请稍后再试（503 Server Unavailable）&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;客户端：。。。。好吧，啦啦啦，有新信息么？&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;服务端：月线正忙，请稍后再试（503 Server Unavailable）&lt;/p&gt;&lt;/div&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;客户端：然后服务端在一旁忙的要死：冰箱，我要更多的冰箱！更多。。更多。。（我错了。。这又是梗。。）&lt;/p&gt;&lt;/div&gt;&lt;h3 style=&quot;margin: 0px 0px 14px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 1.75em; line-height: 1.3em; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(68, 68, 68); overflow-wrap: break-word; letter-spacing: -0.5px; white-space: normal;&quot;&gt;&lt;a name=&quot;t5&quot; style=&quot;margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; color: rgb(22, 207, 193); outline: 0px; transition: all 0.2s ease 0s;&quot;&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; name=&quot;t5&quot; style=&quot;margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; color: rgb(22, 207, 193); outline: 0px; transition: all 0.2s ease 0s;&quot;&gt;&lt;/a&gt;言归正传，我们来说Websocket吧&lt;/h3&gt;&lt;div style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;通过上面这个例子，我们可以看出，这两种方式都不是最好的方式，需要很多资源。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;一种需要更快的速度，一种需要更多的’电话’。这两种都会导致’电话’的需求越来越高。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;哦对了，忘记说了HTTP还是一个状态协议。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;通俗的说就是，服务器因为每天要接待太多客户了，是个健忘鬼，你一挂电话，他就把你的东西全忘光了，把你的东西全丢掉了。你第二次还得再告诉服务器一遍。&lt;/p&gt;&lt;/div&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;所以在这种情况下出现了，Websocket出现了。他解决了HTTP的这几个难题。首先，被动性，当服务器完成协议升级后（HTTP-&amp;gt;Websocket），服务端就可以主动推送信息给客户端啦。所以上面的情景可以做如下修改。&lt;/p&gt;&lt;div style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;&lt;div style=&quot;margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;客户端：啦啦啦，我要建立Websocket协议，需要的服务：chat，Websocket协议版本：17（HTTP Request）&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;服务端：ok，确认，已升级为Websocket协议（HTTP Protocols Switched）&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;客户端：麻烦你有信息的时候推送给我噢。。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;服务端：ok，有的时候会告诉你的。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;服务端：balabalabalabala&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;服务端：balabalabalabala&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;服务端：哈哈哈哈哈啊哈哈哈哈&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;服务端：笑死我了哈哈哈哈哈哈哈&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;就变成了这样，只需要经过一次HTTP请求，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你&amp;nbsp;）&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;这样的协议解决了上面同步有延迟，而且还非常消耗资源的这种情况。那么为什么他会解决服务器上消耗资源的问题呢？&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;其实我们所用的程序是要经过两层代理的，即HTTP协议在Nginx等服务器的解析下，然后再传送给相应的Handler（PHP等）来处理。简单地说，我们有一个非常快速的&amp;nbsp;&lt;code style=&quot;margin: 0px; padding-right: 3px; padding-left: 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;接线员（Nginx）&lt;/code&gt;&amp;nbsp;，他负责把问题转交给相应的&amp;nbsp;&lt;code style=&quot;margin: 0px; padding-right: 3px; padding-left: 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;客服（Handler）&lt;/code&gt;&amp;nbsp;。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;本身接线员基本上速度是足够的，但是每次都卡在客服（Handler）了，老有客服处理速度太慢。，导致客服不够。Websocket就解决了这样一个难题，建立后，可以直接跟接线员建立持久连接，有信息的时候客服想办法通知接线员，然后接线员在统一转交给客户。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;这样就可以解决客服处理速度过慢的问题了。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;同时，在传统的方式上，要不断的建立，关闭HTTP协议，由于HTTP是非状态性的，每次都要重新传输&amp;nbsp;&lt;code style=&quot;margin: 0px; padding-right: 3px; padding-left: 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;identity info&lt;/code&gt;&amp;nbsp;（鉴别信息），来告诉服务端你是谁。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;虽然接线员很快速，但是每次都要听这么一堆，效率也会有所下降的，同时还得不断把这些信息转交给客服，不但浪费客服的处理时间，而且还会在网路传输中消耗过多的流量/时间。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;但是Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。&lt;/p&gt;&lt;div style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; white-space: normal;&quot;&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;同时由客户主动询问，转换为服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。），没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的客服（Handler）了&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;——————–&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;至于怎么在不支持Websocket的客户端上使用Websocket。。答案是：&amp;nbsp;不能&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;但是可以通过上面说的&amp;nbsp;&lt;code style=&quot;margin: 0px; padding-right: 3px; padding-left: 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;long poll&lt;/code&gt;&amp;nbsp;和&amp;nbsp;&lt;code style=&quot;margin: 0px; padding-right: 3px; padding-left: 3px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: 0.6875em; line-height: inherit; font-family: Monaco, &amp;quot;Courier New&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, monospace; vertical-align: baseline; background: rgb(238, 238, 238);&quot;&gt;ajax 轮询&lt;/code&gt;&amp;nbsp;来 模拟出类似的效果&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: 600; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; vertical-align: baseline;&quot;&gt;Websocket和Socket.io的关系&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font: inherit; vertical-align: baseline;&quot;&gt;node.js提供了高效的服务端运行环境，但是由于浏览器端对HTML5的支持不一，为了兼容所有浏览器，提供卓越的实时的用户体验，并且为程序员提供客户端与服务端一致的编程体验，于是socket.io诞生。Socket.io将Websocket和轮询 （Polling）机制以及其它的实时通信方式封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。也就是说，Websocket仅仅是 Socket.io实现实时通信的一个子集。那么，Socket.io都实现了Polling中的那些通信机制呢？&lt;/p&gt;&lt;/div&gt;&lt;/pre&gt;',0,'2016-07-06 00:00:00','29',36),(4,1,'centos7 下PHP使用FFmpeg进行视频截图','','&lt;p&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;FFmpeg是领先的多媒体框架，能够&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;&lt;span style=&quot;font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;&quot;&gt;解码&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;，&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; vertical-align: baseline;&quot;&gt;编码&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;，&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; vertical-align: baseline;&quot;&gt;&amp;nbsp;转码&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;，&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; vertical-align: baseline;&quot;&gt;复用&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;，&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; vertical-align: baseline;&quot;&gt;解&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; vertical-align: baseline;&quot;&gt;复&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; vertical-align: baseline;&quot;&gt;用&lt;/span&gt;，&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; vertical-align: baseline;&quot;&gt;流式传输&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;，&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;&lt;span style=&quot;font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;&quot;&gt;过滤&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;和&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;&lt;span style=&quot;font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline;&quot;&gt;播放&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;人类和机器创建的任何内容。它支持最晦涩难懂的古代格式，直至最前沿。无论它们是由某些标准委员会，社区还是公司设计的。它还具有高度可移植性：FFmpeg&amp;nbsp;在各种构建环境，机器架构和配置下，跨Linux，Mac OS X，Microsoft Windows，BSD，Solaris等编译，运行和传递我们的测试基础架构。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;下载linux版本：&lt;a href=&quot;https://johnvansickle.com/ffmpeg/&quot; target=&quot;_blank&quot; style=&quot;margin: 0px; padding: 0px; border: 0px; font: inherit; vertical-align: baseline; color: rgb(22, 207, 193); outline: 0px; transition: all 0.2s ease 0s; background-color: rgb(247, 247, 247);&quot;&gt;https://johnvansickle.com/ffmpeg/&lt;/a&gt;&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;①下载后解压文件 ****.tar.xz&amp;nbsp; 使用命令&amp;nbsp; xz -d&amp;nbsp; ***.tar.xz&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;②然后再用&amp;nbsp; tar xvf&amp;nbsp; ***.tar&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;③把解压文件目录中的ffmpeg复制到 /usr/local/ffmpeg/ffmpeg&amp;nbsp; 再把 ffmpeg 复制一份到/usr/bin 下面&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;截图、截动画&lt;/p&gt;\n&lt;pre&gt;ffmpeg -i  myvideo.avi -t 0.001 -f image2  pic.jpg\nffmpeg -i myvideo.avi -ss 10 -t 5 -pix_fmt rgb24 -loop_output 0 -f gif  animal.gif\n&lt;/pre&gt;',0,'2016-06-07 00:00:00','23,17',35),(6,1,'CentOS7 如何查看端口是被哪个应用/进程占用及kill  ','','\n                                &lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;检查端口被哪个进程占用&lt;/li&gt;&lt;/ol&gt;\n&lt;pre&gt;netstat -lnp|grep 8000 \n&lt;/pre&gt;&lt;img src=&quot;/upload/article/20181204/a2b075ccb798d61ea4d79651bd11c7bf.png&quot; data-filename=&quot;img&quot; style=&quot;width: 768px;&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;找到进程号是 11100；&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;2.查看进程号&lt;/p&gt;\n&lt;pre&gt; ps 11100\n&lt;/pre&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;3.杀死进程&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;kill -9 11100&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;                            ',0,'2017-02-07 00:00:00','17',66),(8,1,'js中offsetHeight、clientHeight、scrollHeight等相关属性区分','','&lt;p&gt;大体上来说可以这样理解：&lt;/p&gt;&lt;p&gt;client***属性（clientWidth、clientHeight）:&lt;/p&gt;&lt;p&gt;表示元素可以看到内容的可见区域部分，一般是最后一个对象条以下到状况栏以上的这个区域，与页面内容无关。且它会直接返回属性的数值大小，可直接进行计算。分开说的话也可以这样理解：若元素大小小于父元素，大小包括padding、content部分，不包括border；若元素大小大于父元素，则表示可以看到的部分的高或宽。&lt;/p&gt;&lt;p&gt;offset***属性（offsetWidth、offsetHeight、offsetTop、offsetLeft）：&lt;/p&gt;&lt;p&gt;对于offsetWidth和offsetHeight，都表示当前对象的宽度/高度。offsetWidth与style.widtht的区别是：若对象的宽度设定值为百分百宽度，无论页面变大或变小，style.width都返回此百分比；而offsetWidth则返回页面中对象的宽度值而不是百分比。&lt;/p&gt;&lt;p&gt;对于offsetTop和offsetLeft，都表示当前元素对象相对于其定位元素的垂直/水平偏移量。&lt;/p&gt;&lt;p&gt;scroll***属性（scrollTop、scrollLeft、scrollHeight、scrollWidth）:&lt;/p&gt;&lt;p&gt;scroll是滚动的意思，也就是scrollWidth、scrollHeight属性代表元素对象真实的宽高，即使有一部分看不到；scrollTop、scrollLeft代表元素对象最顶端/最左端到对象到当前窗口显示的局限内的距顶部/左边距的间隔，也是元素垂直/水平滚动了的距离，或者是元素卷帘卷走的视觉中看不到的部分。&lt;/p&gt;&lt;p&gt;有两个关系式是(当所有元素的margin均初始化设为0时)：&lt;/p&gt;&lt;p&gt;scrollHeight – scrollTop = clientHeight：当这两个条件成立时，也就代表垂直滚动条走到底了&lt;/p&gt;&lt;p&gt;scrollWidth – scrollLeft = clientWidth：当这两个条件成立时，也就代表水平滚动条走到底了&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;',0,'2016-06-01 00:00:00','22',47),(9,1,'JS 之Blob、File、base64以及 createObjectURL实现图片预览','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;file 对象只是 blob 对象的一个更具体的版本，blob 存储着大量的二进制数据，并且 blob 的 size 和 type 属性，都会被 file 对象所继承。&lt;/p&gt;&lt;p&gt;所以， 在大多数情况下，blob 对象和 file 对象可以用在同一个地方，例如，可以使用 FileReader 接口从 blob 读取数据，也可以使用 URL.createObjectURL() 从 blob 创建一个新的 URL 对象。&lt;/p&gt;&lt;p&gt;File对象,就是一个文件,比如我用input type=”file”标签来上传文件,那么里面的每个文件都是一个File对象.&lt;/p&gt;&lt;p&gt;Blob对象,就是二进制数据,比如通过new Blob()创建的对象就是Blob对象.又比如,在XMLHttpRequest里,如果指定responseType为blob,那么得到的返回值也是一个blob对象.&lt;/p&gt;&lt;p&gt;用filereader【有些浏览器不支持此对象】 和 URL.createObjectURL 两种预览方式。&lt;/p&gt;&lt;p&gt;按照前辈们的说法，creatObjectURL可以有更好的性能，或许是浏览器自带接口的原因, 可以处理的更快。&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;\n&lt;pre&gt; //filereader方式\n document.getElementById(\'imgFile\').onchange = function(e){   \n  \n    var ele =  document.getElementById(\'imgFile\').files[0];\n  		  	\n    var fr = new FileReader();\n    fr.onload = function(ele){\n 		  		\n	    var pvImg = new Image();\n	    pvImg.src = ele.target.result;\n 	    pvImg.setAttribute(\'id\',\'previewImg\');\n 		  		\n 	    $(\'.preview_wrap\').html(\'\').append(pvImg);       \n    }\n\n 	fr.readAsDataURL(ele);\n }\n\n//URL.createObjectURL 方式\ndocument.getElementById(\'imgFile\').onchange = function(e){\n    var ele =  document.getElementById(\'imgFile\').files[0];\n \n    var createObjectURL = function(blob){\n 		return window[window.webkitURL ? \'webkitURL\' : \'URL\'][\'createObjectURL\'](blob);\n    };\n\n    var newimgdata = createObjectURL(ele);\n \n    var pvImg = new Image();\n    pvImg.src = newimgdata;\n    pvImg.setAttribute(\'id\',\'previewImg\');\n\n    $(\'.preview_wrap\').html(\'\').append(pvImg);\n }\n&lt;/pre&gt;',0,'2017-06-06 00:00:00','22',24),(10,1,'php解决和避免form表单重复提交的几种方法','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;为什么要避免form表单被重复提交呢？因为我们不想让我们的服务器重复处理没必要的数据，同时我们也是避免我们的数据库产生重复的数据，避免表单重复提交也是让我们的网站更安全的一种表现。&lt;/p&gt;&lt;p&gt;先看一下有哪些情况下回导致表单重复提交呢，知道哪些情况下可能会出现表单重复提交就可以从根源处理表单重复提交的情况了。&lt;/p&gt;&lt;p&gt;下面的情况就会导致表单重复提交：&lt;/p&gt;&lt;p&gt;点击提交按钮两次。&lt;/p&gt;&lt;p&gt;点击刷新按钮。&lt;/p&gt;&lt;p&gt;使用浏览器后退按钮重复之前的操作，导致重复提交表单。&lt;/p&gt;&lt;p&gt;使用浏览器历史记录重复提交表单。&lt;/p&gt;&lt;p&gt;浏览器重复的HTTP请求。&lt;/p&gt;&lt;p&gt;网页被恶意刷新。&lt;/p&gt;&lt;p&gt;下面是几种解决办法：&lt;/p&gt;&lt;p&gt;一：利用js设置按钮点击后变成灰色&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;background-color: rgb(74, 123, 140); color: rgb(247, 247, 247);&quot;&gt;&amp;lt;input type=&quot;text&quot; name=&quot;T1&quot; size=&quot;20&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;background-color: rgb(74, 123, 140); color: rgb(247, 247, 247);&quot;&gt;&amp;lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;javascript:{this.disabled=true;document.form1.submit();}&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: 600; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; vertical-align: baseline;&quot;&gt;二：利用session&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;在session中放一个特殊标志。当表单页面被请求时，生成一个特殊的字符标志串，存在session中，同时放在表单的隐藏域里。接受处理表单数据时，检查标识字串是否存在，并立即从session中删除它，然后正常处理数据。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;如果发现表单提交里没有有效的标志串，这说明表单已经被提交过了，忽略这次提交。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;这使你的web应用有了更高级的XSRF保护&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;加载提交的页面时候，生成一个随机数，&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;$code = mt_rand(0,1000000);&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;存储在表单的隐藏输入框中：&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;&amp;lt; input type=’hidden’ name=’code’ value=”&amp;gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;\n&lt;pre&gt;if(isset($_POST[\'code\'])) {\n   \n    if($_POST[\'code\'] == $_SESSION[\'code\']){\n   \n       // 重复提交表单了\n   \n    }else{\n   \n    $_SESSION[\'code\'] =$_POST[\'code\']; //存储code\n\n    }\n}\n&lt;/pre&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-weight: 600; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;三：提交表单页面跳转&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;（也可以避免重复提交的情况）&lt;/span&gt;&lt;br&gt;',0,'2016-06-07 00:00:00','23,22',22),(11,1,'Workerman是什么？','','&lt;div&gt;Workerman是一款纯PHP开发的开源高性能的PHP socket 服务框架。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Workerman不是重复造轮子，它不是一个MVC框架，而是一个更底层更通用的socket服务框架，你可以用它开发tcp代理、梯子代理、做游戏服务器、邮件服务器、ftp服务器、甚至开发一个php版本的redis、php版本的数据库、php版本的nginx、php版本的php-fpm等等。Workerman可以说是PHP领域的一次创新，让开发者彻底摆脱了PHP只能做WEB的束缚。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;实际上Workerman类似一个PHP版本的nginx，核心也是多进程+Epoll+非阻塞IO。Workerman每个进程能维持上万并发连接。由于本身常住内存，不依赖Apache、nginx、php-fpm这些容器，拥有超高的性能。同时支持TCP、UDP、UNIXSOCKET，支持长连接，支持Websocket、HTTP、WSS、HTTPS等通讯协以及各种自定义协议。拥有定时器、异步socket客户端、异步Mysql、异步Redis、异步Http、异步消息队列等众多高性能组件。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Workerman理念&lt;/div&gt;&lt;div&gt;极简、稳定、高性能、分布式。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;极简&lt;/div&gt;&lt;div&gt;小即是美，Workerman内核极简，仅有几个php文件并且只暴露几个接口，学习起来非常简单。所有其它功能通过组件的方式扩展。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Workerman拥有完善的文档+权威的主页+活跃的社区+数个千人QQ群+众多的高性能组件+N多的例子，这一切都让开发者使用起来更得心应手。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;稳定&lt;/div&gt;&lt;div&gt;Workerman已经开源数年，被很多上市公司大规模使用，超级稳定。有些服务2年多没重启过仍然在飞速运行。没有coredump、没有内存泄漏、没有bug。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;高性能&lt;/div&gt;&lt;div&gt;Workerman因为常住内存，本身不依赖apache/nginx/php-fpm，没有容器到PHP的通讯开销，没有每个请求初始化一切又销毁一切的开销，具有超高的性能，比起传统的MVC框架，性能要高数十倍，PHP7下通过ab压力测试QPS甚至高于单独的nginx。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;注意：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;WorkerMan有分为Linux版本WorkerMan和Windows版本WorkerMan-for-win，windows版本说明参见这里。Linux版本可用于开发调试及正式环境部署，而由于PHP-CLI在windows系统无法实现多进程以及守护进程，所以windows版本Workerman建议仅作开发调试使用。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;注意：Windows版本WorkerMan无法在Linux平台使用，同时Linux版本WorkerMan也无法在Windows平台使用。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;windows用户需要使用windows版本的workerman，windows版本workerman本身不依赖任何扩展，只需要配置好PHP环境变量即可，windows版本workerman安装及注意事项参见windows用户必看。或者直接cd到php文件夹下运行php.exe&lt;/div&gt;\n                                                            ',0,'2016-08-10 00:00:00','23',30),(12,1,'Workerman与Socket.IO之间的关系？','','\r\n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;区别：&lt;/p&gt;&lt;p&gt;1、Workerman是PHP开发的&lt;/p&gt;&lt;p&gt;2、Socket.io是nodejs开发的&lt;/p&gt;&lt;p&gt;3、不过Workerman也提供了一个PHP版本的Socket.IO框架叫PHPSocket.IO，兼容Socket.io客户端，可用于替代Socket.io。例子，问答系统的页面底部的实时在线统计也是PHPSocket.io做的&lt;/p&gt;&lt;p&gt;4、Workerman和Socket.io的关系就像 nodejs和Socket.io的关系。可以把Workerman看做是php版本的nodejs&lt;/p&gt;&lt;p&gt;5、Socket.io是专门为浏览器设计的，浏览器兼容性很好&lt;/p&gt;&lt;p&gt;6、Socket.io(包括PHPSocket.IO)是单进程的，不好做分布式。Workerman是多进程的，并且Workerman支持分布式，能够支撑更大的并发量&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;选择：&lt;/p&gt;&lt;p&gt;如果js熟悉并且对浏览器兼容有很高要求，可以用nodejs版本的socket.io&lt;/p&gt;&lt;p&gt;如果php熟悉，建议用Workerman的GatewayWorker框架，利用websocket协议通讯，配合web-socket-js前端框架，浏览器兼容性也不差，主要是开发部署方便，并且支持分布式，文档例子也很全。&lt;/p&gt;                            ',0,'2016-08-10 00:00:00','23',45),(13,1,'js鼠标粘贴显示图片','','\n                                \n\n\n&lt;pre&gt;&amp;lt;input type=&quot;”text”&quot; id=&quot;”myInput”&quot;&amp;gt;	&lt;/pre&gt;&lt;pre&gt;document.getElementById(\'myInput\').addEventListener(\'paste\',function(e){\n 	if ( !(e.clipboardData &amp;amp;&amp;amp; e.clipboardData.items) ) {\n		return;\n 	}\n 	for (var i = 0, len = e.clipboardData.items.length; i &amp;lt; len; i++) {\n 		var item = e.clipboardData.items[i];\n \n 		if (item.kind === \'string\') {\n 			item.getAsString(function (str) {\n 				console.log(str);\n 			})\n 		} else if (item.kind === \'file\') {\n 			var f= item.getAsFile();\n \n 			var imgUrl = URL.createObjectURL(f);\n 			console.log(f);\n		}\n	}\n});\n&lt;/pre&gt;                            ',0,'2016-08-10 00:00:00','22',15),(14,1,'JavaScript事件绑定和事件监听的区别','','&lt;pre&gt;&amp;lt;!-- 普通事件中的onclick事件只支持单个事件，会被其他onclick事件覆盖，(重点！！！)&lt;br&gt;&amp;nbsp; &amp;nbsp; 有两种写法:一是在标签内写onclick事件&lt;br&gt;&amp;nbsp; &amp;nbsp;二是在JS里面写onlicke=function（）{&lt;br&gt;&amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;br&gt;&lt;/span&gt;&amp;nbsp; &amp;nbsp;}事件监听中的addEventListener可以添加多个事件而不用担心被覆盖只有一种写法：监听方法&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp;第一种写法 不执行 --&amp;gt;&lt;br&gt;&amp;nbsp;&amp;lt;input id=\'myButton\' type=\'button\' value=\'点我\' onclick=&quot;alert(\'普通事件1\');&quot;&amp;gt;&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp;document.getElementById(\'myButton\').onclick=function () {&lt;br&gt;&amp;nbsp;   alert(\'普通事件2\');&amp;nbsp;&lt;br&gt;&amp;nbsp;   //第二种写法 会将上面的alert(‘普通事件1’)覆盖&lt;br&gt;}&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp;//事件监听添加两个事件. 监听可以对同一件事情添加多个监听的事件&lt;br&gt;&amp;nbsp;document.getElementById(\'myButton\').addEventListener(\'click\', a);&lt;br&gt;&amp;nbsp;document.getElementById(\'myButton\').addEventListener(\'click\', b); //不能用onclick&lt;br&gt;&amp;nbsp;function a() {&lt;br&gt;    &amp;nbsp;alert(\'普通事件1\'); //执行&lt;br&gt;&amp;nbsp;}&lt;br&gt;&amp;nbsp;function b() {&lt;br&gt;&amp;nbsp;    alert(\'普通事件2\');//执行&lt;br&gt;&amp;nbsp;}&lt;/pre&gt;&lt;p&gt;这里顺便提一下addEventListener这个函数&lt;/p&gt;&lt;p&gt;函数原型：addEventListener(event, function, useCapture)，重点是第三个参数，这个参数设置了事件的传递类型，默认值为 false, 即冒泡传递（先执行当前事件，并向上依次执行相同的事件），当值为 true 时, 事件使用捕获传递（从最外层开始执行事件，直到捕获到了指定的事件为止）。&lt;/p&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;                          &lt;/p&gt;',0,'2016-08-10 00:00:00','22',19),(15,1,'关于PHP代码修改后，无法立即生效的原因。','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;今天在修改线上PHP代码时，出现无法立即生效的现象。刚开始以为是缓存的原因，但是清除缓存文件也没有用。于是在网上找到了答案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;原来是opcache的参数设置的原因：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;opcache.revalidate_freq=3600 （之前的参数值）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;说明：如果opcache.revalidate_freq参数越大，服务器单位时间能接收的请求越多，但是加载代码的频率越低，会造成代码加载不及时的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Arial;&quot;&gt;opcache中opcache.revalidate_freq参数，设置的值为2-5为宜&lt;/span&gt;&lt;/p&gt;',0,'2018-12-05 00:00:00','23',51),(16,1,'php的开源类库phpass类的加密使用','','\n                                &lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;密码加密之前一直使用md5方式，md5加密的密码是可以强行破解的，网上查询发现可以使用bcrypt算法，安全系数高，目前YII框架和wordpress都在使用这个算法。&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;phpass是一个开源的类库，可以让我们方便的使用bcrpt加密算法&lt;/p&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; font-size: 18px; line-height: inherit; font-family: Arial, sans-serif; vertical-align: baseline; color: rgb(102, 102, 102);&quot;&gt;&lt;a href=&quot;http://www.openwall.com/phpass/&quot; target=&quot;_blank&quot;&gt;官网： &lt;/a&gt;&lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;http://www.openwall.com/phpass/&lt;/a&gt;&lt;/p&gt;\n&lt;pre&gt;// 引入类文件\n  require \'PasswordHash.php\';\n  \n  // 初始化散列器为不可移植，安全性更好。false加密字符串是60位，true加密字符是34位\n  $hasher = new PasswordHash(8, true);\n  \n  // 执行加密\n  $hashedPassword = $hasher-&amp;gt;HashPassword(\'test123\');\n  \n // 输出加密后的字符和对应的字符串长度\n echo $hashedPassword;\n 		\n echo strlen($hashedPassword);\n \n // 检查密码是否正确，第一个参数是密码的明文，第二个是加密后的字符串\n $hasher-&amp;gt;CheckPassword(\'test123\', $hashedPassword); // false\n \n $hasher-&amp;gt;CheckPassword(\'test1234\', $hashedPassword); // true\n&lt;/pre&gt;\n                                                                                        ',0,'2015-06-03 00:00:00','23',35),(17,1,'PHPExcel在TP3.2框架中的简单使用','','&lt;p&gt;下载phpexcel压缩包，地址：&lt;a href=&quot;https://github.com/PHPOffice/PHPExcel/tree/1.7.9&quot; target=&quot;_blank&quot;&gt;PHPExcel&lt;/a&gt;，该压缩包中有一些示例可以参考，基本涵盖所有情况导出示例。在Examples文件夹中。将压缩包中Classes文件里边的所有文件复制到tp中ThinkPHP\\Library\\Org\\Util目录下,并将PHPExcel.php文件改名为PHPExcel.class.php，如下图，tp的import引入文件时命名规则&lt;/p&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;\r\n&lt;pre&gt;  import(\'Org.Util.PHPExcel\');\r\n  \r\n  $objPHPExcel = new \\PHPExcel();\r\n  //定义配置\r\n  $title = \'商户进货列表\';\r\n  $topNumber = 2;//表头有几行占用\r\n  $xlsTitle = iconv(\'utf-8\', \'gb2312\', $title);//文件名称\r\n  $fileName = $title.date(\'_YmdHis\');//文件名称\r\n  $cellName  = array(\r\n \r\n //  表头\r\n $objPHPExcel-&amp;gt;getActiveSheet()-&amp;gt;setCellValue(\'A1\',\'订单号\');\r\n $objPHPExcel-&amp;gt;getActiveSheet()-&amp;gt;setCellValue(\'B1\', \'商户名\');\r\n $objPHPExcel-&amp;gt;getActiveSheet()-&amp;gt;setCellValue(\'C1\', \'产品名\');\r\n $objPHPExcel-&amp;gt;getActiveSheet()-&amp;gt;setCellValue(\'D1\', \'价格\');\r\n $objPHPExcel-&amp;gt;getActiveSheet()-&amp;gt;setCellValue(\'E1\', \'数量\');\r\n $objPHPExcel-&amp;gt;getActiveSheet()-&amp;gt;setCellValue(\'F1\', \'订货时间\');\r\n $objPHPExcel-&amp;gt;getActiveSheet()-&amp;gt;setCellValue(\'G1\', \'是否发货\');\r\n $objPHPExcel-&amp;gt;getActiveSheet()-&amp;gt;setCellValue(\'H1\', \'地址\');\r\n \r\n //处理数据\r\n \r\n $data //需要导出的数据;\r\n \r\n $key=2;\r\n foreach ($data as $k =&amp;gt;$v)\r\n {\r\n \r\n 	$objPHPExcel-&amp;gt;getActiveSheet()-&amp;gt;setCellValue(\'A$key\',$v[\'ordernum\']);\r\n 	$objPHPExcel-&amp;gt;getActiveSheet()-&amp;gt;setCellValue(\'B$key\', $v[\'merchant_name\']);\r\n 	$objPHPExcel-&amp;gt;getActiveSheet()-&amp;gt;setCellValue(\'C$key\', $v[\'name\']);\r\n 	$objPHPExcel-&amp;gt;getActiveSheet()-&amp;gt;setCellValue(\'D$key\', $v[\'price\']);\r\n 	$objPHPExcel-&amp;gt;getActiveSheet()-&amp;gt;setCellValue(\'E$key\', $v[\'num\']);\r\n 	$objPHPExcel-&amp;gt;getActiveSheet()-&amp;gt;setCellValue(\'F$key\', date(\'Y-m-d H:i:s\',$v[\'add_time\']));\r\n 	$objPHPExcel-&amp;gt;getActiveSheet()-&amp;gt;setCellValue(\'G$key\', $v[\'type_info\']);\r\n 	$objPHPExcel-&amp;gt;getActiveSheet()-&amp;gt;setCellValue(\'H$key\', $v[\'merchant_address\']);\r\n \r\n 	$key++;\r\n \r\n }\r\n \r\n //导出execl\r\n header(\'pragma:public\');\r\n header(\'Content-type:application/vnd.ms-excel;charset=utf-8;name=&quot;\'.$xlsTitle.\'&quot;\'.\'xls\');\r\n\r\n header(\'Content-Disposition:attachment;filename=$fileName.xls\');//attachment新窗口打印inline本窗口打印\r\n $objWriter = \\PHPExcel_IOFactory::createWriter($objPHPExcel, \'Excel5\');\r\n $objWriter-&amp;gt;save(\'php://output\');\r\n \r\n exit;\r\n&lt;/pre&gt;',0,'2016-02-03 00:00:00','23',42),(18,1,'PHP 设计模式之单例模式','','\r\n                                &lt;p&gt;&lt;/p&gt;&lt;div&gt;1、含义&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统全局地提供这个实例。它不会创建实例副本，而是会向单例类内部存储的实例返回一个引用。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、创建单例模式包含三个部分：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;（1）. 需要一个保存类的唯一实例的静态成员变量:&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\r\n&lt;pre&gt;private static $instance;\r\n&lt;/pre&gt;\r\n（2）. 构造函数和克隆函数必须声明为私有的，防止外部程序new类从而失去单例模式的意义:\r\n&lt;pre&gt;private function __construct()\r\n {\r\n      // TODO\r\n }\r\n private function __clone() //覆盖__clone()方法，禁止克隆\r\n {\r\n \r\n }\r\n&lt;/pre&gt;\r\n（3）. 必须提供一个访问这个实例的公共的静态方法，从而返回唯一实例的一个引用,如果不是静态方法，调用该方法需要new一个实例。这样也会失去单例模式的意义&lt;p&gt;&lt;/p&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;\r\n&lt;pre&gt;public static function getInstance()  \r\n {\r\n 	if(! (self::$_instance instanceof self) )\r\n 	{\r\n 	   self::$_instance = new self();\r\n 	}\r\n \r\n    return self::$_instance;\r\n}&lt;font color=&quot;#000000&quot; face=&quot;open sans, Helvetica Neue, Helvetica, Arial, sans-serif&quot;&gt;&lt;span style=&quot;white-space: normal;&quot;&gt;\r\n&lt;/span&gt;&lt;/font&gt;&lt;/pre&gt;&lt;div&gt;php中 instanceof有什么作用&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;作用：（1）判断一个对象是否是某个类的实例，&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;例子：&lt;/div&gt;\r\n&lt;pre&gt;class person\r\n  {\r\n  \r\n  	private static $instance;\r\n  \r\n  	private function __construct($arg)\r\n  	{\r\n  	    //TODO\r\n  	}\r\n \r\n     private function __clone() {}; //覆盖__clone()方法，禁止克隆\r\n \r\n 	public static function getInstance()\r\n 	{\r\n 		if(! (self::$_instance instanceof self) ) { // 判断是否已经存在实例\r\n \r\n 		    self::$_instance = new self(); // 用self调用静态变量 调用静态方法 self::todo()\r\n 		}\r\n \r\n 		    return self::$_instance;\r\n		}\r\n 	}\r\n \r\n     $person = person::getInstance();  // 实现多次调用都是共用同一个实例对象\r\n }&lt;font color=&quot;#000000&quot; face=&quot;open sans, Helvetica Neue, Helvetica, Arial, sans-serif&quot;&gt;&lt;span style=&quot;white-space: normal;&quot;&gt;\r\n&lt;/span&gt;&lt;/font&gt;&lt;/pre&gt;&lt;div&gt;单例模式在PHP中的应用场合：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;（1）、应用程序与数据库交互&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;一个应用中会存在大量的数据库操作，比如过数据库句柄来连接数据库这一行为，使用单例模式可以避免大量的new操作，因为每一次new操作都会消耗内存资源和系统资源。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;比如网站访问一个页面，页面上分为好几个模块，这些模块的数据都要从数据库单独取出，如果不用单例模式，每个模块都会new一个新的数据库实例对象&lt;/div&gt;                            ',0,'2015-03-04 00:00:00','23',52),(19,1,'php 设计模式之工厂模式','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当你有大量的实现同一接口的类的时候，在合适的时候实例化合适的类，如果把这些 new 分散到项目的各个角落，不仅会使业务逻辑变的混乱并且使得项目难以维护。这时候如果引进工厂模式的概念，就能很好的处理这个问题。我们还可以通过应用程序配置或者提供参数的形式让工厂类为我们返回合适的的实例。&lt;/p&gt;&lt;p&gt;工厂类，它把实例化类的过程放到各工厂类里头，专门用来创建其他类的对象。工厂模式往往配合接口一起使用，这样应用程序就不必要知道这些被实例化的类的具体细节，只要知道工厂返回的是支持某个接口的类可以很方便的使用了。下面简单举例说明下工厂类的使用。&lt;/p&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;\r\n&lt;pre&gt;   // 接口是一个纯粹的模块（里面的方法必须都是抽象的） 不同于抽象类\r\n  interface fruit{\r\n  \r\n      public function price(); // 接口的方法必须是public【默认public】，且不能有函数体\r\n  \r\n      public function num();\r\n  }\r\n \r\n  // new fruit(); // 接口不能实例化\r\n \r\n // 类实现接口\r\n class apple implements fruit{\r\n 	public function price(){ // 类必须实现接口的所有方法\r\n 		echo \'5 yuan\';\r\n 	}\r\n \r\n 	public function num(){\r\n 		echo &quot;100 ge&quot;;\r\n 	}\r\n }\r\n \r\n class banana implements fruit{\r\n 	public function price(){ // 类必须实现接口的所有方法\r\n 		echo \'6 yuan\';\r\n 	}\r\n \r\n 	public function num(){\r\n 		echo &quot;50 ge&quot;;\r\n 	}\r\n }\r\n \r\n class factory {\r\n \r\n 	public static function createObj($name) { // 静态工厂方法提高生产对象的效率\r\n \r\n 		return new $name();\r\n 	}\r\n }\r\n \r\n $obj1 = factory::createObj(\'apple\');\r\n $obj2 = factory::createObj(\'banana\');\r\n \r\n echo $obj1-&amp;gt;price(); // 5 yuan\r\n echo $obj2-&amp;gt;price(); // 6 yuan\r\n var_dump($obj1);\r\n var_dump($obj2);\r\n&lt;/pre&gt;&lt;br&gt;',0,'2015-03-06 00:00:00','23',38),(20,1,'git clone远程库所有分支','','&lt;div&gt;利用git开发， 有时候本地没有远程库的分支，解决办法&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;找一个干净目录，假设是git_work&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\r\n&lt;pre&gt; cd git_work\r\n git clone          //远程库地址 ,这样在git_work目录下得到一个project子目录\r\n cd project\r\n git branch -a      //列出所有远程分支名称如下：\r\n    remotes/origin/dev\r\n    remotes/origin/release\r\n git checkout -b dev origin/dev          //作用是checkout远程的dev分支，在本地起名为dev分支，并切换到本地的dev分支\r\n git checkout -b release origin/release  //作用参见上一步解释&lt;/pre&gt;\r\n这样，本地和远程仓库分支一致了',0,'2016-07-07 00:00:00','32',41),(21,1,'git多人协作的操作流程详解','','\r\n                                \r\n                                &lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。&lt;/p&gt;&lt;p&gt;要查看远程库的信息，用git remote：&lt;/p&gt;&lt;pre&gt;$ git remote&lt;br&gt; origin&amp;nbsp; &amp;nbsp; # 远程仓库名&lt;/pre&gt;&lt;p&gt;或者，用git remote -v显示更详细的信息：&lt;/p&gt;&lt;pre&gt;$ git remote -v&lt;br&gt;origin git@github.com:michaelliao/learngit.git (fetch)&lt;br&gt;origin git@github.com:michaelliao/learngit.git (push)&lt;/pre&gt;&lt;p&gt;上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。&lt;/p&gt;&lt;p&gt;推送分支&lt;/p&gt;&lt;p&gt;推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：&lt;/p&gt;&lt;pre&gt;$ git push origin master&lt;/pre&gt;&lt;p&gt;如果要推送其他分支，比如dev，就改成：&lt;/p&gt;&lt;pre&gt;$ git push origin dev&lt;/pre&gt;&lt;p&gt;但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？&lt;/p&gt;&lt;p&gt;master分支是主分支，因此要时刻与远程同步；&lt;/p&gt;&lt;p&gt;dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；&lt;/p&gt;&lt;p&gt;bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；&lt;/p&gt;&lt;p&gt;feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。&lt;/p&gt;&lt;p&gt;总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！&lt;/p&gt;&lt;p&gt;&lt;b&gt;抓取分支&lt;/b&gt;&lt;/p&gt;&lt;p&gt;多人协作时，大家都会往master和dev分支上推送各自的修改。&lt;/p&gt;&lt;p&gt;现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：&lt;/p&gt;&lt;pre&gt;$ git clone git@github.com:*****/***.git&lt;br&gt;Cloning into \'learngit\'...&lt;br&gt;remote: Counting objects: 40, done.&lt;br&gt;remote: Compressing objects: 100% (21/21), done.&lt;br&gt;remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0&lt;br&gt;Receiving objects: 100% (40/40), done.&lt;br&gt;Resolving deltas: 100% (14/14), done.&lt;/pre&gt;&lt;p style=&quot;margin-bottom: 1em; padding: 0px; border: 0px; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-stretch: inherit; line-height: inherit; vertical-align: baseline;&quot;&gt;当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看：&lt;br&gt;&lt;/p&gt;&lt;p&gt;\r\n&lt;/p&gt;\r\n&lt;pre&gt;$ git branch\r\n* master\r\n&lt;/pre&gt;\r\n现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：&lt;p&gt;&lt;/p&gt;&lt;pre&gt;$ git checkout -b dev origin/dev&lt;/pre&gt;\r\n现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：&lt;p&gt;&lt;/p&gt;&lt;pre&gt;$ git add env.txt             #1.添加改动文件到本地暂存区&lt;br&gt;$ git commit -m &quot;add env&quot;     #2.提交改动文件到本地暂存区&lt;br&gt;[dev 7a5e5dd] add env&lt;br&gt;&amp;nbsp;1 file changed, 1 insertion(+)&lt;br&gt;&amp;nbsp;create mode 100644 env.txt&lt;br&gt;$ git push origin dev         #3.推送改动文件到远程仓库对应dev分支上&lt;br&gt;Counting objects: 3, done.&lt;br&gt;Delta compression using up to 4 threads.&lt;br&gt;Compressing objects: 100% (2/2), done.&lt;br&gt;Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.&lt;br&gt;Total 3 (delta 0), reused 0 (delta 0)&lt;br&gt;To github.com:michaelliao/learngit.git&lt;br&gt;&amp;nbsp; &amp;nbsp;f52c633..7a5e5dd&amp;nbsp; dev -&amp;gt; dev&lt;/pre&gt;\r\n你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：&lt;p&gt;&lt;/p&gt;&lt;pre&gt;$ git add env.txt                 #1.添加改动文件到本地暂存区&lt;br&gt;$ git commit -m &quot;add new env&quot;     #2.提交改动文件到本地暂存区&lt;br&gt;[dev 7bd91f1] add new env&lt;br&gt;&amp;nbsp;1 file changed, 1 insertion(+)&lt;br&gt;&amp;nbsp;create mode 100644 env.txt&lt;br&gt;$ git push origin dev             #3.推送改动文件到远程仓库对应dev分支上&lt;br&gt;To github.com:michaelliao/learngit.git&lt;br&gt;&amp;nbsp;! [rejected]&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; dev -&amp;gt; dev (non-fast-forward)&lt;br&gt;error: failed to push some refs to \'git@github.com:michaelliao/learngit.git\'     #由于文件冲突提交失败&lt;br&gt;hint: Updates were rejected because the tip of your current branch is behind&lt;br&gt;hint: its remote counterpart. Integrate the remote changes (e.g.&lt;br&gt;hint: \'git pull ...\') before pushing again.&lt;br&gt;hint: See the \'Note about fast-forwards\' in \'git push --help\' for details.&lt;/pre&gt;\r\n推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：&lt;p&gt;&lt;/p&gt;&lt;pre&gt;$ git pull&lt;br&gt;There is no tracking information for the current branch.&lt;br&gt;Please specify which branch you want to merge with.&lt;br&gt;See git-pull(1) for details.&lt;br&gt;&amp;nbsp; &amp;nbsp; git pull &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;&lt;br&gt;If you wish to set tracking information for this branch you can do so with:&lt;br&gt;&amp;nbsp; &amp;nbsp; git branch --set-upstream-to=origin/&amp;lt;branch&amp;gt; dev&lt;/pre&gt;\r\ngit pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：&lt;p&gt;&lt;/p&gt;&lt;pre&gt;$ git branch --set-upstream-to=origin/dev dev    #指定本地dev分支与远程origin/dev分支的链接（与远程分支建立联系）&lt;br&gt;Branch \'dev\' set up to track remote branch \'dev\' from \'origin\'.&lt;/pre&gt;\r\n再pull：&lt;p&gt;&lt;/p&gt;&lt;pre&gt;$ git pull&lt;br&gt;Auto-merging env.txt&lt;br&gt;CONFLICT (add/add): Merge conflict in env.txt&lt;br&gt;Automatic merge failed; fix conflicts and then commit the result.&lt;/pre&gt;\r\n这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：&lt;p&gt;&lt;/p&gt;&lt;pre&gt;$ git commit -m &quot;fix env conflict&quot;&lt;br&gt;[dev 57c53ab] fix env conflict&lt;br&gt;$ git push origin dev&lt;br&gt;Counting objects: 6, done.&lt;br&gt;Delta compression using up to 4 threads.&lt;br&gt;Compressing objects: 100% (4/4), done.&lt;br&gt;Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.&lt;br&gt;Total 6 (delta 0), reused 0 (delta 0)&lt;br&gt;To github.com:michaelliao/learngit.git&lt;br&gt;&amp;nbsp; &amp;nbsp;7a5e5dd..57c53ab&amp;nbsp; dev -&amp;gt; dev&lt;/pre&gt;&lt;b&gt;\r\n因此，多人协作的工作模式通常是这样&lt;/b&gt;：&lt;p&gt;&lt;/p&gt;&lt;p&gt;1.首先，可以试图用git push origin &amp;lt;branch-name&amp;gt;推送自己的修改；&lt;/p&gt;&lt;p&gt;2.如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；&lt;/p&gt;&lt;p&gt;3.如果合并有冲突，则解决冲突，并在本地提交；&lt;/p&gt;&lt;p&gt;4.没有冲突或者解决掉冲突后，再用git push origin &amp;lt;branch-name&amp;gt;推送就能成功！&lt;/p&gt;&lt;p&gt;5.如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &amp;lt;branch-name&amp;gt; origin/&amp;lt;branch-name&amp;gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;git使用总结：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;1.查看远程库信息，使用git remote -v；&lt;/p&gt;&lt;p&gt;2.本地新建的分支如果不推送到远程，对其他人就是不可见的；&lt;/p&gt;&lt;p&gt;3.从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；&lt;/p&gt;&lt;p&gt;4.在本地创建和远程分支对应的分支并建立关系，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；&lt;/p&gt;&lt;p&gt;5.建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；&lt;/p&gt;&lt;p&gt;6.从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;                                                        ',0,'2016-06-08 00:00:00','32',67),(22,1,'本地磁盘映射与apache反向代理参数设置','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;由于工作需要，需要在公司内网的管理网站上，播放存储在别的磁盘下的视频，其中有利用了canvas视频截图画图功能，涉及到反向代理。&lt;/p&gt;&lt;p&gt;在apache的vhost.conf文件中配置反向代理：&lt;/p&gt;&lt;div&gt;#管理系统网站域名配置&lt;/div&gt;&lt;div&gt;&amp;lt;VirtualHost *:80&amp;gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; DocumentRoot \'D:php/WWW/FTM\'&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; ServerName www.ftm.com&lt;/div&gt;&lt;div&gt;&amp;lt;Directory \'D:php/WWW/FTM\'&amp;gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //省略…&lt;/div&gt;&lt;div&gt;&amp;lt;/Directory&amp;gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; // 反向代理参数位置&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; ProxyRequests Off&lt;/div&gt;&lt;div&gt;&amp;lt;Proxy *&amp;gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; Order deny,allow&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; Allow from all&lt;/div&gt;&lt;div&gt;&amp;lt;/Proxy&amp;gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; ProxyPass&amp;nbsp; /share&amp;nbsp; &amp;nbsp; &amp;nbsp;http://www.videos.com/share&amp;nbsp; &amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; #表示当遇到http://www.ftm.com/share&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; #就会跳转到 http://www.videos.com /share 请求数据 【share表示磁盘下某个目录名】&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; ProxyPassReverse&amp;nbsp; /share&amp;nbsp; &amp;nbsp; http://www.videos.com /share&amp;nbsp; &amp;nbsp;#同上&lt;/div&gt;&lt;div&gt;&amp;lt;/VirtualHost&amp;gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;#映射一个专门存视频的共享磁盘到本地并配置域名&lt;/div&gt;&lt;div&gt;&amp;lt;VirtualHost *:80&amp;gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;DocumentRoot \'Z:\'&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;ServerName www.videos.com&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;Directory \'Z:\'&amp;gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;//省略…&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;/Directory&amp;gt;&lt;/div&gt;&lt;div&gt;&amp;lt;/VirtualHost&amp;gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;//注：在http.conf里取消下面注释&lt;/div&gt;&lt;div&gt;#LoadModule proxy_module modules/mod_proxy.so&amp;nbsp;&lt;/div&gt;&lt;div&gt;#LoadModule proxy_http_module modules/mod_proxy_http&lt;/div&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;',0,'2017-06-06 00:00:00','25',49),(23,1,'Linux下修改php 配置文件的上传文件大小参数','','\r\n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;因为php web默认上传文件大小有限，需要上传大文件时需要修改php.ini文件。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 一.. 在php.ini文件中找到 File Uploadsh区域修改以下几个参数：&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 1. file_uploads = on ;是否允许通过HTTP上传文件的开关，默认为ON即是开；&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 2. upload_tmp_dir ;文件上传至服务器上存储临时文件的地方，如果没指定就会用系统默认的临时文件夹(moodle可以不改)；&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 3. upload_max_filesize = 8m ;允许上传文件大小的最大值；&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 二.. 在php.ini文件中找到 Data Handling区域修改以下参数:&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 1. post_max_size = 8m ;指通过表单POST给PHP的所能接收的最大值，包括表单里的所有值,默认为8M;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 三.. 设上述四个参数后，上传小于8M的文件一般不成问题。但如果上传大于8M的文件，还得设置以下参数:&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Resource Limits 区域: max_execution_time = 600 ;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 每个PHP页面运行的最大时间值(秒)，默认30秒 max_input_time = 600 ;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 每个PHP页面接收数据所需的最大时间，默认60秒 memory_limit = 8m ;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 每个PHP页面所吃掉的最大内存，默认8M&lt;/div&gt;\r\n                                                                                        ',0,'2017-02-01 00:00:00','23,17',56),(24,1,'用JQuery编写一个属于自己的插件','','&lt;p&gt;我们在开发中，用到的一些插件，常常会看到这样的代码，$.fn.pluginName ,其实这是jq开发插件的一个标准格式，接下来，我们来看看用JQ开发一个插件的具体步骤：&lt;/p&gt;&lt;p&gt;第一步：首先准备好一个架子，如下：&lt;/p&gt;&lt;pre&gt;;(function($){   //注意前面还有一个分号（;）&lt;br&gt;})(jQuery);&lt;/pre&gt;&lt;p&gt;解释：这个架子是你编写插件代码要写入的空间，：&lt;/p&gt;&lt;p&gt;1）在jQuery环境下封装自己的插件，首先为避免与其他库的冲突，需要在插件的后面传一个jQuery参数进去，对应的函数里面的参数写入$&lt;/p&gt;&lt;p&gt;2）未避免出现问题，需在插件的前后加入分号（分号的增加并不会影响程序的运行）&lt;/p&gt;&lt;p&gt;第二步：原来的框架里面再准备一个架子&lt;/p&gt;&lt;pre&gt;;(function($){&lt;br&gt;   $.fn.tab = function(options){&lt;br&gt;      var defaults = {&lt;br&gt;           //各种参数，各种属性&lt;br&gt;          }&lt;br&gt;     var options = $.extend(defaults,options);&lt;br&gt;     this.each(function(){&lt;br&gt;         //各种功能&lt;br&gt;     });&lt;br&gt;     return this;&lt;br&gt;   }&lt;br&gt;})(jQuery);&lt;/pre&gt;&lt;p&gt;解释：&lt;/p&gt;&lt;p&gt;$.fn 是jQuery官方提供的一个标准化的开发模式 ，目的是给JQ新增一个方法， 这个tab是你这个功能插件的名字，可任意改变名字。&lt;/p&gt;&lt;p&gt;var options = $.extend(defaults,options);&amp;nbsp; 这个是利用extend方法把options的参数与 defaults参数合并起来，如果有相同的属性，则，defaults属性值会被覆盖&lt;/p&gt;&lt;p&gt;也就是options继承了defaults对象的方法以及属性。这个defaults和options名字是可以随意更改的，只要是满足js的命名规范。&lt;/p&gt;&lt;p&gt;this.each(function(){});这个就是选中的元素要运行的代码，全部写在里面&lt;/p&gt;&lt;p&gt;调用方式：&lt;/p&gt;&lt;pre&gt;&amp;lt;div id=&quot;test&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;br&gt;$(&quot;#test&quot;).tab();&lt;/pre&gt;&lt;p&gt;return this;&amp;nbsp; 返回元素对象，jQuery最强大的特性之一莫过于链式操作啦，此时你可以在$(“#test”).tab()后面追加操作，，如下:&lt;/p&gt;&lt;pre&gt;$(&quot;#test&quot;).tab().css(&quot;background&quot;,&quot;red&quot;);&lt;/pre&gt;&lt;p&gt;要是，插件功能比较复杂，可以用这种格式：&lt;/p&gt;&lt;pre&gt;;(function($){&lt;br&gt;   $.fn.tab = {    //用json来添加多个方法或属性&lt;br&gt;      init：function(options){},&lt;br&gt;       ……&lt;br&gt;  }&lt;br&gt;})(jQuery);&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;此时，$.fn.tab是一个全局对象变量，用$.fn.tab.init()这种形式来访问&lt;/p&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;',0,'2016-07-08 00:00:00','22',21),(25,1,'js中(function(){…})()立即执行函数理解以及各种函数写法','','\r\n                                &lt;p&gt;&lt;b&gt;1、什么是闭包&lt;/b&gt;&lt;/p&gt;&lt;p&gt;闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。闭包的特点：&lt;/p&gt;&lt;p&gt;（1） 作为一个函数变量的一个引用，当函数返回时，其处于激活状态。&lt;/p&gt;&lt;p&gt;（2）一个闭包就是当一个函数返回时，一个没有释放资源的栈区。&lt;/p&gt;&lt;p&gt;简单的说，Javascript允许使用内部函数—即函数定义和函数表达式位于另一个函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。&lt;/p&gt;&lt;p&gt;函数声明、函数表达式、匿名函数&lt;/p&gt;&lt;p&gt;函数声明：function fnName () {…};使用function关键字声明一个函数，再指定一个函数名，叫函数声明。&lt;/p&gt;&lt;p&gt;函数表达式 var fnName = function () {…};使用function关键字声明一个函数，但未给函数命名，最后将匿名函数赋予一个变量，叫函数表达式，这是最常见的函数表达式语法形式。&lt;/p&gt;&lt;p&gt;匿名函数：function () {}; 使用function关键字声明一个函数，但未给函数命名，所以叫匿名函数，匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等。&lt;/p&gt;&lt;p&gt;函数声明和函数表达式不同之处在于，一、Javascript引擎在解析javascript代码时会‘函数声明提升’（Function declaration Hoisting）当前执行环境（作用域）上的函数声明，而函数表达式必须等到Javascirtp引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式，二、函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以fnName()形式调用 。以下是两者差别的两个例子。&lt;/p&gt;&lt;pre&gt;&amp;nbsp;fnName();&lt;br&gt;&amp;nbsp;function fnName(){&lt;br&gt;&amp;nbsp; &amp;nbsp;...&lt;br&gt; }&lt;br&gt;//正常，因为‘提升’了函数声明，函数调用可在函数声明之前&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;br&gt;&amp;nbsp;fnName();&lt;br&gt;&amp;nbsp;var fnName=function(){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;...&lt;br&gt; }&lt;br&gt;//报错，变量fnName还未保存对函数的引用，函数调用必须在函数表达式之后&lt;br&gt;var fnName=function(){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;alert(\'Hello World\');&lt;br&gt;}();&lt;br&gt;//函数表达式后面加括号，当javascript引擎解析到此处时能立即调用函数&lt;br&gt;function fnName(){&lt;br&gt;&amp;nbsp; &amp;nbsp;alert(\'Hello World\');&lt;br&gt;}();&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;br&gt;//不会报错，但是javascript引擎只解析函数声明，忽略后面的括号，函数声明不会被调用&lt;br&gt;function(){&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;console.log(\'Hello World\');&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;}();&lt;br&gt;//语法错误，虽然匿名函数属于函数表达式，但是未进行赋值操作，&lt;br&gt;//所以javascript引擎将开头的function关键字当做函数声明，报错：要求需要一个函数名&lt;/pre&gt;&lt;p&gt;在理解了一些函数基本概念后，回头看看( function(){…} )()和( function (){…} () )这两种立即执行函数的写法，最初我以为是一个括号包裹匿名函数，并后面加个括号立即调用函数，当时不知道为什么要加括号，后来明白，要在函数体后面加括号就能立即调用，则这个函数必须是函数表达式，不能是函数声明。&lt;/p&gt;&lt;pre&gt;(function(a){&lt;br&gt;&amp;nbsp;   console.log(a);&amp;nbsp; &amp;nbsp;//firebug输出123,使用（）运算符&lt;br&gt;})(123);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;br&gt;(function(a){&lt;br&gt;&amp;nbsp; &amp;nbsp;console.log(a);&amp;nbsp; &amp;nbsp;//firebug输出1234，使用（）运算符&lt;br&gt;}(1234));&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;!function(a){&lt;br&gt;&amp;nbsp; &amp;nbsp;console.log(a);&amp;nbsp; &amp;nbsp;//firebug输出12345,使用！运算符&lt;br&gt;}(12345);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;+function(a){&lt;br&gt;&amp;nbsp; &amp;nbsp;console.log(a);&amp;nbsp; &amp;nbsp;//firebug输出123456,使用+运算符&lt;br&gt;}(123456);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;-function(a){&lt;br&gt;&amp;nbsp; console.log(a);&amp;nbsp; &amp;nbsp;//firebug输出1234567,使用-运算符&lt;br&gt;}(1234567);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;var fn=function(a){&lt;br&gt;&amp;nbsp; console.log(a);&amp;nbsp; &amp;nbsp;//firebug输出12345678，使用=运算符&lt;br&gt;}(12345678)&lt;/pre&gt;&lt;p&gt;javascript中没用私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉；&lt;/p&gt;&lt;p&gt;根据javascript函数作用域链的特性，可以使用这种技术可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以( function(){…} )()内部定义的变量不会和外部的变量发生冲突，俗称“匿名包裹器”或“命名空间”。&lt;/p&gt;&lt;p&gt;JQuery使用的就是这种方法，将JQuery代码包裹在( function (window,undefined){…jquery代码…} (window)中，在全局作用域中调用JQuery代码时，可以达到保护JQuery内部变量的作用。&lt;/p&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;                            ',0,'2017-05-02 00:00:00','22',41),(7,1,'centos7编译安装php7的关键参数配置详解','','\r\n&lt;pre&gt; ./configure --prefix=/usr/local/php \\        #指定php的安装路径\r\n--with-config-file-path=/usr/local/php/etc \\  #php配置文件所在目录\r\n--enable-fpm \\                                #表示激活PHP-FPM方式服务,即FactCGI方式运行PHP服务。\r\n--with-fpm-user=www \\                         #在lamp/lnmp环境中，要与apache或nginx的用户用户组一致\r\n--with-fpm-group=www \\                        #在lamp/lnmp环境中，要与apache或nginx的用户用户组一致\r\n--with-curl \\                                 #打开curl浏览工具的支持\r\n--with-freetype-dir \\                         #打开对freetype字体库支持\r\n--with-gd \\                                   #打开gd库的支持              \r\n--with-iconv-dir \\\r\n--with-libdir=lib64 \\\r\n--with-libxml-dir \\\r\n--with-mysqli \\\r\n--with-mysql \\\r\n--with-openssl \\\r\n--with-pcre-regex \\\r\n--with-pdo-mysql \\                            #PHP7链接mysql的扩展\r\n--with-pdo-sqlite \\\r\n--with-pear \\\r\n--with-png-dir \\\r\n--with-xmlrpc \\\r\n--with-xsl \\\r\n--with-zlib \\\r\n--with-apxs2 \\\r\n--enable-bcmath \\\r\n--enable-libxml \\\r\n--enable-inline-optimization \\\r\n--enable-gd-native-ttf \\\r\n--enable-mbregex \\\r\n--enable-mbstring \\\r\n--enable-opcache \\                          #可以开启PHP自带的opcache开启性能加速\r\n--enable-pcntl \\\r\n--enable-shmop \\\r\n--enable-soap \\\r\n--enable-sockets \\\r\n--enable-sysvsem \\\r\n--enable-xml \\\r\n--enable-zip \\\r\n--enable-mysqlnd\r\n&lt;/pre&gt;&lt;br&gt;',0,'2018-12-03 00:00:00','23,17',46),(26,1,'纯css伪类实现标签显示隐藏','','\r\n                                &lt;p&gt;&amp;nbsp;CSS样式：&lt;/p&gt;&lt;pre&gt;&amp;lt;style type=&quot;text/css&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;body,h3,ul{&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;margin:0px;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;padding:0px;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;}&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;ul &amp;gt; li {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;list-style:none;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;height:30px;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;width:200px;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;background-color:#ccc;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;color:#fff;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;text-align: center;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;cursor:pointer;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;}&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;#wrap {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;margin: 200px 0px 0px 200px;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;height:120px;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;width: 600px;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;position:relative;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;border:1px solid red;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;}&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;.container {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;position:absolute;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;top:0px;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;height:100%;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;width:400px;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;left:200px;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;display:none;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;background-color:blue;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;}&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; ul&amp;gt;li:hover .container{    #关键实现的代码&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;background-color:blue;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;display: block;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;}&lt;br&gt;&amp;nbsp;&amp;lt;/style&amp;gt;&lt;/pre&gt;&lt;p&gt;HTML：&lt;/p&gt;&lt;pre&gt;&amp;nbsp; &amp;lt;div id=&quot;wrap&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;lt;ul&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;lt;li&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;h3&amp;gt;选项1&amp;lt;/h3&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;lt;div class=&quot;container1 container&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 选项1选项1选项1选项1&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;/li&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;li&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;h3&amp;gt;选项2&amp;lt;/h3&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;container&quot;&amp;gt;选项2选项2选项2选项2&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;/li&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;li&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;h3&amp;gt;选项3&amp;lt;/h3&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;container&quot;&amp;gt;选项3选项3选项3选项3&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;/li&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;li&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;lt;h3&amp;gt;选项4&amp;lt;/h3&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;lt;div class=&quot;container&quot;&amp;gt;选项4选项4选项4选项4&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;/li&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;/ul&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;lt;/div&amp;gt;&lt;/pre&gt;&lt;p&gt;如图所示：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20181205/ddab2fcc9091904a763cd9f409a85183.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 672px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;                            ',0,'2018-12-05 00:00:00','21',64),(27,1,'windows安装mongodb步骤','','\n                                &lt;div&gt;首先当然是下载 MongoDB 了,这里是官网下载地址:&amp;nbsp;&lt;a href=&quot;https://www.mongodb.com/download-center?jmp=nav#community&quot; target=&quot;_blank&quot; style=&quot;background-color: rgb(255, 255, 255);&quot;&gt;MongoDB官网下载地址&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;点击进入后会看到下载页面【Community Server】&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;点击下一步安装过程中注意不要勾选[mongodb-compass];&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;创建数据目录&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;MongoDB 将数据目录存储在 db 目录下。但是这个数据目录不会主动创建，我们在安装完成后需要创建它。请注意，数据目录应该放在根目录下（(如： C:\\ 或者 D:\\ 等 )。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;我默认在C：盘 安装了 mongodb，现在让我们创建一个 mongodb-data 的目录然后在 mongodb-data 目录里创建 db(数据库) 目录和 log(日志) 目录。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;注:以下所有命令都请使用管理员身份打开命令窗口执行&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;cd c:\\&amp;nbsp; &amp;nbsp; //进入c盘根目录&lt;br&gt;mkdir mongodb-data&amp;nbsp; &amp;nbsp; //新建 mongodb-data 文件夹&lt;br&gt;cd mongodb-data&amp;nbsp; &amp;nbsp; //进入 mongodb-data 文件夹&lt;br&gt;mkdir db,log&amp;nbsp; &amp;nbsp; //分别创建 db(数据库) 文件夹,log(日志) 文件夹&lt;/pre&gt;&lt;p&gt;使用命令来启动 MongoDB 服务器&lt;/p&gt;&lt;p&gt;我的 MongoDB 路径 C:\\Program Files\\MongoDB\\ ,服务启动需 bin 目录下的 mongod.exe&lt;/p&gt;&lt;pre&gt;\'C:\\Program Files\\MongoDB\\Server\\3.4\\bin\\mongod.exe\' --dbpath \'&lt;a href=&quot;C:\\mongodb-data\\db\\&quot;&gt;C:\\mongodb-data\\db\\&lt;/a&gt;\'&lt;/pre&gt;&lt;p&gt;注: bin 目录下的文件对应不同的功能&lt;/p&gt;&lt;p&gt;mongod.exe　　– MongoDB 的服务,通常用作启动服务用&lt;/p&gt;&lt;p&gt;mongo.exe　　– MongoDB 的客户端,使用命令工具查询操作数据库&lt;/p&gt;&lt;p&gt;启动成功后，我们可以运行 C:\\Program Files\\MongoDB\\Server\\3.4\\bin\\mongo.exe&amp;nbsp; 查看版本号等信息&lt;/p&gt;&lt;p&gt;创建 MongoDB 的 windows 服务&lt;/p&gt;&lt;p&gt;通过上面的方法启动了 MongoDB 服务后,会有一个问题,每次启动服务都得使用&lt;/p&gt;&lt;pre&gt;\'C:\\Program Files\\MongoDB\\Server\\3.4\\bin\\mongod.exe\' --dbpath &lt;a href=&quot;C:\\mongodb-data\\db\\&quot;&gt;C:\\mongodb-data\\db\\&lt;/a&gt;&lt;/pre&gt;&lt;p&gt;真的很不方便,于是我创建一个名为 mongodb 的 windows 服务,创建之前需要创建一个数据库的日志文件 mongodb.log ,使用命令窗口&lt;/p&gt;&lt;pre&gt;cd C:\\mongodb-data\\log\\&amp;nbsp; &amp;nbsp; //进入日志目录&lt;br&gt;touch mongodb.log&amp;nbsp; &amp;nbsp; //创建日志文件&lt;/pre&gt;&lt;p&gt;我使用下面的命令创建服务,我的服务名为 mongodb (注意是小写,方便每次启动服务的时候输入服务名)&lt;/p&gt;&lt;pre&gt;\'C:\\Program Files\\MongoDB\\Server\\3.4\\bin\\mongod.exe\' --logpath C:\\mongodb-data\\log\\mongodb.log --logappend --dbpath C:\\mongodb-data\\db\\ --serviceName &quot;mongodb&quot; --install&lt;/pre&gt;&lt;p&gt;创建成功后,启动 MongoDB 服务,服务启动后,命令窗口可以关闭&amp;nbsp; 【注意自己的安装目录路径】&lt;/p&gt;&lt;pre&gt;net start mongodb&amp;nbsp; &amp;nbsp; //启动 MongoDB 服务&lt;br&gt;net stop mongodb&amp;nbsp; &amp;nbsp; //停止 MongoDB 服务&lt;/pre&gt;&lt;p&gt;菜鸟教程网：&lt;a href=&quot;http://www.runoob.com/mongodb/mongodb-window-install.html&quot; target=&quot;_blank&quot;&gt;mongodb安装教程&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;\n                                                                                        ',0,'2017-07-26 00:00:00','12',43),(28,1,'git提交或更新代码的步骤','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;大致的步骤为:&lt;/b&gt;&lt;/p&gt;&lt;p&gt;1.add xxx：把需要提交的文件先添加到本地暂存区。&lt;/p&gt;&lt;p&gt;2.commit -m \'msg:xxx\'：把改动的文件提交到本地仓库，并添加说明信息&lt;/p&gt;&lt;p&gt;3.pull ：这个先 commit 再 pull，是为了防止在提交代码的时候，其他人已经提交了新的代码到远程仓库，导致本地和远程代码不一致提交失败&lt;/p&gt;&lt;p&gt;4.push ：把提交到本地的仓库的代码推送到远程指定仓库 git push origin dev&lt;/p&gt;&lt;p&gt;&lt;b&gt;详解：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;commit 是为了告诉 git 我这次提交改了哪些东西,不然你只是改了但是 git 不知道你改了,也就无从判断比较;&lt;/p&gt;&lt;p&gt;pull是为了本地 commit 和远程commit 的对比记录,git 是按照文件的行数操作进行对比的,如果同时操作了某文件的同一行那么就会产生冲突,git 也会把这个冲突给标记出来,这个时候就需要先把和你冲突的那个人拉过来问问保留谁的代码,然后在 git add &amp;amp;&amp;amp; git commit &amp;amp;&amp;amp; git pull 这三连,再次 pull 一次是为了防止再你们协商的时候另一个人给又提交了一版东西,如果真发生了那流程重复一遍,通常没有冲突的时候就直接给你合并了,不会把你的代码给覆盖掉&lt;/p&gt;&lt;p&gt;出现代码覆盖或者丢失的情况:比如A B两人的代码pull 时候的版本都是1,A在本地提交了2,3并且推送到远程了,B 进行修改的时候没有commit 操作,他先自己写了东西,然后 git pull 这个时候 B 本地版本已经到3了,B 在本地版本3的时候改了 A 写过的代码,再进行了git commit &amp;amp;&amp;amp; git push 那么在远程版本中就是4,而且 A 的代码被覆盖了,所以说所有人都要先 commit 再 pull,不然真的会覆盖代码的&lt;/p&gt;&lt;p&gt;两个互相合并的唯一区别就是 A-&amp;gt;B 的时候 B 分支上会产生一个 merge_commit 的信息,这个时候 B 是合并状态而 A 未合并状态,如果现在没有发生任何改动执行 B-&amp;gt;A 就直接切换过去了,连 merge_commit 都不会生成了&lt;/p&gt;&lt;p&gt;比如你从一个git log为1,2,3,4,5,6的远程库拉取到了本地,&lt;/p&gt;&lt;p&gt;另一个同事也拉取了同样的代码,而且你的同事先于你提交到远程了,&lt;/p&gt;&lt;p&gt;此时远程的版本是1,2,3,4,5,6,7_new,8_new,&lt;/p&gt;&lt;p&gt;而你当前只是本地的版本1,2,3,4,5,6,7_local,8_local,9_local&lt;/p&gt;&lt;p&gt;从这里你就能看出你前一部分和远程的一样,后一部分和远程的不一样,&lt;/p&gt;&lt;p&gt;这个时候你不能正常推送上去的,如果你采取git push origin master --force&lt;/p&gt;&lt;p&gt;那么远程的版本就变成了1,2,3,4,5,6,7_local,8_local,9_local&lt;/p&gt;&lt;p&gt;之前你同事推送的7_new,8_new这两次推送被覆盖了,这不是大家想要的情况&lt;/p&gt;&lt;p&gt;因此需要git pull来将本地的版本合并成这样1,2,3,4,5,6,7_new,7_local,8_local,8_new,9_local,10_commit_merge&lt;/p&gt;&lt;p&gt;远程和本地的排序是按当时 commit 的时间来排的,最后一个10_commit_merge就是你本地和远程合并的标志,最后你推送到远程仓库的应该也是这个,&lt;/p&gt;&lt;p&gt;因为你们操作的是同一个库始终要保持代码的同步,所以一旦版本库发生改动同一分支下的所有人都要跟着去同步他,因为各开发各的直接往上推 git 还没智能到帮你处理冲突的地步&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;更新代码但不提交本地改动的代码：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果本地工作还没有完成，不想提交代码，但又要pull更新远程仓库的代码,可以用stash命令：&lt;/p&gt;&lt;pre&gt;git stash&amp;nbsp; &amp;nbsp; &amp;nbsp; // 先将当前改动存在栈中&lt;br&gt;git pull origin 分枝名&amp;nbsp; &amp;nbsp; // 拉取代码&lt;br&gt;git stash pop&amp;nbsp; &amp;nbsp;// 取出刚刚保存的改动&lt;/pre&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;',0,'2016-06-09 00:00:00','32',39),(29,1,'git删除本地或远程仓库的文件或目录','','\r\n &lt;p&gt;&lt;/p&gt;                              \r\n &lt;pre&gt;git rm -r –cached a/2.txt&amp;nbsp; &amp;nbsp; //删除a文件夹下的2.txt文件&amp;nbsp; &amp;nbsp;删除a文件夹git rm -r –cached a&lt;br&gt;git commit -m “删除a目录下的2.txt文件”&lt;br&gt;git push origin master&amp;nbsp; (提交到远程master分支)&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;注：1.&amp;nbsp; git rm&amp;nbsp; file_path&amp;nbsp; &amp;nbsp; &amp;nbsp;//删除本地和远程仓库的文件&amp;nbsp; &amp;nbsp;删除文件夹 用 git rm -r&amp;nbsp; file_path&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 2.&amp;nbsp; git rm –cached file_path&amp;nbsp; &amp;nbsp;// 当我们需要删除暂存区或远程仓库上的文件, 但本地的又不想删除文件 用 git rm -r&amp;nbsp; –cached&amp;nbsp; file_path&lt;/div&gt;\r\n                                                                                        ',0,'2016-07-06 00:00:00','32',66),(30,1,'mysql decimal类型与decimal长度用法详解','','\r\n                                &lt;div&gt;三者的区别介绍&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;float:浮点型，含字节数为4，32bit，数值范围为-3.4E38~3.4E38（7个有效位）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;double:双精度实型，含字节数为8，64bit数值范围-1.7E308~1.7E308（15个有效位）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;decimal:数字型，128bit，不存在精度损失，常用于银行帐目计算。（28个有效位）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;decimal(a,b)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;参数说明&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;a指定指定小数点左边和右边可以存储的十进制数字的最大个数，最大精度38。&lt;/div&gt;&lt;div&gt;b指定小数点右边可以存储的十进制数字的最大个数。小数位数必须是从 0 到 a之间的值。默认小数位数是 0。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如：decimal&lt;span style=&quot;color: rgb(51, 51, 51); font-family: simsun; font-size: 14px;&quot;&gt;&amp;nbsp;(5,2) --&amp;gt; 345.24&amp;nbsp; 数据保存入库时，小数点前后的部分不超过5个数，并且小数点最后一位四舍五入&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: simsun; font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;simsun&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;simsun&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;simsun&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;数值存储范围越小的精度越高，存储数值范围越大，精度就越不准确，如果存储正常金额的情况下，使用money，好处在于可以存储不指定的小数点位数的数值，比较真实。如果对于既要求精度，又固定小数点位数的数值存储，采用decimal（numeric），优点在于可以自定义小数点位数，精度高。如特殊情况，如数值范围巨大只能用float（real）类型了，此类型一般不提倡使用。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\r\n                                                                                        ',0,'2018-12-14 00:00:00','11',56),(31,1,'vue.js中watch、methods、computed的区别及使用','','\n                                &lt;pre&gt;&amp;lt;div id=&quot;methods-computed&quot;&amp;gt;&lt;br&gt;    &amp;lt;div&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;li&amp;gt;&amp;lt;input type=&quot;text&quot; name=&quot;val&quot; id=&quot;val&quot;&amp;nbsp; v-model=&quot;a&quot;&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;span&amp;gt;a值改变了：{{changeA}}&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;li&amp;gt;&amp;lt;input type=&quot;text&quot; name=&quot;val&quot; id=&quot;val&quot;&amp;nbsp; v-model=&quot;b&quot;&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;span&amp;gt;b值改变了：{{changeB}}&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;a href=&quot;#&quot;&amp;gt;{{listenAll()}}&amp;lt;/a&amp;gt;&lt;br&gt;    &amp;lt;/div&amp;gt;&lt;br&gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;&lt;pre&gt;var vm = new Vue({&lt;br&gt;&amp;nbsp; &amp;nbsp; el: \'#methods-computed\',&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;data: { a: \'a de zhi \',b:\'b de zhi \'},&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; //*******实时监听属性值改变，开发一般不会用watch来监听属性*********//&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;watch: { // 监听data里对应key的value值的变化，并触发相应的方法. 可以在input标签里使用v-model=\'a\',监听a的值的变化&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; // 如果 `a` 发生改变，这个函数就会运行&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; a: function (newA, oldA) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// console.log(\'a的值改变了：\'+this.a)&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; },&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;// 如果 `b` 发生改变，这个函数就会运行&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; b:function(newA, oldA) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;// console.log(\'b的值改变了：\'+this.b)&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; },&lt;br&gt;&amp;nbsp; &amp;nbsp; //********computed依赖于缓存，只有属性值改变是才会重新赋值，反之则返回上一次的值 效率更高********//&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;computed:{&amp;nbsp; //计算属性&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; changeA:function() {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(\'当前a的值：\'+this.a)&amp;nbsp; // 注：当属性值改变时，只有方法体内用到了该属性值才会被调用&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; },&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; changeB:function() {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(\'当前b的值：\'+this.b)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;},&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt; //********任意属性值发生改变都会被调用（注：必须用{{listenAll()}} 调用才会生效），一般用于事件绑定函数调用。********//&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;methods:{&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; listenAll:function(){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;console.log(\'当前a的值：\'+this.a,\'当前b的值：\'+this.b)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}&lt;br&gt;});&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                            ',0,'2018-12-14 00:00:00','38',27),(32,1,'mysql的between是否包含边界问题','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;mysql的sql语句中可以使用between来限定一个数据的范围，例如：&lt;/p&gt;&lt;p&gt;select * from user where userId between 5 and 7;&amp;nbsp;&lt;/p&gt;&lt;p&gt;查询userId为5、6，7的user，userId范围是包含边界值的，也等同如下查询：&lt;/p&gt;&lt;p&gt;select * from user where userId &amp;gt;= 5 and userId &amp;lt;= 7;&amp;nbsp;&lt;/p&gt;&lt;p&gt;很多地方都提到between是给定的范围是大于等第一值，小于第二个值，其实这是不对的。此前我一直也是这么认为，通过实验，结论是包含两边的边界值，如果实在拿不准，可以采用&amp;gt;= 、&amp;lt;=的方式来指定条件。&lt;/p&gt;&lt;p&gt;另外 not between的范围是不包含边界值。&lt;/p&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;',0,'2016-02-04 00:00:00','11',17),(33,1,'vue-cli之webpack的proxyTable配置详解','','\n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre&gt;proxyTable: {&lt;br&gt;&amp;nbsp; &amp;nbsp; \'/api\': {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; target: \'http://www.vuetpadmin.com\',&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; changeOrigin: true, //是否跨域&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; secure: false,&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; pathRewrite: { // 路由重写 (默认可以不配置pathRewrite，即请求接口时URL会包含http://www.xxx.com/api/admin/index)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; \'^/api\': \'\'&amp;nbsp; &amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;},&lt;br&gt;详解：&lt;br&gt;&amp;nbsp;1.不用\'/api\' 这种格式配置的话，发起http请求必须写全完整的接口路径，并且会报跨域错误&lt;br&gt;&amp;nbsp;2.\'/api\' 表示我们在写url的时候，只用写成/api/admin/index/login 就可以代表 http://www.vuetpadmin.com/admin/index/login&lt;br&gt;&amp;nbsp;3.&amp;nbsp; pathRewrite: { \'^/api\': \'\'} //为空表示请求接口: /api/admin/index/login 就会重写为 http://www.vuetpadmin.com/admin/index/login （舍去了api）&lt;br&gt;&amp;nbsp;4.&amp;nbsp; pathRewrite: { \'^/api\': \'/api\'} //不为空表示请求接口: /api/admin/index/login 就会重写为 http://www.vuetpadmin.com/api/admin/index/login&amp;nbsp; （包含了api）&lt;br&gt;&amp;nbsp;例如：&lt;br&gt;&amp;nbsp;methods:{&lt;br&gt;&amp;nbsp; &amp;nbsp; target(){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.$http({&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; method: \'get\',&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; url: \'/api/admin/index/login\',&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; data: {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; name: \'virus\'&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;}).then((response) =&amp;gt; {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(response);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }).catch((error) =&amp;gt; {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(error);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;br&gt;&amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;br&gt;},&lt;/pre&gt;&lt;p&gt;          &lt;/p&gt;                            ',0,'2018-12-18 00:00:00','38',41),(34,1,'vue-cli项目迁移后要做的事情','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;vue-cli项目迁移后，由于在开发时服务器安装了一些依赖包比如：axios&lt;/p&gt;&lt;pre&gt;npm/cnpm install  // 安装了 package.json 里的安装依赖包   npm/cnpm install axios --save  // http请求依赖包&lt;/pre&gt;&lt;p&gt;所以在迁移到新服务器后，也要再次用同样的命令安装这些依赖包：&lt;/p&gt;&lt;p&gt;最后，进入项目文件夹 运行项目：&lt;/p&gt;&lt;pre&gt;npm/cnpm run dev  // 运行项目&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;',1,'2018-12-18 00:00:00','22',59),(35,1,'MyISAM与InnoDB两者之间区别与选择','','&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;一、MyISAM与InnoDB简介：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、MyISAM：默认表类型，它是基于传统的ISAM类型，ISAM是Indexed Sequential Access Method (有索引的顺序访问方法) 的缩写，它是存储记录和文件的标准方法。不是事务安全的，而且不支持外键，如果执行大量的select，insert MyISAM比较适合。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、InnoDB：支持事务安全的引擎，支持外键、行锁、事务是他的最大特点。如果有大量的update和insert，建议使用InnoDB，特别是针对多个并发和QPS较高的情况。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;二、MyISAM与InnoDB锁的差异&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;MyISAM:&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;myisam 支持 FULLTEXT类型的全文索引；只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。（也可以通过lock table命令来锁表，这样操作主要是可以模仿事务，但是消耗非常大，一般只在实验演示中使用）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;InnoDB ：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Innodb支持事务和行级锁，是innodb的最大特色；不支持 FULLTEXT类型的全文索引；。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;并发事务带来的几个问题：更新丢失，脏读，不可重复读，幻读。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;事务隔离级别：未提交读(Read uncommitted)，已提交读(Read committed)，可重复读(Repeatable read)，可序列化(Serializable)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Innodb的行锁模式有以下几种：共享锁，排他锁，意向共享锁(表锁)，意向排他锁(表锁)，间隙锁。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;注意：行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;①共享锁：其它事物可以读取数据，但是不能改数据，只有获得排他锁的事物才能改&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;②排他锁：其它事物既不能读取数据，也不能改数据，只有获得排他锁的事物才能改&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;对于insert、update、delete，InnoDB会自动给涉及的数据加排他锁（X）；对于一般的Select语句，InnoDB不会加任何锁，事务可以通过以下语句给显示加共享锁或排他锁。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;共享锁： SELECT ... LOCK IN SHARE MODE;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;排他锁： SELECT ... FOR UPDATE;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;（注：SELECT ... FROM 是一个普通查询，不会加任何锁）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;关于死锁：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;什么是死锁？当两个(或以上)事务都需要获得对方持有的排他锁才能完成事务，这样就导致了循环锁等待，也就是常见的死锁类型。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;解决死锁的方法：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、&amp;nbsp; 应用中尽量约定程序读取表的顺序一样&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、&amp;nbsp; 应用中处理一个表时，尽量对处理事物加锁的顺序排序&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;总结一下，在写多读少的应用中还是Innodb插入性能更稳定，在并发情况下也能胜任，如果是对读取速度要求比较快的应用还是选MyISAM。&lt;/div&gt;\r\n                                                            ',0,'2016-02-03 00:00:00','11',51),(36,1,'redis中各种数据类型详解及应用场景','','&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;String:&lt;/b&gt;&lt;/div&gt;&lt;div&gt;Strings 数据结构是简单的key-value类型，value其实不仅是String，也可以是数字.&lt;/div&gt;&lt;div&gt;常用命令:&amp;nbsp; set,get,decr,incr,mget 等。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;应用场景：&lt;/b&gt;String是最常用的一种数据类型，普通的key/ value 存储都可以归为此类.即可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受Redis的定时持久化，操作日志及 Replication等功能。除了提供与 Memcached 一样的get、set、incr、decr 等操作外，Redis还提供了下面一些操作：&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;01.获取字符串长度&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;02.往字符串append内容&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;03.设置和获取字符串的某一段内容&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;04.设置及获取字符串的某一位（bit）&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;05.批量设置一系列字符串的内容&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;Hash&lt;/b&gt;&lt;/div&gt;&lt;div&gt;常用命令：hget,hset,hgetall 等。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;应用场景：&lt;/b&gt;在Memcached中，我们经常将一些结构化的信息打包成HashMap，在客户端序列化后存储为一个字符串的值，比如用户的昵称、年龄、性别、积分等，这时候在需要修改其中某一项时，通常需要将所有值取出反序列化后，修改某一项的值，再序列化存储回去。这样不仅增大了开销，也不适用于一些可能并发操作的场合（比如两个并发的操作都需要修改积分）。而Redis的Hash结构可以使你像在数据库中Update一个属性一样只修改某一项属性值。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 我们简单举个实例来描述下Hash的应用场景，比如我们要存储一个用户信息对象数据，包含以下信息：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;第二种方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;那么Redis提供的Hash很好的解决了这个问题，Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口，如下图：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;也就是说，Key仍然是用户ID, value是一个Map，这个Map的key是成员的属性名，value是属性值，这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。很好的解决了问题。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这里同时需要注意，Redis提供了接口(hgetall)可以直接取到全部的属性数据,但是如果内部Map的成员很多，那么涉及到遍历整个内部Map的操作，由于Redis单线程模型的缘故，这个遍历操作可能会比较耗时，而另其它客户端的请求完全不响应，这点需要格外注意。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;实现方式：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;上面已经说到Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;List&lt;/b&gt;&lt;/div&gt;&lt;div&gt;常用命令：lpush,rpush,lpop,rpop,lrange等。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;应用场景：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Lists 就是链表，相信略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消息排行等功能。Lists的另一个应用就是消息队列，&lt;/div&gt;&lt;div&gt;可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作Lists中某一段的api，你可以直接查询，删除Lists中某一段的元素。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;实现方式：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis中list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;Set&lt;/b&gt;&lt;/div&gt;&lt;div&gt;常用命令：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;sadd,spop,smembers,sunion 等。&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;应用场景：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Sets 集合的概念就是一堆不重复值的组合。利用Redis提供的Sets数据结构，可以存储一些集合性的数据，比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;实现方式：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;Sorted Set&lt;/b&gt;&lt;/div&gt;&lt;div&gt;常用命令：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;zadd,zrange,zrem,zcard等&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;使用场景：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;另外还可以用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;实现方式：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;Pub/Sub&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;Transactions&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;谁说NoSQL都不支持事务，虽然Redis的Transactions提供的并不是严格的ACID的事务（比如一串用EXEC提交执行的命令，在执行中服务器宕机，那么会有一部分命令执行了，剩下的没执行），但是这个Transactions还是提供了基本的命令打包执行的功能（在服务器不出问题的情况下，可以保证一连串的命令是顺序在一起执行的，中间有会有其它客户端命令插进来执行）。Redis还提供了一个Watch功能，你可以对一个key进行Watch，然后再执行Transactions，在这过程中，如果这个Watched的值进行了修改，那么这个Transactions会发现并拒绝执行。&lt;/div&gt;',0,'2015-06-09 00:00:00','16',42),(37,1,'linux里如何查看系统文件空间使用情况以及查看文件或目录占用空间大小','','\r\n                                &lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;1.查看系统文件&lt;/p&gt;&lt;pre&gt;[root@centos74lnmp /]# df -h&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20181221/1f2948c665660d5875099bd4793ca686.png&quot; data-filename=&quot;img&quot; style=&quot;width: 441px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;2.查看当前目录所有文件的大小&lt;/p&gt;&lt;pre&gt;[root@centos74lnmp yxadmin]# du -sh *&amp;nbsp; &amp;nbsp; （-sh和*之间要有空格）&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20181221/6d748e2bbf052c9bfcceb091b4b09199.png&quot; data-filename=&quot;img&quot; style=&quot;width: 317px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;3.查看指定目录或文件的大小&lt;/p&gt;&lt;pre&gt;[root@centos74lnmp /]# du -sh /home&amp;nbsp;&amp;nbsp;&lt;/pre&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;\r\n&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20181221/162a67de9e5348953612208a6f9d3072.png&quot; data-filename=&quot;img&quot; style=&quot;width: 310px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;                            ',0,'2015-06-09 00:00:00','17',59),(38,1,'redis数据库简介以及与Memcached和MongoDB的比较','','\r\n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;redis是目前使用最广的nosql数据库之一，主要用于数据的缓存以及消息队列，其目的主要是减轻服务器的压力，提高数据的访问效率；由于redis的数据是存储在内存中的，所以在实际运用中，应考虑服务器的内存大小。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis 是一个高性能(key/value)分布式内存数据库,基于内存运行并支持持久化的NoSQL数据库;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;Redis特点：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 1 、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 2 、Redis支持数据的备份，即master-slave模式的数据备份。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 3 、Redis支持数据的持久化，可以定期保存到磁盘（持久化），重启的时候可以再次加载进行使用。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 4 、支持事物，虽然Redis的Transactions提供的并不是严格的ACID的事务，，但是这个Transactions还是提供了基本的命令打包执行的功能;Redis还提供了一个Watch功能，你可以对一个key进行Watch，然后再执行Transactions，在这过程中，如果这个Watched的值进行了修改，那么这个Transactions会发现并拒绝执行。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;Redis最为常用的数据类型主要有以下：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;String&amp;nbsp; &amp;nbsp; &amp;nbsp;（字符串）&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;Hash&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;（json格式数据）&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;List&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;（列表/数组）&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;Set&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; （集合去重）&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;Sorted set （自动排序的集合去重）&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;pub/sub&amp;nbsp; &amp;nbsp; （消息发布及消息订阅）&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;Transactions （支持事物）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;Memcached与redis的区别:&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;memcached也是（key-vlue）的内存nosql数据,只支持简单的string数据类型。并且不支持数据持久化和数据备份，一旦宕机数据就会丢失。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;MongoDB与redis的区别：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; 1.MongoDB 是一个基于分布式文件存储的数据库，数据存储在磁盘中，占用空间大,可以说是用空间换时间。旨在为web应用提供可扩展的高性能数据存储解决方案。MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。对存储内容的筛选可以说是 redis 和 MongoDB 的最大区别。&lt;/div&gt;&lt;div&gt;&amp;nbsp; 2.MongoDB 提供类似关系型数据库一样的 curd 语句，性能比关系型数据要好。而 redis 虽然性能比 MongoDB 要好，但是它不提供 curd 语句，更适合用来做缓存。如果是用来（持久化）存储数据，并且需要高效的curd操作的话，MongoDB会更适合。&lt;/div&gt;&lt;div&gt;&amp;nbsp;3.mongoDB不支持事务&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;MongoDB将数据存储为一个文档，数据结构由键值(key=&amp;gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;以存储一篇文章为例，文章有字段：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;01.标题&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;02.内容&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;03.图片&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;04.时间&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;用关系型数据存储时，你可能会建一个文章表，然后建立对应字段，存储对应数据。而 MongoDB 就是直接把字段以及对应内容当成一个 json 存进去（下面的json）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;{&lt;br&gt;&amp;nbsp; &amp;nbsp; &quot;title&quot;:&quot;文章标题&quot;,&lt;br&gt;&amp;nbsp; &amp;nbsp; &quot;content&quot;:&quot;文章内容&quot;,&lt;br&gt;&amp;nbsp; &amp;nbsp; &quot;img&quot;:&quot;文章图片&quot;,&lt;br&gt;&amp;nbsp; &amp;nbsp; &quot;createTime&quot;:&quot;创建时间&quot;&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;两种方式，你会看到，如果是关系型数据库，你如果要增删一个字段，可能要考虑很多东西。但是对于 MongoDB 而言，直接在 json 里加上对应字段及内容就可以了，增删字段十分方便。&lt;/div&gt;&lt;div&gt;另外，可以用redis的hash来存储这样的数据，但是有个问题，数据存储解决了。当你想根据【标题】或者【时间】筛选文章的时候，你会发现，该怎么筛选？个人觉得，对存储内容的筛选可以说是 redis 和 MongoDB 的最大区别。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;应用场景&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;redis：用于数据量较小的性能操作和运算上&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;memcache：用于在动态系统中减少数据库负载，提升性能;做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用sharding）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;MongoDB:主要解决海量数据的访问效率问题&amp;nbsp; &amp;nbsp;&lt;/div&gt;&lt;/div&gt;\r\n                                                                                        ',0,'2015-08-12 00:00:00','12,16,30',42),(39,1,'Mongodb简介','','&lt;div&gt;MongoDB 是一个基于分布式文件存储的数据库。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;MongoDB将数据存储为一个文档，数据结构由键值(key=&amp;gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20181227/d17e6f63c0a7e8b155647e8b7f7278ba.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 554px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;Mongodb特点&lt;/b&gt;&lt;/div&gt;&lt;ol&gt;&lt;li&gt;&lt;ol&gt;&lt;li&gt;MongoDB的提供了一个面向文档存储，操作起来比较简单和容易。&lt;/li&gt;&lt;li&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;可以在MongoDB记录中设置任何属性的索引(如：FirstName=&quot;Sameer&quot;,Address=&quot;8Gandhi Road&quot;)来实现更快的排序。&lt;/li&gt;&lt;li&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。&lt;/li&gt;&lt;li&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;如果负载的增加（需要更多的存储空间和更强的处理能力），它可以分布在计算机网络中的其他节点上这就是所谓的分片。&lt;/li&gt;&lt;li&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。&lt;/li&gt;&lt;li&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。&lt;/li&gt;&lt;li&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;ol&gt;&lt;/ol&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Mongodb应用场景&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Mongodb现阶段已被许多大型网站应用，例如：淘宝，京东，github，ebay等。许多网站并非完全将传统的关系型数据库替换为mongodb，而是选择性的在部分模块应用。在应用mongodb之前，要根据自身需求以及mongodb的特点、不足进行选择。目前，mongodb适用于以下一些场景：&lt;/p&gt;&lt;p&gt;网站数据：mongo非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。&lt;/p&gt;&lt;p&gt;缓存：由于性能很高，mongo也适合作为信息基础设施的缓存层。在系统重启之后，由mongo搭建的持久化缓存可以避免下层的数据源过载。&lt;/p&gt;&lt;p&gt;大尺寸、低价值的数据：使用传统的关系数据库存储一些数据时可能会比较贵，在此之前，很多程序员往往会选择传统的文件进行存储。&lt;/p&gt;&lt;p&gt;高伸缩性的场景：mongo非常适合由数十或者数百台服务器组成的数据库。用于对象及JSON数据的存储：mongo的BSON数据格式非常适合文档格式化的存储及查询。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Mongodb相对关系型数据库有如下优点：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;高可扩展性&lt;/p&gt;&lt;p&gt;分布式计算&lt;/p&gt;&lt;p&gt;低成本&lt;/p&gt;&lt;p&gt;架构的灵活性，半结构化数据&lt;/p&gt;&lt;p&gt;没有复杂的关系&lt;/p&gt;&lt;p&gt;在满足以上优点的同时，却没有关系型数据库那样严格的事物支持，通常情况下，mongodb这一缺点阻碍了人们对其的选择。对于习惯利用关系型数据库的开发人员来说，mongodb没有关联查询，这也是在做数据库选型时会考虑到的。&lt;/p&gt;&lt;p&gt;在非关系型数据库中，mongdb拥有相对突出的优势，mongodb之所以是介于关系型数据库和非关系型数据库的产品，在于它提供了非常丰富的功能，例如MySQL中常用的数据增删改查，索引，聚合查询，分页这些功能，mongodb都提供了相应的能力，与hbase列存储相比，方便了数据的可操作性。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Mongodb适用项目&lt;/b&gt;&lt;/p&gt;&lt;p&gt;针对开发者在进行项目数据库选型时，根据mongodb的特点，优势，缺点综合考虑其适合性。例如在项目中进行的事务性操作比较多，那么mongodb就不是合适的选择。考虑到mongodb的数据存储结构比较灵活，并非固定结构，即扩展性高，那么在项目中经常出现需要扩展数据字段的情况，则可以选择mongodb。当然，项目中也可以利用不同的数据库，根据数据的性质选择存储的位置。&lt;/p&gt;&lt;p&gt;&lt;b&gt;数据库&lt;/b&gt;&lt;/p&gt;&lt;p&gt;一个mongodb中可以建立多个数据库。 MongoDB的默认数据库为&quot;db&quot;，该数据库存储在data目录中。 MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。&lt;/p&gt;&lt;p&gt;&lt;b&gt;集合&lt;/b&gt;&lt;/p&gt;&lt;p&gt;集合就是MongoDB文档组，类似于关系数据库中的表格。集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。&lt;/p&gt;&lt;p&gt;&lt;b&gt;文档&lt;/b&gt;&lt;/p&gt;&lt;p&gt;文档是一组键值(key-value)对(即BSON)。MongoDB的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。&lt;/p&gt;\r\n                                                            ',0,'2015-07-15 00:00:00','12',28),(40,1,'Redis实际应用场景解析','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; Redis在很多方面与其他数据库解决方案不同：它使用内存提供主存储支持，而仅使用硬盘做持久性的存储；它的数据模型非常独特，用的是单线程。另一个大区别在于，你可以在开发环境中使用Redis的功能，但却不需要转到Redis。&lt;/p&gt;&lt;p&gt;转向Redis当然也是可取的，许多开发者从一开始就把Redis作为首选数据库；但设想如果你的开发环境已经搭建好，应用已经在上面运行了，那么更换数据库框架显然不那么容易。另外在一些需要大容量数据集的应用，Redis也并不适合，因为它的数据集不会超过系统可用的内存。所以如果你有大数据应用，而且主要是读取访问模式，那么Redis并不是正确的选择。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 然而我喜欢Redis的一点就是你可以把它融入到你的系统中来，这就能够解决很多问题，比如那些你现有的数据库处理起来感到缓慢的任务。这些你就可以通过Redis来进行优化，或者为应用创建些新的功能。在本文中，我就想探讨一些怎样将Redis加入到现有的环境中，并利用它的原语命令等功能来解决 传统环境中碰到的一些常见问题。在这些例子中，Redis都不是作为首选数据库。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;1、显示最新的项目列表&lt;/b&gt;&lt;/p&gt;&lt;p&gt;下面这个语句常用来显示最新项目，随着数据多了，查询毫无疑问会越来越慢。&lt;/p&gt;&lt;pre&gt;SELECT * FROM foo WHERE ... ORDER BY time DESC LIMIT 10&amp;nbsp; &amp;nbsp;&lt;/pre&gt;&lt;p&gt;在Web应用中，“列出最新的回复”之类的查询非常普遍，这通常会带来可扩展性问题。这令人沮丧，因为项目本来就是按这个顺序被创建的，但要输出这个顺序却不得不进行排序操作。&lt;/p&gt;&lt;p&gt;类似的问题就可以用Redis来解决。比如说，我们的一个Web应用想要列出用户贴出的最新20条评论。在最新的评论边上我们有一个“显示全部”的链接，点击后就可以获得更多的评论。&lt;/p&gt;&lt;p&gt;我们假设数据库中的每条评论都有一个唯一的递增的ID字段。&lt;/p&gt;&lt;p&gt;我们可以使用分页来制作主页和评论页，使用Redis的模板，每次新评论发表时，我们会将它的ID添加到一个Redis列表：&lt;/p&gt;&lt;pre&gt;LPUSH latest.comments &amp;lt;ID&amp;gt;&amp;nbsp; &amp;nbsp;&lt;/pre&gt;&lt;p&gt;我们将列表裁剪为指定长度，因此Redis只需要保存最新的5000条评论：&lt;/p&gt;&lt;pre&gt;LTRIM latest.comments 0 5000&amp;nbsp;&lt;/pre&gt;&lt;p&gt;每次我们需要获取最新评论的项目范围时，我们调用一个函数来完成（使用伪代码）：&lt;/p&gt;&lt;pre&gt;FUNCTION get_latest_comments(start, num_items):&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; id_list = redis.lrange(&quot;latest.comments&quot;,start,start+num_items - 1)&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; IF id_list.length &amp;lt; num_items&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; id_list = SQL_DB(&quot;SELECT ... ORDER BY time LIMIT ...&quot;)&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; END&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; RETURN id_list&amp;nbsp;&amp;nbsp;&lt;br&gt;END&amp;nbsp;&amp;nbsp;&lt;/pre&gt;&lt;p&gt;&amp;nbsp;这里我们做的很简单。在Redis中我们的最新ID使用了常驻缓存，这是一直更新的。但是我们做了限制不能超过5000个ID，因此我们的获取ID函数会一直询问Redis。只有在start/count参数超出了这个范围的时候，才需要去访问数据库。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 我们的系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。SQL数据库（或是硬盘上的其他类型数据库）只是在用户需要获取“很远”的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2、删除与过滤&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 我们可以使用LREM来删除评论。如果删除操作非常少，另一个选择是直接跳过评论条目的入口，报告说该评论已经不存在。 有些时候你想要给不同的列表附加上不同的过滤器。如果过滤器的数量受到限制，你可以简单的为每个不同的过滤器使用不同的Redis列表。毕竟每个列表只有5000条项目，但Redis却能够使用非常少的内存来处理几百万条项目。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3、排行榜相关&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 另一个很普遍的需求是各种数据库的数据并非存储在内存中，因此在按得分排序以及实时更新这些几乎每秒钟都需要更新的功能上数据库的性能不够理想。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 典型的比如那些在线游戏的排行榜，比如一个Facebook的游戏，根据得分你通常想要：&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;- 列出前100名高分选手&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;- 列出某用户当前的全球排名&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 这些操作对于Redis来说小菜一碟，即使你有几百万个用户，每分钟都会有几百万个新的得分。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 模式是这样的，每次获得新得分时，我们用这样的代码：&lt;/p&gt;&lt;pre&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; ZADD leaderboard&amp;nbsp; &amp;lt;score&amp;gt;&amp;nbsp; &amp;lt;username&amp;gt;&amp;nbsp;  // 添加有序集合&lt;/pre&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;你可能用userID来取代username，这取决于你是怎么设计的。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 得到前100名高分用户很简单：ZREVRANGE leaderboard 0 99。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 用户的全球排名也相似，只需要：ZRANK leaderboard &amp;lt;username&amp;gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;4、按照用户投票和时间排序&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 排行榜的一种常见变体模式就像Reddit或Hacker News用的那样，新闻按照类似下面的公式根据得分来排序：&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;score = points / time^alpha&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 因此用户的投票会相应的把新闻挖出来，但时间会按照一定的指数将新闻埋下去。下面是我们的模式，当然算法由你决定。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 模式是这样的，开始时先观察那些可能是最新的项目，例如首页上的1000条新闻都是候选者，因此我们先忽视掉其他的，这实现起来很简单。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 每次新的新闻贴上来后，我们将ID添加到列表中，使用LPUSH + LTRIM，确保只取出最新的1000条项目。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 有一项后台任务获取这个列表，并且持续的计算这1000条新闻中每条新闻的最终得分。计算结果由ZADD命令按照新的顺序填充生成列表，老新闻则被清除。这里的关键思路是排序工作是由后台任务来完成的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;5、处理过期项目&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 另一种常用的项目排序是按照时间排序。我们使用unix时间作为得分即可。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 模式如下：&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;- 每次有新项目添加到我们的非Redis数据库时，我们把它加入到排序集合中。这时我们用的是时间属性，current_time和time_to_live。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;- 另一项后台任务使用ZRANGE…SCORES查询排序集合，取出最新的10个项目。如果发现unix时间已经过期，则在数据库中删除条目&lt;/p&gt;&lt;p&gt;&lt;b&gt;6、计数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Redis是一个很好的计数器，这要感谢INCRBY和其他相似命令。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;我相信你曾许多次想要给数据库加上新的计数器，用来获取统计或显示新信息，但是最后却由于写入敏感而不得不放弃它们。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;好了，现在使用Redis就不需要再担心了。有了原子递增（atomic increment），你可以放心的加上各种计数，用GETSET重置，或者是让它们过期。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;例如这样操作：&lt;/p&gt;&lt;pre&gt;INCR user:&amp;lt;id&amp;gt; EXPIRE&amp;nbsp;&lt;br&gt;user:&amp;lt;id&amp;gt; 60&amp;nbsp;&lt;/pre&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;你可以计算出最近用户在页面间停顿不超过60秒的页面浏览量，当计数达到比如20时，就可以显示出某些条幅提示，或是其它你想显示的东西。&lt;/p&gt;&lt;p&gt;&lt;b&gt;7、特定时间内的特定项目&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 另一项对于其他数据库很难，但Redis做起来却轻而易举的事就是统计在某段特点时间里有多少特定用户访问了某个特定资源。比如我想要知道某些特定的注册用户或IP地址，他们到底有多少访问了某篇文章。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 每次我获得一次新的页面浏览时我只需要这样做：&lt;/p&gt;&lt;pre&gt;&amp;nbsp;SADD page:day1:&amp;lt;page_id&amp;gt; &amp;lt;user_id&amp;gt;&amp;nbsp;&lt;/pre&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 当然你可能想用unix时间替换day1，比如time()-(time()%3600*24)等等。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 想知道特定用户的数量吗？只需要使用SCARD page:day1:&amp;lt;page_id&amp;gt;。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;需要测试某个特定用户是否访问了这个页面？SISMEMBER page:day1:&lt;page_id&gt;。&lt;/page_id&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;8、实时分析正在发生的情况，用于数据统计与防止垃圾邮件等&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 我们只做了几个例子，但如果你研究Redis的命令集，并且组合一下，就能获得大量的实时分析方法，有效而且非常省力。使用Redis原语命令，更容易实施垃圾邮件过滤系统或其他实时跟踪系统。&lt;/p&gt;&lt;p&gt;&lt;b&gt;9、Pub/Sub&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Redis的Pub/Sub非常非常简单，运行稳定并且快速。支持模式匹配，能够实时订阅与取消频道。&lt;/p&gt;&lt;p&gt;&lt;b&gt;10、队列&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 你应该已经注意到像list push和list pop这样的Redis命令能够很方便的执行队列操作了，但能做的可不止这些：比如Redis还有list pop的变体命令，能够在列表为空时阻塞队列。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;现代的互联网应用大量地使用了消息队列（Messaging）。消息队列不仅被用于系统内部组件之间的通信，同时也被用于系统跟其它服务之间的交互。消息队列的使用可以增加系统的可扩展性、灵活性和用户体验。非基于消息队列的系统，其运行速度取决于系统中最慢的组件的速度（注：短板效应）。而基于消息队列可以将系统中各组件解除耦合，这样系统就不再受最慢组件的束缚，各组件可以异步运行从而得以更快的速度完成各自的工作。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; 此外，当服务器处在高并发操作的时候，比如频繁地写入日志文件。可以利用消息队列实现异步处理。从而实现高性能的并发操作。&lt;/p&gt;',0,'2016-08-10 00:00:00','16',39),(41,1,'Redis和MongoDB的简单区别比较','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;就Redis和MongoDB来说，大家一般称之为Redis缓存、MongoDB数据库。这也是有道有理有根据的，&lt;/p&gt;&lt;p&gt;Redis主要把数据存储在内存中，其“缓存”的性质远大于其“数据存储“的性质，其中数据的增删改查也只是像变量操作一样简单；&lt;/p&gt;&lt;p&gt;MongoDB却是一个“存储数据”的系统，增删改查可以添加很多条件，就像MYSQL数据库一样灵活.&lt;/p&gt;&lt;p&gt;&lt;b&gt;Mongodb与Redis应用指标对比&lt;/b&gt;&lt;/p&gt;&lt;p&gt;MongoDB和Redis都是NoSQL，采用结构型数据存储。二者在使用场景中，存在一定的区别，这也主要由于&lt;/p&gt;&lt;p&gt;二者在内存映射的处理过程，持久化的处理方法不同。MongoDB建议集群部署，更多的考虑到集群方案，Redis&lt;/p&gt;&lt;p&gt;更偏重于进程顺序写入，虽然支持集群，也仅限于主-从模式。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;table class=&quot;table table-bordered&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;指标&lt;/td&gt;&lt;td&gt;MongoDB(v2.4.9)&amp;nbsp;&lt;br&gt;&lt;/td&gt;&lt;td&gt;Redis(v2.4.17)&amp;nbsp;&lt;br&gt;&lt;/td&gt;&lt;td&gt;比较说明&lt;br&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;实现语言&lt;br&gt;&lt;/td&gt;&lt;td&gt;C++&lt;br&gt;&lt;/td&gt;&lt;td&gt;C/C++&lt;br&gt;&lt;/td&gt;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;协议&lt;br&gt;&lt;/td&gt;&lt;td&gt;BSON、自定义二进制&lt;br&gt;&lt;/td&gt;&lt;td&gt;类Telnet&lt;br&gt;&lt;/td&gt;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;性能&lt;br&gt;&lt;/td&gt;&lt;td&gt;依赖内存，TPS较高&lt;br&gt;&lt;/td&gt;&lt;td&gt;依赖内存，TPS非常高&lt;br&gt;&lt;/td&gt;&lt;td&gt;Redis优于MongoDB&lt;br&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;可操作性&lt;br&gt;&lt;/td&gt;&lt;td&gt;丰富的数据表达、索引；最类似于关系数据库，支持丰富的查询语言&lt;br&gt;&lt;/td&gt;&lt;td&gt;数据丰富，较少的IO&lt;br&gt;&lt;/td&gt;&lt;td&gt;MongoDB优于Redis&lt;br&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;内存及存储&lt;br&gt;&lt;/td&gt;&lt;td&gt;适合大数据量存储，依赖系统虚拟内存管理，采用镜像文件存储；内存占有率比较高，官方建议独立部署在64位系统（32位有最大2.5G文件限制，64位没有改限制）&lt;br&gt;&lt;/td&gt;&lt;td&gt;Redis2.0后增加虚拟内存特性，突破物理内存限制；数据可以设置时效性，类似于memcache&lt;br&gt;&lt;/td&gt;&lt;td&gt;不同的应用角度看，各有优劣&lt;br&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;可用性&lt;br&gt;&lt;/td&gt;&lt;td&gt;支持master-slave,replicaset（内部采用paxos选举算法，自动故障恢复）,auto sharding机制，对客户端屏蔽了故障转移和切分机制&lt;br&gt;&lt;/td&gt;&lt;td&gt;依赖客户端来实现分布式读写；主从复制时，每次从节点重新连接主节点都要依赖整个快照,无增量复制；不支持自动sharding,需要依赖程序设定一致hash机制&lt;br&gt;&lt;/td&gt;&lt;td&gt;MongoDB优于Redis&lt;br&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;一致性&lt;br&gt;&lt;/td&gt;&lt;td&gt;不支持事物，靠客户端自身保证&lt;br&gt;&lt;/td&gt;&lt;td&gt;支持事物，比较弱，仅能保证事物中的操作按顺序执行&lt;br&gt;&lt;/td&gt;&lt;td&gt;Redis优于MongoDB&lt;br&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;数据分析&lt;br&gt;&lt;/td&gt;&lt;td&gt;内置数据分析功能（mapreduce）&lt;br&gt;&lt;/td&gt;&lt;td&gt;不支持&lt;br&gt;&lt;/td&gt;&lt;td&gt;MongoDB优于Redis&lt;br&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;应用场景&lt;br&gt;&lt;/td&gt;&lt;td&gt;海量数据的访问效率提升&lt;br&gt;&lt;/td&gt;&lt;td&gt;较小数据量的性能及运算&lt;br&gt;&lt;/td&gt;&lt;td&gt;MongoDB优于Redis&lt;br&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;',0,'2017-10-18 00:00:00','12,16',31),(42,1,'MongoDB语法与现有关系型数据库SQL语法比较','','&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;MongoDB&amp;nbsp; 被称之为最接近 sql数据库的nosql的数据库是有原因的：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;MongoDB语法&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; MySql语法&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.find({\'name\':\'foobar\'})&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;lt;==&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; select * from test where name=\'foobar\'&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.find()&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;==&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; select *from test&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.find({\'ID\':10}).count()&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;lt;==&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; select count(*) from test where ID=10&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.find().skip(10).limit(20)&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;==&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; select * from test limit 10,20&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.find({\'ID\':{$in:[25,35,45]}})&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;lt;==&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; select * from test where ID in (25,35,45)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.find().sort({\'ID\':-1})&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;lt;==&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; select * from test order by IDdesc&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.distinct(\'name\',{\'ID\':{$lt:20}}) &amp;lt;==&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; select distinct(name) from testwhere ID&amp;lt;20&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.group({key:{\'name\':true},cond:{\'name\':\'foo\'},reduce:function(obj,prev){prev.msum+=obj.marks;},initial:{msum:0}})&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;lt;==&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;select name,sum(marks) from testgroup by name&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.find(\'this.ID&amp;lt;20\',{name:1})&amp;nbsp; &amp;nbsp; &amp;lt;==&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;select name from test whereID&amp;lt;20&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.insert({\'name\':\'foobar\',\'age\':25})&amp;nbsp; &amp;nbsp; &amp;lt;==&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;insertinto test (\'name\',\'age\') values(\'foobar\',25)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.remove({})&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;lt;==&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;delete * from test&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.remove({\'age\':20})&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;==&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;delete test where age=20&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.remove({\'age\':{$lt:20}})&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;==&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; delete test where age&amp;lt;20&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.remove({\'age\':{$lte:20}})&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;==&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; delete test where age&amp;lt;=20&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.remove({\'age\':{$gt:20}})&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;==&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;delete test where age&amp;gt;20&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.remove({\'age\':{$gte:20}})&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;==&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;delete test where age&amp;gt;=20&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.remove({\'age\':{$ne:20}})&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;lt;==&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;delete test where age!=20&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.update({\'name\':\'foobar\'},{$set:{\'age\':36}})&amp;lt;==&amp;gt; update test set age=36 where name=\'foobar\'&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.update({\'name\':\'foobar\'},{$inc:{\'age\':3}})&amp;lt;==&amp;gt; update test set age=age+3 where name=\'foobar\'&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;模糊查询：$regex&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.test.find({&quot;name&quot;:{$regex:&quot;aaa&quot;}})&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;分组个数过滤&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.getCollection(\'id_mapper\').aggregate([{$group:{ _id :&quot;$contract_id&quot;,count:{$sum:1}}},{$match:{count:{$gt:1}}}])&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;判断是否为空&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;db.getCollection(\'id_mapper\').find({&quot;sinocardid&quot;:{$in:[null]}})&lt;/div&gt;\n                                                            ',0,'2017-07-20 00:00:00','12',58),(43,1,'Memcache,Redis对比分析','','&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;当今在数据存储方面所有的实现方案，其中主要涉及到了普通关系型数据库（MySQL/PostgreSQL），NoSQL数据库(MongoDB)，内存数据库（Redis），内存Cache（Memcached），我们现在需要的是对大数据表仍保持高效的查询速度，普通关系型数据库是无法满足的。而MongoDB其实只是一种非关系型数据库，其优势在于可以存储海量数据，具备强大的查询功能，因此不宜用于缓存数据的场景。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;（注：&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 内存：是存储器，用于辅助CPU输入输出数据进行运算。&lt;/div&gt;&lt;div&gt;　&amp;nbsp; &amp;nbsp;CACHE：是一种特殊的内存。因为主内存速度不够快，用少量的特别快的但特别昂贵的内存来做缓存加速。就是cache。&lt;/div&gt;&lt;div&gt;）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;四、下面重点分析Memcached和Redis两种方案：&lt;/div&gt;&lt;div&gt;4.1 Memcached介绍&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提供动态、数据库驱动网站的速度，现在已被LiveJournal、hatena、Facebook、Vox、LiveJournal等公司所使用。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;4.2 Memcached工作方式分析&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;许多Web应用都将数据保存到 RDBMS中，应用服务器从中读取数据并在浏览器中显示。 但随着数据量的增大、访问的集中，就会出现RDBMS的负担加重、数据库响应恶化、 网站显示延迟等重大影响。Memcached是高性能的分布式内存缓存服务器,通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web等应用的速度、 提高可扩展性。下图展示了memcache与数据库端协同工作情况：&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20181230/7d2a8107b3ae8285b363334ea72e0da1.png&quot; data-filename=&quot;img&quot; style=&quot;width: 621px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ol&gt;&lt;li&gt;&lt;div&gt;其中的过程是这样的：&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 1.检查用户请求的数据是缓存中是否有存在，如果有存在的话，只需要直接把请求的数据返回，无需查询数据库。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 2.如果请求的数据在缓存中找不到，这时候再去查询数据库。返回请求数据的同时，把数据存储到缓存中一份。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 3.保持缓存的“新鲜性”，每当数据发生变化的时候（比如，数据有被修改，或被删除的情况下），要同步的更新缓存信息，确保用户不会在缓存取到旧的数据。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Memcached作为高速运行的分布式缓存服务器，具有以下的特点：&amp;nbsp;&lt;/div&gt;&lt;ol&gt;&lt;li&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;协议简单&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;基于libevent的事件处理&amp;nbsp;&lt;/li&gt;&lt;li&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 内置内存存储方式&lt;/li&gt;&lt;li&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;memcached不互相通信的分布式&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;4.4 Redis 介绍&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、 list(链表)、set(集合)和zset(有序集合)。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步,当前 Redis的应用已经非常广泛，国内像新浪、淘宝，国外像 Flickr、Github等均在使用Redis的缓存服务。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;4.5 Redis 工作方式分析&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;Redis作为一个高性能的key-value数据库具有以下特征：&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 多样的数据模型&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;持久化&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 主从同步&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;Redis支持丰富的数据类型，最为常用的数据类型主要由五种：String、Hash、List、Set和Sorted Set。Redis通常将数据存储于内存中，或被配置为使用虚拟内存。Redis有一个很重要的特点就是它可以实现持久化数据，通过两种方式可以实现数据持久化：使用RDB快照的方式，将内存中的数据不断写入磁盘；或使用类似MySQL的AOF日志方式，记录每次更新的日志。前者性能较高，但是可能会引起一定程度的数据丢失；后者相反。 Redis支持将数据同步到多台从数据库上，这种特性对提高读取性能非常有益。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;五、综合结论&lt;/div&gt;&lt;div&gt;&amp;nbsp;应该说Memcached和Redis都能很好的满足解决我们的问题，它们性能都很高，总的来说，可以把Redis理解为是对Memcached的拓展，是更加重量级的实现，提供了更多更强大的功能。具体来说：&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;1.性能上：&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;性能上都很出色，具体到细节，由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比&lt;/div&gt;&lt;div&gt;Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;2.内存空间和数据量大小：&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;MemCached可以修改最大内存，采用LRU算法。Redis增加了VM的特性，突破了物理内存的限制。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;3.操作便利上：&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;MemCached数据结构单一，仅用来缓存数据，而Redis支持更加丰富的数据类型，也可以在服务器端直接对数据进行丰富的操作,这样可以减少网络IO次数和数据体积。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;4.可靠性上：&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;MemCached不支持数据持久化，断电或重启后数据消失，但其稳定性是有保证的。Redis支持数据持久化和数据恢复，允许单点故障，但是同时也会付出性能的代价。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;5.应用场景：&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;Memcached：动态系统中减轻数据库负载，提升性能；做缓存，适合多读少写，大数据量的情况（如人人网大量查询用户信息、好友信息、文章信息等）。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;Redis：适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统（如新浪微博的计数和微博发布部分系统，对数据安全性、读写要求都很高）。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;六、需要慎重考虑的部分&lt;/div&gt;&lt;div&gt;1.Memcached单个key-value大小有限，一个value最大只支持1MB，而Redis最大支持512MB&lt;/div&gt;&lt;div&gt;2.Memcached只是个内存缓存，对可靠性无要求；而Redis更倾向于内存数据库，因此对对可靠性方面要求比较高&lt;/div&gt;&lt;div&gt;3.从本质上讲，Memcached只是一个单一key-value内存Cache；而Redis则是一个数据结构内存数据库，支持五种数据类型，因此Redis除单纯缓存作用外，还可以处理一些简单的逻辑运算，Redis不仅可以缓存，而且还可以作为数据库用&lt;/div&gt;&lt;div&gt;4.新版本（3.0）的Redis是指集群分布式，也就是说集群本身均衡客户端请求，各个节点可以交流，可拓展行、可维护性更强大。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\n                                                            ',0,'2017-07-13 00:00:00','16,30',48),(44,1,'集群与分布式的简单理解','','\n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Source Han Sans SC&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, sans-serif; font-size: 15px;&quot;&gt;&amp;nbsp; &amp;nbsp; 分布式是指将不同的业务分布在不同的地方，&lt;u&gt;实现不同的业务&lt;/u&gt;。 而集群指的是将几台服务器集中在一起，&lt;u&gt;实现同一业务&lt;/u&gt;。&amp;nbsp;&lt;/span&gt;&lt;br style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Source Han Sans SC&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, sans-serif; font-size: 15px;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Source Han Sans SC&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, sans-serif; font-size: 15px;&quot;&gt;分布式中的每一个节点，都可以做集群。 而集群并不一定就是分布式的。&amp;nbsp;&lt;/span&gt;&lt;br style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Source Han Sans SC&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, sans-serif; font-size: 15px;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Source Han Sans SC&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, sans-serif; font-size: 15px;&quot;&gt;举例：就比如新浪网，访问的人多了，他可以做一个群集，前面放一个响应服务器，后面几台服务器完成同一业务，如果有业务访问的时候，通过负载均衡的方式，看哪台服务器的负载不是很重，就将给哪一台去完成。&amp;nbsp;&lt;/span&gt;&lt;br style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Source Han Sans SC&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, sans-serif; font-size: 15px;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Source Han Sans SC&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, sans-serif; font-size: 15px;&quot;&gt;而分布式，从窄意上理解，也跟集群差不多， 但是它的组织比较松散，不像集群，有一个组织性，一台服务器垮了，其它的服务器可以顶上来。&amp;nbsp;&lt;/span&gt;&lt;br style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Source Han Sans SC&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, sans-serif; font-size: 15px;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Source Han Sans SC&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, sans-serif; font-size: 15px;&quot;&gt;分布式的每一个节点，都完成不同的业务，一个节点垮了，哪这个业务就不可访问了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Source Han Sans SC&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, sans-serif; font-size: 15px;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;再比如：一个大型的电商网站，由于需要展示的数据量大而多比如：产品图片、评论信息等其它信息。要是只用一台服务器。那么用户访问量大的时候，由于服务器的处理能力不足，整个网站就会瞬间变卡。这个时候我们就可以利用分布式，将服务器拆分为多台，每台服务器各自请求不同的业务，比如：A服务器获取图片，B服务器获取评论数据。但是由于产品的不多增多，一台服务器获取图片也会变卡，于是我们就可以利用集群的方式，多部署几台，都是为获取图片而服务的，通过负载均含策略将请求分配给请求压力不是很大的服务器进行处理（这就是说&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Source Han Sans SC&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, sans-serif; font-size: 15px;&quot;&gt;分布式中的每一个节点，都可以做集群&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Source Han Sans SC&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, sans-serif; font-size: 15px;&quot;&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Source Han Sans SC&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, sans-serif; font-size: 15px;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                            ',0,'2016-07-13 00:00:00','33',64),(45,1,'并行、并发,两者的简单理解','','\n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;什么是并发?&lt;/b&gt;&lt;/p&gt;&lt;p&gt;并发:指应用能够&lt;span style=&quot;background-color: rgb(255, 0, 0);&quot;&gt;&lt;u&gt;交替执行&lt;/u&gt;&lt;/span&gt;不同的任务,其实并发有点类似于多线程的原理,多线程并非是同时执行多个任务,如果你开两个线程执行,就是在你几乎不可能察觉到的速度不断去切换这两个任务,已达到&quot;同时执行效果&quot;,其实并不是的,只是计算机的速度太快,我们无法察觉到而已&lt;b&gt;（这里的切换任务，不是等某个任务执行完成才去切换下一个任务。而是不间断的切换执行）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;就类似于你,吃一口饭喝一口水,以正常速度来看,完全能够看的出来,当你把这个过程以n倍速度执行时..可以想象一下.&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;高并发产生的原因就是，应用程序在某个时刻存在大量的任务需要交替执行，这个时候就会有很大可能造成数据错误。比如在秒杀活动中，同一时候发起大量的数据库请求，A客户端查询出某商品数量为5，购买后库存减少1个，由于这些数据库请求任务都是交替执行的，在A客户还没有吧减少的库存写入到数据时，应用程序把任务切换到B客户执行，此时B客户读取数据库某商品数量还是为5，购买后库存也减少1个。在B客户还没有吧减少的库存写入到数据时，应用程序又把任务切换到A客户去执行更新库存的操作了。此时库存量为4。然后又轮到B客户更新库存量，这时库存量还是为4，导致两个用户都买了一个商品，库存却只减少1个，最后数据造成了错误。这个就是并发造成的结果。&lt;/p&gt;&lt;p&gt;&lt;b&gt;什么是并行?&lt;/b&gt;&lt;/p&gt;&lt;p&gt;并行:指应用能够&lt;u style=&quot;background-color: rgb(255, 0, 0);&quot;&gt;同时&lt;/u&gt;执行不同的任务,例:吃饭的时候可以边吃饭边打电话,这两件事情可以同时执行&lt;/p&gt;&lt;p&gt;两者区别:一个是交替执行,一个是同时执行.&lt;/p&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                            ',0,'2016-02-02 00:00:00','33',28),(46,1,'MYSQL explain详解','','\r\n                                &lt;p&gt;&lt;img src=&quot;/upload/article/20190102/99d519047ac5708a7319fa4c4c6fcaf1.png&quot; data-filename=&quot;img&quot; style=&quot;width: 917.778px; height: 98px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;1. id&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这是SELECT查询序列号。这个不重要,比如嵌套的sql语句，SELECT *FROM (SELECT* FROM a) AS b 。会显示两条数据&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.select_type&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;select类型，它有以下几种值&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;01 simple 它表示简单的select,没有union和子查询&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;02 primary 最外面的select,在有子查询的语句中，最外面的select查询就是primary,上图中就是这样&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;03 union union语句的第二个或者说是后面那一个.现执行一条语句，explain&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;select&amp;nbsp; *&amp;nbsp; from uchome_space limit 10 union select * from uchome_space limit 10,10&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;还有几个参数，这里就不说了，不重要&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.table&lt;/b&gt;&lt;/p&gt;&lt;p&gt;SELECT查询所用的表&lt;/p&gt;&lt;p&gt;&lt;b&gt;4.type&lt;/b&gt;&lt;/p&gt;&lt;p&gt;连接类型。有多个参数，先从最佳类型（查询速率快）到最差类型（查询速率慢）介绍&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;01. system&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;表仅有一行，这是const类型的特列，平时不会出现，这个也可以忽略不计&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;02. const&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;表最多有一个匹配行，const用于比较primary key 或者unique索引。因为只匹配一行数据，所以很快&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;记住一定是用到primary key 或者unique&amp;nbsp; &amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190102/9dfdb4163b7d1aa99956426f749091e1.png&quot; data-filename=&quot;img&quot; style=&quot;width: 978px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;03.eq_ref&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;对于eq_ref的解释，mysql手册是这样说的:&quot;对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型。它用在一个索引的所有部分被联接使用并且索引是UNIQUE或PRIMARY KEY&quot;。eq_ref可以用于使用&quot;=&quot;比较带索引的列。看下面的语句&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;explain select * from uchome_spacefield,uchome_space where uchome_spacefield.uid = uchome_space.uid&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190102/d7c490e95b8d78ddfc2ba87ba3ebbddd.png&quot; data-filename=&quot;img&quot; style=&quot;width: 1029px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;04.ref 对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。如果联接只使用键的最左边的前缀，或如果键不是UNIQUE或PRIMARY KEY（换句话说，如果联接不能基于关键字选择单个行的话），则使用ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 05.range: 扫描部分索引，索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行，常见于between、&amp;lt;、&amp;gt;、IN()等的查询&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 06.index: 扫描全部索引树&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;07.ALL:对于每个来自于先前的表的行组合，进行完整的表扫描。如果表是第一个没标记const的表，这通常不好，并且通常在它情况下很差。通常可以增加更多的索引而不要使用ALL，使得行能基于前面的表中的常数值或列值被检索出。&lt;/p&gt;&lt;p&gt;&lt;b&gt;5 .possible_keys &lt;/b&gt;提示使用哪个索引会在该表中找到行，不太重要&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;6. keys&lt;/b&gt; MYSQL使用的索引，简单且重要&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;7. key_len&lt;/b&gt; MYSQL使用的索引长度&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;8. ref&amp;nbsp;&lt;/b&gt; &amp;nbsp;ref列显示使用哪个列或常数与key一起从表中选择行。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/p&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;                            ',0,'2016-06-08 00:00:00','11',30),(47,1,'MySQL 索引及查询优化总结（转）','','\r\n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; MySQL索引的建立对于MySQL的高效运行是很重要的。对于少量的数据，没有合适的索引影响不是很大，但是，当随着数据量的增加，性能会急剧下降。如果对多列进行索引(组合索引)，列的顺序非常重要，MySQL仅能对索引最左边的前缀进行有效的查找。&lt;/div&gt;&lt;div&gt;下面介绍几种常见的MySQL索引类型。&lt;/div&gt;&lt;div&gt;索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、MySQL索引类型&lt;/div&gt;&lt;div&gt;&lt;b&gt;(1) 主键索引 PRIMARY KEY&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190103/ffa766a26b4d521bf80c9fc42476e679.png&quot; data-filename=&quot;img&quot; style=&quot;width: 340px;&quot;&gt;&lt;/div&gt;&lt;div&gt;当然也可以用 ALTER 命令。记住：一个表只能有一个主键。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;(2) 唯一索引 UNIQUE&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。可以在创建表的时候指定，也可以修改表结构，如：&lt;/div&gt;&lt;div&gt;ALTER TABLE table_name ADD UNIQUE (column)&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;(3) 普通索引 INDEX&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 这是最基本的索引，它没有任何限制。可以在创建表的时候指定，也可以修改表结构，如：&lt;/div&gt;&lt;div&gt;ALTER TABLE table_name ADD INDEX index_name (column)&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;(4) 组合索引 INDEX&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 组合索引，即一个索引包含多个列。可以在创建表的时候指定，也可以修改表结构，如：&lt;/div&gt;&lt;div&gt;ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3)&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;(5) 全文索引 FULLTEXT&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;全文索引（也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用分词技术等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。&lt;/div&gt;&lt;div&gt;可以在创建表的时候指定，也可以修改表结构，如：&lt;/div&gt;&lt;div&gt;ALTER TABLE table_name ADD FULLTEXT (column)&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;2、索引结构及原理&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;mysql中普遍使用B+Tree做索引，但在实现上又根据聚簇索引和非聚簇索引而不同，本文暂不讨论这点。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;u&gt;&lt;b&gt;b+树介绍&lt;/b&gt;&lt;/u&gt;&lt;/div&gt;&lt;div&gt;&lt;u&gt;&lt;br&gt;&lt;/u&gt;&lt;/div&gt;&lt;div&gt;下面这张b+树的图片在很多地方可以看到，之所以在这里也选取这张，是因为觉得这张图片可以很好的诠释索引的查找过程。&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190103/17f85356d2dd214c5109d90144f670f8.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 553px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;如上图，是一颗b+树。浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。&lt;/div&gt;&lt;div&gt;真实的数据存在于叶子节点，即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。&lt;/div&gt;&lt;div&gt;查找过程&lt;/div&gt;&lt;div&gt;在上图中，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;性质&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;(1) 索引字段要尽量的小。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;通过上面b+树的查找过程，或者通过真实的数据存在于叶子节点这个事实可知，IO次数取决于b+数的高度h。&lt;/div&gt;&lt;div&gt;假设当前数据表的数据量为N，每个磁盘块的数据项的数量是m，则树高h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；&lt;/div&gt;&lt;div&gt;而m = 磁盘块的大小/数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的；如果数据项占的空间越小，数据项的数量m越多，树的高度h越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;(2) 索引的最左匹配特性。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;建索引的几大原则&lt;/div&gt;&lt;div&gt;&lt;b&gt;(1) 最左前缀匹配原则&lt;/b&gt;&lt;/div&gt;&lt;div&gt;对于多列索引，总是从索引的最前面字段开始，接着往后，中间不能跳过。比如创建了多列索引(name,age,sex)，会先匹配name字段，再匹配age字段，再匹配sex字段的，中间不能跳过。mysql会一直向右匹配直到遇到范围查询(&amp;gt;、&amp;lt;、between、like)就停止匹配。&lt;/div&gt;&lt;div&gt;一般，在创建多列索引时，where子句中使用最频繁的一列放在最左边。&lt;/div&gt;&lt;div&gt;看一个补符合最左前缀匹配原则和符合该原则的对比例子。&lt;/div&gt;&lt;div&gt;实例：表c2c_db.t_credit_detail建有索引(Flistid,Fbank_listid)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190103/7b34970ce35264a5b55898e2f315b497.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 485px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;不符合最左前缀匹配原则的sql语句：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;select * from t_credit_detail where Fbank_listid=\'201108010000199\'\\G&lt;/div&gt;&lt;div&gt;该sql直接用了第二个索引字段Fbank_listid，跳过了第一个索引字段Flistid，不符合最左前缀匹配原则。用explain命令查看sql语句的执行计划，如下图：&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190103/0fcc1eba37e2f72304a205deb7526967.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 738px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;从上图可以看出，该sql未使用索引，是一个低效的全表扫描。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;符合最左前缀匹配原则的sql语句：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;select * from t_credit_detail where Flistid=\'2000000608201108010831508721\' and Fbank_listid=\'201108010000199\'\\G&lt;/div&gt;&lt;div&gt;该sql先使用了索引的第一个字段Flistid，再使用索引的第二个字段Fbank_listid，中间没有跳过，符合最左前缀匹配原则。用explain命令查看sql语句的执行计划，如下图：&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190103/ffab62ad90e1f1b8655ed5d01fe28a82.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 817.778px; height: 161px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;从上图可以看出，该sql使用了索引，仅扫描了一行。&lt;/div&gt;&lt;div&gt;对比可知，符合最左前缀匹配原则的sql语句比不符合该原则的sql语句效率有极大提高，从全表扫描上升到了常数扫描。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;(2) 尽量选择区分度高的列作为索引。&lt;/div&gt;&lt;div&gt;比如，我们会选择学号做索引，而不会选择性别来做索引。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;(3) =和in可以乱序&lt;/div&gt;&lt;div&gt;比如a = 1 and b = 2 and c = 3，建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;(4) 索引列不能参与计算，保持列“干净”&lt;/div&gt;&lt;div&gt;比如：Flistid+1&amp;gt;‘2000000608201108010831508721‘。原因很简单，假如索引列参与计算的话，那每次检索时，都会先将索引计算一次，再做比较，显然成本太大。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;(5) 尽量的扩展索引，不要新建索引。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;索引的不足&lt;/b&gt;&lt;/div&gt;&lt;div&gt;虽然索引可以提高查询效率，但索引也有自己的不足之处。&lt;/div&gt;&lt;div&gt;索引的额外开销：&lt;/div&gt;&lt;div&gt;(1) 空间：索引需要占用空间；&lt;/div&gt;&lt;div&gt;(2) 时间：查询索引需要时间；&lt;/div&gt;&lt;div&gt;(3) 维护：索引须要维护（数据变更时）；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;不建议使用索引的情况：&lt;/div&gt;&lt;div&gt;(1) 数据量很小的表&lt;/div&gt;&lt;div&gt;(2) 空间紧张&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;常用优化总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;优化语句很多，需要注意的也很多，针对平时的情况总结一下几点：&lt;/p&gt;&lt;p&gt;1、有索引但未被用到的情况（不建议）&lt;/p&gt;&lt;p&gt;(1) Like的参数以通配符开头时&lt;/p&gt;&lt;p&gt;尽量避免Like的参数以通配符开头，否则数据库引擎会放弃使用索引而进行全表扫描。&lt;/p&gt;&lt;p&gt;以通配符开头的sql语句，例如：select * from t_credit_detail where Flistid like \'%0\'\\G&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190103/a3607d32e06aa367c5ac616b53b98e05.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 585px;&quot;&gt;&lt;/p&gt;&lt;p&gt;这是全表扫描，没有使用到索引，不建议使用。&lt;/p&gt;&lt;p&gt;不以通配符开头的sql语句，例如：select * from t_credit_detail where Flistid like \'2%\'\\G&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190103/d806c5d1e8338b1748b01f082f759156.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 590px;&quot;&gt;&lt;/p&gt;&lt;p&gt;很明显，这使用到了索引，是有范围的查找了，比以通配符开头的sql语句效率提高不少。&lt;/p&gt;&lt;p&gt;(2) where条件不符合最左前缀原则时&lt;/p&gt;&lt;p&gt;例子已在最左前缀匹配原则的内容中有举例。&lt;/p&gt;&lt;p&gt;(3) 使用！= 或 &amp;lt;&amp;gt; 操作符时&lt;/p&gt;&lt;p&gt;尽量避免使用！= 或 &amp;lt;&amp;gt;操作符，否则数据库引擎会放弃使用索引而进行全表扫描。使用&amp;gt;或&amp;lt;会比较高效。&lt;/p&gt;&lt;p&gt;select * from t_credit_detail where Flistid != \'2000000608201108010831508721\'\\G&lt;/p&gt;&lt;p&gt;(4) 索引列参与计算&lt;/p&gt;&lt;p&gt;应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。&lt;/p&gt;&lt;p&gt;select * from t_credit_detail where Flistid +1 &amp;gt; \'2000000608201108010831508722\'\\G&lt;/p&gt;&lt;p&gt;(5) 对字段进行null值判断&lt;/p&gt;&lt;p&gt;应尽量避免在where子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： 低效：select * from t_credit_detail where Flistid is null ;&lt;/p&gt;&lt;p&gt;可以在Flistid上设置默认值0，确保表中Flistid列没有null值，然后这样查询： 高效：select * from t_credit_detail where Flistid =0;&lt;/p&gt;&lt;p&gt;(6) 使用or来连接条件&lt;/p&gt;&lt;p&gt;应尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，&lt;/p&gt;&lt;p&gt;如： 低效：select * from t_credit_detail where Flistid = \'2000000608201108010831508721\' or Flistid = \'10000200001\';&lt;/p&gt;&lt;p&gt;可以用下面这样的查询代替上面的 or 查询：&lt;/p&gt;&lt;p&gt; 高效：select from t_credit_detail where Flistid = \'2000000608201108010831508721\' union all select from t_credit_detail where Flistid = \'10000200001\';&lt;/p&gt;&lt;p&gt;&lt;b&gt;2、避免select *&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在解析的过程中，会将\'*\' 依次转换成所有的列名，这个工作是通过查询数据字典完成的，这意味着将耗费更多的时间。&lt;/p&gt;&lt;p&gt;所以，应该养成一个需要什么就取什么的好习惯。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3、order by 语句优化&lt;/b&gt;&lt;/p&gt;&lt;p&gt;任何在Order by语句的非索引项或者有计算表达式都将降低查询速度。&lt;/p&gt;&lt;p&gt;方法：&lt;/p&gt;&lt;p&gt;1.重写order by语句以使用索引；&lt;/p&gt;&lt;p&gt;2.为所使用的列建立另外一个索引&lt;/p&gt;&lt;p&gt;3.绝对避免在order by子句中使用表达式。&lt;/p&gt;&lt;p&gt;&lt;b&gt;4、GROUP BY语句优化&lt;/b&gt;&lt;/p&gt;&lt;p&gt;提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉&lt;/p&gt;&lt;p&gt;低效:&lt;/p&gt;&lt;pre&gt;SELECT JOB , AVG(SAL)&lt;br&gt;FROM EMP&lt;br&gt;GROUP by JOB&lt;br&gt;HAVING JOB = ‘PRESIDENT\'&lt;br&gt;OR JOB = ‘MANAGER\'&lt;/pre&gt;&lt;p&gt;高效:&lt;/p&gt;&lt;pre&gt;SELECT JOB , AVG(SAL)&lt;br&gt;FROM EMP&lt;br&gt;WHERE JOB = ‘PRESIDENT\'&lt;br&gt;OR JOB = ‘MANAGER\'&lt;br&gt;GROUP by JOB&lt;/pre&gt;&lt;p&gt;&lt;b&gt;5、用 exists 代替 in&lt;/b&gt;&lt;/p&gt;&lt;p&gt;很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num)&lt;/p&gt;&lt;p&gt;&lt;b&gt;6、使用 varchar/nvarchar 代替 char/nchar&lt;/b&gt;&lt;/p&gt;&lt;p&gt;尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。&lt;/p&gt;&lt;p&gt;&lt;b&gt;7、能用DISTINCT的就不用GROUP BY&lt;/b&gt;&lt;/p&gt;&lt;p&gt;SELECT OrderID FROM Details WHERE UnitPrice &amp;gt; 10 GROUP BY OrderID&lt;/p&gt;&lt;p&gt;可改为：&lt;/p&gt;&lt;p&gt;SELECT DISTINCT OrderID FROM Details WHERE UnitPrice &amp;gt; 10&lt;/p&gt;&lt;p&gt;&lt;b&gt;8、能用UNION ALL就不要用UNION&lt;/b&gt;&lt;/p&gt;&lt;p&gt;UNION ALL不执行SELECT DISTINCT函数，这样就会减少很多不必要的资源。&lt;/p&gt;&lt;p&gt;&lt;b&gt;9、在Join表的时候使用相当类型的例，并将其索引&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果应用程序有很多JOIN 查询，你应该确认两个表中Join的字段是被建过索引的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。&lt;/p&gt;&lt;p&gt;而且，这些被用来Join的字段，应该是相同的类型的。例如：如果你要把 DECIMAL 字段和一个 INT 字段Join在一起，MySQL就无法使用它们的索引。对于那些STRING类型，还需要有相同的字符集才行。（两个表的字符集有可能不一样）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;作者：腾讯云加社区&lt;/p&gt;&lt;p&gt;链接：https://juejin.im/post/5c2c8dace51d455d382ee046&lt;/p&gt;&lt;p&gt;来源：掘金&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\r\n                                                                                        ',0,'2019-01-03 00:00:00','11',87),(48,1,'sql 中的 group by 语句的作用到底是什么','','&lt;div&gt;是分组函数&lt;/div&gt;&lt;div&gt;比如 现有&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;性别 男 3 人 体重 50KG/60KG/70&amp;nbsp;&lt;/div&gt;&lt;div&gt;性别 女 2 人 体重 40KG/30KG 这时 你用到group by 进行分组&lt;/div&gt;&lt;div&gt;select sum(体重) ,性别 from 表明 group by 性别 ；&lt;/div&gt;&lt;div&gt;则能得到结果&amp;nbsp;&lt;/div&gt;&lt;div&gt;男 180&lt;/div&gt;&lt;div&gt;女 70&lt;/div&gt;&lt;div&gt;等于说 是按照你所 group by 的 东西进行分组 ，然后再对分组内的东西进行操作&lt;/div&gt;\r\n                                                            ',0,'2016-07-06 00:00:00','11',31),(49,1,'mysql中distinct详解和用法','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;distinct简单来说就是用来去重的，而group by的设计目的则是用来聚合统计的，两者在能够实现的功能上有些相同之处，但应该仔细区分，因为用错场景的话，效率相差可以倍计。&lt;/p&gt;&lt;p&gt;单纯的去重操作使用distinct，速度是快于group by的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;distinct&lt;/b&gt;&lt;/p&gt;&lt;p&gt;distinct支持单列、多列的去重方式。&amp;nbsp;&lt;/p&gt;&lt;p&gt;单列去重的方式简明易懂，即相同值只保留1个。&amp;nbsp;&lt;/p&gt;&lt;p&gt;多列的去重则是根据指定的去重的列信息来进行，即只有所有指定的列信息都相同，才会被认为是重复的信息。&lt;/p&gt;&lt;p&gt;示例一下：&lt;/p&gt;&lt;pre&gt;示例数据表中的数据：&lt;br&gt;mysql&amp;gt; select * from talk_test;&lt;br&gt;+----+-------+--------+&lt;br&gt;| id | name&amp;nbsp; | mobile |&lt;br&gt;+----+-------+--------+&lt;br&gt;|&amp;nbsp; 1 | xiao9 | 555555 |&lt;br&gt;|&amp;nbsp; 2 | xiao6 | 666666 |&lt;br&gt;|&amp;nbsp; 3 | xiao9 | 888888 |&lt;br&gt;|&amp;nbsp; 4 | xiao9 | 555555 |&lt;br&gt;|&amp;nbsp; 5 | xiao6 | 777777 |&lt;br&gt;+----+-------+--------+&lt;br&gt;进行单列去重后的结果：&lt;br&gt;mysql&amp;gt; select distinct(name) from talk_test;&lt;br&gt;+-------+&lt;br&gt;| name&amp;nbsp; |&lt;br&gt;+-------+&lt;br&gt;| xiao9 |&lt;br&gt;| xiao6 |&lt;br&gt;+-------+&lt;br&gt;2 rows in set (0.01 sec)&lt;br&gt;mysql&amp;gt; select distinct(mobile) from talk_test;&lt;br&gt;+--------+&lt;br&gt;| mobile |&lt;br&gt;+--------+&lt;br&gt;| 555555 |&lt;br&gt;| 666666 |&lt;br&gt;| 888888 |&lt;br&gt;| 777777 |&lt;br&gt;+--------+&lt;br&gt;**只会保留指定的列的信息&lt;br&gt;进行多列去重后的结果：&lt;br&gt;mysql&amp;gt; select distinct name,mobile from talk_test;&lt;br&gt;+-------+--------+&lt;br&gt;| name&amp;nbsp; | mobile |&lt;br&gt;+-------+--------+&lt;br&gt;| xiao9 | 555555 |&lt;br&gt;| xiao6 | 666666 |&lt;br&gt;| xiao9 | 888888 |&lt;br&gt;| xiao6 | 777777 |&lt;br&gt;+-------+--------+&lt;br&gt;**只有所有指定的列信息都相同，才会被认定为重复的信&lt;/pre&gt;&lt;p&gt;group by使用的频率相对较高，但正如其功能一样，它的目的是用来进行聚合统计的，虽然也可能实现去重的功能，但这并不是它的长项。&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;',0,'2015-06-09 00:00:00','11',46),(50,1,'Union与Union All的区别','','&lt;div&gt;如果我们需要将两个select语句的结果作为一个整体显示出来，我们就需要用到union或者union all关键字。union(或称为联合)的作用是将多个结果合并在一起显示出来。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;union和union all的区别是:&lt;/div&gt;&lt;div&gt;union会自动压缩多个结果集合中的重复结果(&lt;span style=&quot;color: rgb(51, 51, 51); font-family: &amp;quot;Microsoft YaHei&amp;quot;; font-size: 16px;&quot;&gt;不包括重复行&lt;/span&gt;)，而union all则将所有的结果全部显示出来，不管是不是重复。&lt;/div&gt;&lt;div&gt;&lt;div&gt;例如：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;select employee_id,job_id from employees&amp;nbsp;&lt;br&gt;union&amp;nbsp;&lt;br&gt;select employee_id,job_id from job_history&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;以上将两个表的结果联合在一起。这两个例子会将两个select语句的结果中的重复值进行压缩，也就是结果的数据并不是两条结果的条数的和。如果希望即使重复的结果显示出来可以使用union all,例如：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.用户中有表emp&amp;nbsp;&lt;/div&gt;&lt;pre&gt;select * from emp where deptno &amp;gt;= 20&amp;nbsp;&lt;br&gt;union all&amp;nbsp;&lt;br&gt;select * from emp where deptno &amp;lt;= 30&amp;nbsp; &lt;/pre&gt;&lt;p&gt;这里的结果就有很多重复值了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;注：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.&lt;/b&gt;能用UNION ALL就不要用UNION&amp;nbsp; ，UNION ALL不执行SELECT DISTINCT函数，这样就会减少很多不必要的资源。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.&lt;/b&gt;可以用UNION ALL 来代替OR查询&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;pre&gt;低效：select * from t_credit_detail where Flistid = \'2000000608201108010831508721\' or Flistid = \'10000200001\';&lt;br&gt;高效：select from t_credit_detail where Flistid = \'2000000608201108010831508721\' union all select from t_credit_detail where Flistid = \'10000200001\';&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;',0,'2015-06-10 00:00:00','11',29),(51,1,'数据库分库分表，何时分？怎样分？','','&lt;p&gt;&lt;p&gt;\n                                &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一. 数据切分&lt;/p&gt;&lt;p data-anchor-id=&quot;nne9&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;关系型数据库本身比较容易成为系统瓶颈，单机存储容量、连接数、处理能力都有限。当单表的数据量达到1000W或100G以后，由于查询维度较多，即使添加从库、优化索引，做很多操作时性能仍下降严重。此时就要考虑对其进行切分了，切分的目的就在于减少数据库的负担，缩短查询时间。&lt;/p&gt;&lt;p data-anchor-id=&quot;5wpb&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; color: rgb(51, 102, 255); overflow-wrap: break-word !important;&quot;&gt;数据库分布式核心内容无非就是数据切分（Sharding）&lt;/span&gt;，以及切分后对数据的定位、整合。数据切分就是将数据分散存储到多个数据库中，使得单一数据库中的数据量变小，通过扩充主机的数量缓解单一数据库的性能问题，从而达到提升数据库操作性能的目的。&lt;/p&gt;&lt;p data-anchor-id=&quot;q9o8&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;数据切分根据其切分类型，可以分为两种方式：垂直（纵向）切分和水平（横向）切分&lt;/p&gt;&lt;h3 data-anchor-id=&quot;ptoh&quot; style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; font-weight: bold; font-size: 16px; max-width: 100%; letter-spacing: 0.544px; line-height: 1.5; color: rgb(0, 0, 0); font-family: 微软雅黑, PTSans, Arial, sans-serif; overflow-wrap: break-word !important;&quot;&gt;1、垂直（纵向）切分&lt;/h3&gt;&lt;p data-anchor-id=&quot;06w9&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;垂直切分常见有垂直分库和垂直分表两种。&lt;/p&gt;&lt;p data-anchor-id=&quot;10m7&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; color: rgb(51, 102, 255); overflow-wrap: break-word !important;&quot;&gt;垂直分库&lt;/span&gt;就是根据业务耦合性，将关联度低的不同表存储在不同的数据库。做法与大系统拆分为多个小系统类似，按业务分类进行独立划分。与&quot;微服务治理&quot;的做法相似，每个微服务使用单独的一个数据库。如图：&lt;/p&gt;&lt;p data-anchor-id=&quot;10m7&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;&lt;img src=&quot;/upload/article/20190104/1c3200e5d34991c6bfaa7cb11bc27a4b.png&quot; data-filename=&quot;img&quot; style=&quot;width: 500px;&quot;&gt;&lt;/p&gt;&lt;p data-anchor-id=&quot;10m7&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; letter-spacing: 0.544px; color: rgb(51, 102, 255); overflow-wrap: break-word !important;&quot;&gt;垂直分表&lt;/span&gt;&lt;span style=&quot;letter-spacing: 0.544px;&quot;&gt;是基于数据库中的&quot;列&quot;进行，某个表字段较多，可以新建一张扩展表，将不经常用或字段长度较大的字段拆分出去到扩展表中。在字段很多的情况下（例如一个大表有100多个字段），通过&quot;大表拆小表&quot;，更便于开发与维护，也能避免跨页问题，MySQL底层是通过数据页存储的，一条记录占用空间过大会导致跨页，造成额外的性能开销。另外数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能加载更多的数据，命中率更高，减少了磁盘IO，从而提升了数据库性能。&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;p data-anchor-id=&quot;q9o8&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;&lt;img src=&quot;/upload/article/20190104/82893fe72ce4dfc0fa31750e8ef381a8.png&quot; data-filename=&quot;img&quot; style=&quot;width: 500px;&quot;&gt;&lt;/p&gt;&lt;p data-anchor-id=&quot;u3j9&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;垂直切分的优点：&lt;/p&gt;&lt;ul data-anchor-id=&quot;xjkp&quot; class=&quot;list-paddingleft-2&quot; style=&quot;margin-right: 0px; margin-bottom: 0px; margin-left: 30px; padding: 0px 0px 0px 2.2em; max-width: 100%; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;li style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;解决业务系统层面的耦合，业务清晰&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;与微服务的治理类似，也能对不同业务的数据进行分级管理、维护、监控、扩展等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;高并发场景下，垂直切分一定程度的提升IO、数据库连接数、单机硬件资源的瓶颈&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-anchor-id=&quot;wy9p&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;缺点：&lt;/span&gt;&lt;/p&gt;&lt;ul data-anchor-id=&quot;lk8h&quot; class=&quot;list-paddingleft-2&quot; style=&quot;margin-right: 0px; margin-bottom: 0px; margin-left: 30px; padding: 0px 0px 0px 2.2em; max-width: 100%; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;li style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;部分表无法join，只能通过接口聚合方式解决，提升了开发的复杂度&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;分布式事务处理复杂&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;依然存在单表数据量过大的问题（需要水平切分）&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-anchor-id=&quot;ux1c&quot; style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; font-weight: bold; font-size: 16px; max-width: 100%; letter-spacing: 0.544px; line-height: 1.5; color: rgb(0, 0, 0); font-family: 微软雅黑, PTSans, Arial, sans-serif; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;2、水平（横向）切分&lt;/span&gt;&lt;/h3&gt;&lt;p data-anchor-id=&quot;65hz&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈，这时候就需要进行水平切分了。&lt;/span&gt;&lt;/p&gt;&lt;p data-anchor-id=&quot;v57u&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;水平切分分为&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; color: rgb(51, 102, 255); overflow-wrap: break-word !important;&quot;&gt;库内分表和分库分表&lt;/span&gt;，是根据表内数据内在的逻辑关系，将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果。如图所示：&lt;/span&gt;&lt;/p&gt;&lt;p data-anchor-id=&quot;v57u&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;&lt;img src=&quot;/upload/article/20190104/9fbbfc7bca8a2ba83bc5124c02f4db68.png&quot; data-filename=&quot;img&quot; style=&quot;width: 405px;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-anchor-id=&quot;tobh&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;库内分表只解决了单一表数据量过大的问题，但没有将表分布到不同机器的库上，因此对于减轻MySQL数据库的压力来说，帮助不是很大，大家还是竞争同一个物理机的CPU、内存、网络IO，最好通过分库分表来解决。&lt;/span&gt;&lt;/p&gt;&lt;p data-anchor-id=&quot;yty0&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;水平切分的优点：&lt;/span&gt;&lt;/p&gt;&lt;ul data-anchor-id=&quot;qixb&quot; class=&quot;list-paddingleft-2&quot; style=&quot;margin-right: 0px; margin-bottom: 0px; margin-left: 30px; padding: 0px 0px 0px 2.2em; max-width: 100%; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;li style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;不存在单库数据量过大、高并发的性能瓶颈，提升系统稳定性和负载能力&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;应用端改造较小，不需要拆分业务模块&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-anchor-id=&quot;lhix&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;缺点：&lt;/span&gt;&lt;/p&gt;&lt;ul data-anchor-id=&quot;mpv4&quot; class=&quot;list-paddingleft-2&quot; style=&quot;margin-right: 0px; margin-bottom: 0px; margin-left: 30px; padding: 0px 0px 0px 2.2em; max-width: 100%; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;li style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;跨分片的事务一致性难以保证&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;跨库的join关联查询性能较差&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;数据多次扩展难度和维护量极大&lt;/span&gt;&lt;/p&gt;&lt;p data-anchor-id=&quot;qbrh&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; overflow-wrap: break-word !important;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-anchor-id=&quot;qbrh&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;水平切分后同一张表会出现在多个数据库/表中，每个库/表的内容不同。几种典型的数据分片规则为：&lt;/span&gt;&lt;/p&gt;&lt;h4 data-anchor-id=&quot;zcm5&quot; style=&quot;font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-weight: bold; color: rgb(51, 51, 51); margin-top: 10px; margin-right: 0px; margin-left: 0px; font-size: 14px; letter-spacing: 0.544px; text-align: justify; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; color: rgb(0, 0, 0); overflow-wrap: break-word !important;&quot;&gt;1、根据数值范围&lt;/span&gt;&lt;/h4&gt;&lt;p data-anchor-id=&quot;v7s0&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; color: rgb(51, 102, 255); overflow-wrap: break-word !important;&quot;&gt;按照时间区间或ID区间来切分&lt;/span&gt;。例如：按日期将不同月甚至是日的数据分散到不同的库中；将userId为1~9999的记录分到第一个库，10000~20000的分到第二个库，以此类推。某种意义上，某些系统中使用的&quot;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; color: rgb(51, 102, 255); overflow-wrap: break-word !important;&quot;&gt;冷热数据分离&lt;/span&gt;&quot;，将一些使用较少的历史数据迁移到其他库中，业务功能上只提供热点数据的查询，也是类似的实践。&lt;/span&gt;&lt;/p&gt;&lt;p data-anchor-id=&quot;mao9&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;这样的优点在于：&lt;/span&gt;&lt;/p&gt;&lt;ul data-anchor-id=&quot;mbgg&quot; class=&quot;list-paddingleft-2&quot; style=&quot;margin-right: 0px; margin-bottom: 0px; margin-left: 30px; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; padding: 0px 0px 0px 2.2em; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;li style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;单表大小可控&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;天然便于水平扩展，后期如果想对整个分片集群扩容时，只需要添加节点即可，无需对其他分片的数据进行迁移&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;使用分片字段进行范围查找时，连续分片可快速定位分片进行快速查询，有效避免跨分片查询的问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-anchor-id=&quot;haum&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;缺点：&lt;/span&gt;&lt;/p&gt;&lt;ul data-anchor-id=&quot;bj43&quot; class=&quot;list-paddingleft-2&quot; style=&quot;margin-right: 0px; margin-bottom: 0px; margin-left: 30px; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; padding: 0px 0px 0px 2.2em; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;li style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;热点数据成为性能瓶颈。连续分片可能存在数据热点，例如按时间字段分片，有些分片存储最近时间段内的数据，可能会被频繁的读写，而有些分片存储的历史数据，则很少被查询&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-anchor-id=&quot;vx5e&quot; style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; font-weight: bold; font-size: 14px; max-width: 100%; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; color: rgb(0, 0, 0); overflow-wrap: break-word !important;&quot;&gt;2、根据数值取模&lt;/span&gt;&lt;/h4&gt;&lt;p data-anchor-id=&quot;r5ms&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; color: rgb(51, 102, 255); overflow-wrap: break-word !important;&quot;&gt;一般采用hash取模mod的切分方式&lt;/span&gt;，例如：将 Customer 表根据 cusno 字段切分到4个库中，余数为0的放到第一个库，余数为1的放到第二个库，以此类推。这样同一个用户的数据会分散到同一个库中，如果查询条件带有cusno字段，则可明确定位到相应库去查询。&lt;/span&gt;&lt;/p&gt;&lt;p data-anchor-id=&quot;47xh&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;优点：&lt;/span&gt;&lt;/p&gt;&lt;ul data-anchor-id=&quot;e6ln&quot; class=&quot;list-paddingleft-2&quot; style=&quot;margin-right: 0px; margin-bottom: 0px; margin-left: 30px; padding: 0px 0px 0px 2.2em; max-width: 100%; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;li style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;数据分片相对比较均匀，不容易出现热点和并发访问的瓶颈&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-anchor-id=&quot;7dep&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;缺点：&lt;/span&gt;&lt;/p&gt;&lt;ul data-anchor-id=&quot;ru3w&quot; class=&quot;list-paddingleft-2&quot; style=&quot;margin-right: 0px; margin-bottom: 0px; margin-left: 30px; padding: 0px 0px 0px 2.2em; max-width: 100%; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;li style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;后期分片集群扩容时，需要迁移旧的数据（使用一致性hash算法能较好的避免这个问题）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;容易面临跨分片查询的复杂问题。比如上例中，如果频繁用到的查询条件中不带cusno时，将会导致无法定位数据库，从而需要同时向4个库发起查询，再在内存中合并数据，取最小集返回给应用，分库反而成为拖累。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; font-weight: bold; font-size: 16px; max-width: 100%; letter-spacing: 0.544px; line-height: 1.5; color: rgb(0, 0, 0); font-family: 微软雅黑, PTSans, Arial, sans-serif; overflow-wrap: break-word !important;&quot;&gt;主键避重问题&lt;/h1&gt;&lt;p data-anchor-id=&quot;1qxi&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;在分库分表环境中，由于表中数据同时存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库自生成的ID无法保证全局唯一。因此需要单独设计全局主键，以避免跨库主键重复问题。有一些常见的主键生成策略：&lt;/p&gt;&lt;h4 data-anchor-id=&quot;52ye&quot; style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; font-weight: bold; font-size: 14px; max-width: 100%; color: rgb(51, 51, 51); letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; overflow-wrap: break-word !important;&quot;&gt;1）UUID&lt;/h4&gt;&lt;p data-anchor-id=&quot;5bxp&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;UUID标准形式包含32个16进制数字，分为5段，形式为8-4-4-4-12的36个字符，例如：550e8400-e29b-41d4-a716-446655440000&lt;/p&gt;&lt;p data-anchor-id=&quot;h0i7&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;UUID是主键是最简单的方案，本地生成，性能高，没有网络耗时。但缺点也很明显，由于UUID非常长，会占用大量的存储空间；另外，作为主键建立索引和基于索引进行查询时都会存在性能问题，在InnoDB下，UUID的无序性会引起数据位置频繁变动，导致分页。&lt;/p&gt;&lt;h4 data-anchor-id=&quot;570p&quot; style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; font-weight: bold; font-size: 14px; max-width: 100%; color: rgb(51, 51, 51); letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; overflow-wrap: break-word !important;&quot;&gt;2）结合数据库维护主键ID表&lt;/h4&gt;&lt;p data-anchor-id=&quot;qm2y&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;在数据库中建立 sequence 表：&lt;/p&gt;&lt;pre style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; letter-spacing: 0.544px;&quot;&gt;CREATE TABLE `sequence` (&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; letter-spacing: 0.544px;&quot;&gt;&amp;nbsp; `id` bigint(20) unsigned NOT NULL auto_increment,&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; letter-spacing: 0.544px;&quot;&gt;&amp;nbsp; `stub` char(1) NOT NULL default \'\',&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; letter-spacing: 0.544px;&quot;&gt;&amp;nbsp; PRIMARY KEY&amp;nbsp; (`id`),&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; letter-spacing: 0.544px;&quot;&gt;&amp;nbsp; UNIQUE KEY `stub` (`stub`)&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; letter-spacing: 0.544px;&quot;&gt;) ENGINE=MyISAM;&lt;/span&gt;&lt;/pre&gt;&lt;span style=&quot;font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; letter-spacing: 0.544px;&quot;&gt;stub字段设置为唯一索引，同一stub值在sequence表中只有一条记录，可以同时为多张表生成全局ID。sequence表的内容，如下所示：&lt;/span&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;span style=&quot;font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; letter-spacing: 0.544px;&quot;&gt;+-------------------+------+&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; letter-spacing: 0.544px;&quot;&gt;| id&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | stub |&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; letter-spacing: 0.544px;&quot;&gt;+-------------------+------+&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; letter-spacing: 0.544px;&quot;&gt;| 72157623227190423 |&amp;nbsp; &amp;nbsp; a |&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; letter-spacing: 0.544px;&quot;&gt;+-------------------+------+&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;span style=&quot;font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; letter-spacing: 0.544px;&quot;&gt;使用 MyISAM 存储引擎而不是 InnoDB，以获取更高的性能。MyISAM使用的是表级别的锁，对表的读写是串行的，所以不用担心在并发时两次读取同一个ID值。&lt;/span&gt;&lt;/p&gt;&lt;p data-anchor-id=&quot;q3dx&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;此方案较为简单，但缺点也明显：存在单点问题，强依赖DB，当DB异常时，整个系统都不可用。配置主从可以增加可用性，但当主库挂了，主从切换时，数据一致性在特殊情况下难以保证。另外性能瓶颈限制在单台MySQL的读写性能。&lt;/p&gt;&lt;p data-anchor-id=&quot;do9o&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; color: rgb(51, 102, 255); overflow-wrap: break-word !important;&quot;&gt;flickr团队使用的一种主键生成策略，与上面的sequence表方案类似，但更好的解决了单点和性能瓶颈的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-anchor-id=&quot;do9o&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; color: rgb(51, 102, 255); overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); letter-spacing: 0.544px;&quot;&gt;这一方案的整体思想是：建立2个以上的全局ID生成的服务器，每个服务器上只部署一个数据库，每个库有一张sequence表用于记录当前全局ID。表中ID增长的步长是库的数量，起始值依次错开，这样能将ID的生成散列到各个数据库上。如下图所示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-anchor-id=&quot;7wzy&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;由两个数据库服务器生成ID，设置不同的auto_increment值。第一台sequence的起始值为1，每次步长增长2，另一台的sequence起始值为2，每次步长增长也是2。结果第一台生成的ID都是奇数（1, 3, 5, 7 ...），第二台生成的ID都是偶数（2, 4, 6, 8 ...）。&lt;/p&gt;&lt;p data-anchor-id=&quot;jddd&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;这种方案将生成ID的压力均匀分布在两台机器上。同时提供了系统容错，第一台出现了错误，可以自动切换到第二台机器上获取ID。但有以下几个缺点：系统添加机器，水平扩展时较复杂；每次获取ID都要读写一次DB，DB的压力还是很大，只能靠堆机器来提升性能。&lt;/p&gt;&lt;p data-anchor-id=&quot;do9o&quot; style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; max-width: 100%; clear: both; min-height: 1em; letter-spacing: 0.544px; font-family: 微软雅黑, PTSans, Arial, sans-serif; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; color: rgb(51, 102, 255); overflow-wrap: break-word !important;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;',0,'2018-10-09 00:00:00','11',54),(52,1,'MySQL慢查询日志设置和分析','','&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;MySQL中的日志包括：错误日志、二进制日志、通用查询日志、慢查询日志等等。这里主要介绍下比较常用的两个功能：通用查询日志和慢查询日志。&lt;br&gt;&lt;/div&gt;&lt;div&gt;1）通用查询日志：记录建立的客户端连接和执行的语句。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2）慢查询日志：记录所有执行时间超过long_query_time秒的所有查询或者不使用索引的查询&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;（1）通用查询日志&lt;/b&gt;&lt;/div&gt;&lt;div&gt;在学习通用日志查询时，需要知道两个数据库中的常用命令：&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;1） show variables like \'%version%\';&lt;/div&gt;&lt;div&gt;&lt;pre&gt;mysql&amp;gt; show variables like \'%version%\';&lt;br&gt;+-------------------------+------------------------------+&lt;br&gt;| Variable_name&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| Value&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;+-------------------------+------------------------------+&lt;br&gt;| innodb_version&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | 5.6.37&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| protocol_version&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | 10&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| slave_type_conversions&amp;nbsp; |&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;| version&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| 5.6.37-log&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| version_comment&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| MySQL Community Server (GPL) |&lt;br&gt;| version_compile_machine | x86_64&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| version_compile_os&amp;nbsp; &amp;nbsp; &amp;nbsp; | Linux&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;+-------------------------+------------------------------+&lt;br&gt;7 rows in set (0.00 sec)&lt;br&gt;#上述命令，显示当前数据库中与版本号相关的东西。&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;2） show variables like ‘%general%’;&lt;/div&gt;&lt;pre&gt;mysql&amp;gt;&amp;nbsp; show variables like \'%general%\';&lt;br&gt;+------------------+-------------------------------+&lt;br&gt;| Variable_name&amp;nbsp; &amp;nbsp; | Value&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;+------------------+-------------------------------+&lt;br&gt;| general_log&amp;nbsp; &amp;nbsp; &amp;nbsp; | OFF&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| general_log_file | /var/lib/mysql/nginx-test.log |&lt;br&gt;+------------------+-------------------------------+&lt;br&gt;2 rows in set (0.00 sec)&lt;br&gt;#可以查看，当前的通用日志查询是否开启，如果general_log的值为ON则为开启，为OFF则为关闭（默认情况下是关闭的）。&lt;/pre&gt;&lt;p&gt;3） show variables like ‘%log_output%’;&lt;/p&gt;&lt;pre&gt;mysql&amp;gt; show variables like \'%log_output%\';&lt;br&gt;+---------------+-------+&lt;br&gt;| Variable_name | Value |&lt;br&gt;+---------------+-------+&lt;br&gt;| log_output&amp;nbsp; &amp;nbsp; | FILE&amp;nbsp; |&lt;br&gt;+---------------+-------+&lt;br&gt;1 row in set (0.00 sec)&lt;br&gt;查看当前慢查询日志输出的格式，可以是FILE（存储在数数据库的数据文件中的hostname.log），也可以是TABLE（存储在数据库中的mysql.general_log）&lt;/pre&gt;&lt;p&gt;问题：如何开启MySQL通用查询日志，以及如何设置要输出的通用日志输出格式呢？&lt;/p&gt;&lt;pre&gt;开启通用日志查询： set global general_log=on;&lt;br&gt;关闭通用日志查询： set global general_log=off;&lt;br&gt;设置通用日志输出为表方式： set global log_output=’TABLE’;&lt;br&gt;设置通用日志输出为文件方式： set global log_output=’FILE’;&lt;br&gt;设置通用日志输出为表和文件方式：set global log_output=’FILE,TABLE’;&lt;/pre&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;#注意：上述命令只对当前生效，当MySQL重启失效，如果要永久生效，需要配置my.cnf&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;日志输出的效果图如下：&lt;/p&gt;&lt;p&gt;记录到mysql.general_log表结构如下：&lt;/p&gt;&lt;pre&gt;mysql&amp;gt; desc general_log;&lt;br&gt;+--------------+---------------------+------+-----+-------------------+-----------------------------+&lt;br&gt;| Field&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | Type&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | Null | Key | Default&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| Extra&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;+--------------+---------------------+------+-----+-------------------+-----------------------------+&lt;br&gt;| event_time&amp;nbsp; &amp;nbsp;| timestamp&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| NO&amp;nbsp; &amp;nbsp;|&amp;nbsp; &amp;nbsp; &amp;nbsp;| CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |&lt;br&gt;| user_host&amp;nbsp; &amp;nbsp; | mediumtext&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | NO&amp;nbsp; &amp;nbsp;|&amp;nbsp; &amp;nbsp; &amp;nbsp;| NULL&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| thread_id&amp;nbsp; &amp;nbsp; | bigint(21) unsigned | NO&amp;nbsp; &amp;nbsp;|&amp;nbsp; &amp;nbsp; &amp;nbsp;| NULL&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| server_id&amp;nbsp; &amp;nbsp; | int(10) unsigned&amp;nbsp; &amp;nbsp; | NO&amp;nbsp; &amp;nbsp;|&amp;nbsp; &amp;nbsp; &amp;nbsp;| NULL&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| command_type | varchar(64)&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| NO&amp;nbsp; &amp;nbsp;|&amp;nbsp; &amp;nbsp; &amp;nbsp;| NULL&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| argument&amp;nbsp; &amp;nbsp; &amp;nbsp;| mediumtext&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | NO&amp;nbsp; &amp;nbsp;|&amp;nbsp; &amp;nbsp; &amp;nbsp;| NULL&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;+--------------+---------------------+------+-----+-------------------+-----------------------------+&lt;br&gt;6 rows in set (0.00 sec)&lt;/pre&gt;&lt;p&gt;my.cnf文件的配置如下：&lt;/p&gt;&lt;pre&gt;general_log=1&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; #为1表示开启通用日志查询，值为0表示关闭通用日志查询&lt;br&gt;log_output=FILE,TABLE&amp;nbsp; #设置通用日志的输出格式为文件和表&lt;/pre&gt;&lt;p&gt;（2）慢查询日志&lt;/p&gt;&lt;p&gt;MySQL的慢查询日志是MySQL提供的一种日志记录，用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中（日志可以写入文件或者数据库表，如果对性能要求高的话，建议写文件）。默认情况下，MySQL数据库是不开启慢查询日志的，long_query_time的默认值为10（即10秒，通常设置为1秒），即运行10秒以上的语句是慢查询语句。&lt;/p&gt;&lt;p&gt;一般来说，慢查询发生在大表（比如：一个表的数据量有几百万），且查询条件的字段没有建立索引，此时，要匹配查询条件的字段会进行全表扫描，耗时查过long_query_time，则为慢查询语句。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;问题：如何查看当前慢查询日志的开启情况？&lt;/p&gt;&lt;p&gt;在MySQL中输入命令：&lt;/p&gt;&lt;p&gt;show variables like \'%quer%\';&lt;/p&gt;&lt;pre&gt;mysql&amp;gt; show variables like \'%quer%\';&lt;br&gt;+----------------------------------------+-------------------------------+&lt;br&gt;| Variable_name&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | Value&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;+----------------------------------------+-------------------------------+&lt;br&gt;| binlog_rows_query_log_events&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| OFF&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| ft_query_expansion_limit&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| 20&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;| have_query_cache&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| YES&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| log_queries_not_using_indexes&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | ON&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;| log_throttle_queries_not_using_indexes | 0&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| long_query_time&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | 10.000000&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| query_alloc_block_size&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| 8192&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;| query_cache_limit&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | 1048576&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| query_cache_min_res_unit&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| 4096&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;| query_cache_size&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| 1048576&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| query_cache_type&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| OFF&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| query_cache_wlock_invalidate&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| OFF&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| query_prealloc_size&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | 8192&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;| slow_query_log&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| ON&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;| slow_query_log_file&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | /var/log/mysql/mysql_slow.log |&lt;br&gt;+----------------------------------------+-------------------------------+&lt;br&gt;15 rows in set (0.00 sec)&lt;/pre&gt;&lt;p&gt;#主要掌握以下的几个参数：&lt;/p&gt;&lt;pre&gt;（1）set global slow_query_log 的值为ON为开启慢查询日志，OFF则为关闭慢查询日志。&lt;br&gt;（2） set global slow_query_log_file的值是记录的慢查询日志到文件中&lt;br&gt;&amp;nbsp; &amp;nbsp; （注意：默认名为主机名.log，慢查询日志是否写入指定文件中，需要指定慢查询的输出日志格式为文件，相关命令为：show variables like ‘%log_output%’；去查看输出的格式）。&lt;br&gt;（3）set global long_query_time 指定了慢查询的阈值，即如果执行语句的时间超过该阈值则为慢查询语句，默认值为10秒。&lt;br&gt;（4）set global log_queries_not_using_indexes 如果值设置为ON，则会记录所有没有利用索引的查询&lt;br&gt;&amp;nbsp; &amp;nbsp; （注意：如果只是将log_queries_not_using_indexes设置为ON，而将slow_query_log设置为OFF，此时该设置也不会生效，即该设置生效的前提是slow_query_log的值设置为ON），一般在性能调优的时候会暂时开启。&lt;/pre&gt;&lt;pre&gt;配置文件设置(永久设置，重启MYSQL)&lt;br&gt;    修改配置文件my.cnf，在[mysqld]下的下方加入&lt;br&gt;[mysqld]&lt;br&gt;slow_query_log = ON&lt;br&gt;slow_query_log_file = /usr/local/mysql/data/slow.log&lt;br&gt;long_query_time = 1&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;问题：设置MySQL慢查询的输出日志格式为文件还是表，或者两者都有？&lt;/p&gt;&lt;p&gt;通过命令：show variables like ‘%log_output%’;&lt;/p&gt;&lt;pre&gt;mysql&amp;gt; show variables like \'%log_output%\';&lt;br&gt;+---------------+------------+&lt;br&gt;| Variable_name | Value&amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;+---------------+------------+&lt;br&gt;| log_output&amp;nbsp; &amp;nbsp; | FILE,TABLE |&lt;br&gt;+---------------+------------+&lt;br&gt;1 row in set (0.00 sec)&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;通过log_output的值可以查看到输出的格式，上面的值为FILE,TABLE。当然，我们也可以设置输出的格式为文本，或者同时记录文本和数据库表中，设置的命令如下：&lt;/p&gt;&lt;p&gt;set global log_output=’TABLE’; #慢查询日志输出到表中（即mysql.slow_log）&lt;/p&gt;&lt;p&gt;set global log_output=’FILE’;&amp;nbsp; #慢查询日志仅输出到文本中(即：slow_query_log_file指定的文件)&lt;/p&gt;&lt;p&gt;set global log_output=’FILE,TABLE’;&amp;nbsp; #慢查询日志同时输出到文本和表中&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;关于慢查询日志的表中的数据个文本中的数据格式分析：&lt;/p&gt;&lt;p&gt;慢查询的日志记录myql.slow_log表中，格式如下：&lt;/p&gt;&lt;pre&gt;mysql&amp;gt; mysql&amp;gt; select * from mysql.slow_log limit 1;&lt;br&gt;+---------------------+--------------------------------+------------+-----------+-----------+---------------+------------+----------------+-----------+-----------+----------------------------------------------------------------------------------------+-----------+&lt;br&gt;| start_time&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | user_host&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | query_time | lock_time | rows_sent | rows_examined | db&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| last_insert_id | insert_id | server_id | sql_text&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| thread_id |&lt;br&gt;+---------------------+--------------------------------+------------+-----------+-----------+---------------+------------+----------------+-----------+-----------+----------------------------------------------------------------------------------------+-----------+&lt;br&gt;| 2018-02-07 11:16:55 | root[root] @&amp;nbsp; [121.196.203.51] | 00:00:00&amp;nbsp; &amp;nbsp;| 00:00:00&amp;nbsp; |&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 13 |&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 40 | jp_core_db |&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 0 |&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;0 |&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;0 | select pd.lastAuction from Product pd where pd.status = \'O\' and pd.auctionStatus = \'A\' |&amp;nbsp; &amp;nbsp; &amp;nbsp; 1621 |&lt;br&gt;+---------------------+--------------------------------+------------+-----------+-----------+---------------+------------+----------------+-----------+-----------+----------------------------------------------------------------------------------------+-----------+&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;慢查询的日志记录到mysql_slow.log文件中，格式如下：&lt;/p&gt;&lt;pre&gt;# Time: 180118 14:58:37&lt;br&gt;# User@Host: root[root] @ localhost []&amp;nbsp; Id:&amp;nbsp; &amp;nbsp;150&lt;br&gt;# Query_time: 0.000270&amp;nbsp; Lock_time: 0.000109 Rows_sent: 0&amp;nbsp; Rows_examined: 6&lt;br&gt;SET timestamp=1516258717;&lt;br&gt;delete from user where User=\'app\';&lt;/pre&gt;&lt;p&gt;#可以看到，不管是表还是文件，都具体记录了：是那条语句导致慢查询（sql_text），该慢查询语句的查询时间（query_time），锁表时间（Lock_time），以及扫描过的行数（rows_examined）等信息&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;问题：如何查询当前慢查询的语句的个数？&lt;/p&gt;&lt;p&gt;在MySQL中有一个变量专门记录当前慢查询语句的个数：&lt;/p&gt;&lt;p&gt;输入命令：show global status like ‘%slow%’;&lt;/p&gt;&lt;pre&gt;mysql&amp;gt; show global status like \'%slow%\';&lt;br&gt;+---------------------+-------+&lt;br&gt;| Variable_name&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| Value |&lt;br&gt;+---------------------+-------+&lt;br&gt;| Slow_launch_threads | 132&amp;nbsp; &amp;nbsp;|&lt;br&gt;| Slow_queries&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | 1772&amp;nbsp; |&lt;br&gt;+---------------------+-------+&lt;br&gt;2 rows in set (0.00 sec)&lt;/pre&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;（注意：上述所有命令，如果都是通过MySQL的shell将参数设置进去，如果重启MySQL，所有设置好的参数将失效，如果想要永久的生效，需要将配置参数写入my.cnf文件中）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;补充知识点：如何利用MySQL自带的慢查询日志分析工具mysqldumpslow分析日志？&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;mysqldumpslow –s c –t 10 slow-query.log&lt;/pre&gt;&lt;p&gt;具体参数设置如下：&lt;/p&gt;&lt;p&gt;-s 表示按何种方式排序，c、t、l、r分别是按照记录次数、时间、查询时间、返回的记录数来排序，ac、at、al、ar，表示相应的倒叙；&lt;/p&gt;&lt;p&gt;-t&amp;nbsp; 表示top的意思，后面跟着的数据表示返回前面多少条；&lt;/p&gt;&lt;p&gt;-g 后面可以写正则表达式匹配，大小写不敏感。&lt;/p&gt;&lt;pre&gt;[root@nginx-test /var/log/mysql]# mysqldumpslow -s c -t 2 /var/log/mysql/mysql_slow.log&amp;nbsp;&lt;br&gt;Reading mysql slow query log from /var/log/mysql/mysql_slow.log&lt;br&gt;Count: 125448&amp;nbsp; Time=0.00s (131s)&amp;nbsp; Lock=0.00s (3s)&amp;nbsp; Rows=2.2 (272835), 2users@2hosts&lt;br&gt;&amp;nbsp; select * from ProductAuction productauc0_ where productauc0_.status=\'S\'&lt;br&gt;Count: 66216&amp;nbsp; Time=0.00s (127s)&amp;nbsp; Lock=0.00s (2s)&amp;nbsp; Rows=1.7 (115074), root[root]@[121.196.203.51]&lt;br&gt;&amp;nbsp; select * where productauc0_.status=\'S\'&lt;/pre&gt;&lt;p&gt;上述中的参数含义如下：&lt;/p&gt;&lt;p&gt;Count:125448&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;#语句出现了125448次；&lt;/p&gt;&lt;p&gt;Time=0.00s（131s）&amp;nbsp; #执行最长时间为0.00s，累计总耗费时间131s；&lt;/p&gt;&lt;p&gt;Lock=0.0s（3s）&amp;nbsp; &amp;nbsp; &amp;nbsp;#等待锁最长时间为0s，累计等待锁耗费时间为3s；&lt;/p&gt;&lt;p&gt;Rows=2.2（272835） #发送给客户端最多的行数为2.2，累计发送给客户端的函数为272835&lt;/p&gt;&lt;p&gt;#注意：mysqldumpslow脚本是用perl语言写的，具体mysqldumpslow的用法后期再讲）&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;问题：如何得知设置的慢查询是有效的？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;很简单，我们可以手动产生一条慢查询语句，比如，如果我们的慢查询log_query_time的值设置为1，则我们可以执行如下语句：&lt;/p&gt;&lt;p&gt;select sleep(1);&lt;/p&gt;&lt;p&gt;该条语句即是慢查询语句，之后，便可以在相应的日志输出文件或表中去查看是否有该条语句。&lt;/p&gt;&lt;/div&gt;\r\n                                                            ',0,'2018-10-16 00:00:00','11',37),(53,1,'tomcat 和Apache、Nginx的区别','','&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Apache、Nginx都是web服务器（或者称之为静态资源服务器），专门处理一些图片、js、css以及html静态网页的；&lt;/div&gt;&lt;div&gt;而tomcat是用来处理动态资源的服务器（jsp网站的服务器之一，tomcat便可以解释jsp等java编写的网站。）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;为什么PHP做的项目，可以不使用Tomcat服务器&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;PHP所有操作都属于动态的，一定要由支持PHP解析器的服务器处理，但是不一定是Tomcat，Apache和Nginx+PHP-FPM都能够执行PHP 脚本。所以，没有Tomcat，但是有Apache、FPM甚至php -S开启的内置 Web 服务器都可以运行 PHP 站点&lt;/div&gt;\r\n                                                            ',0,'2015-06-10 00:00:00','25,26',71),(54,1,'Nginx 本身可以做什么?','','&lt;div&gt;Nginx在不加载第三方模块的情况能处理哪些事情&lt;/div&gt;&lt;ol&gt;&lt;li&gt;反向代理&lt;/li&gt;&lt;li&gt;负载均衡&lt;/li&gt;&lt;li&gt;HTTP服务器（动静分离）&lt;/li&gt;&lt;li&gt;正向代理&lt;/li&gt;&lt;/ol&gt;&lt;div&gt;以上就是我了解到的Nginx在不依赖第三方模块能处理的事情，下面详细说明每种功能怎么做。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;反向代理&lt;/b&gt;&lt;/div&gt;&lt;div&gt;反向代理应该是Nginx做的最多的一件事了，什么是反向代理呢，以下是百度百科的说法：反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。下面贴上一段简单的实现反向代理的代码&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190105/3387157c3394f8cb785d83cf922d39f9.png&quot; data-filename=&quot;img&quot; style=&quot;width: 679px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;保存配置文件后启动Nginx，这样当我们访问localhost的时候，就相当于访问localhost:8080了&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;负载均衡&lt;/b&gt;&lt;/div&gt;&lt;div&gt;负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。&lt;/div&gt;&lt;div&gt;&lt;div&gt;1、RR（默认）&lt;/div&gt;&lt;div&gt;每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;简单配置&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190105/585f24c12326f4669f1a76cee009eaae.png&quot; data-filename=&quot;img&quot; style=&quot;width: 678px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(74, 74, 74); font-family: Avenir, -apple-system-font, 微软雅黑, sans-serif; font-size: 16px; letter-spacing: 0.544px; text-align: justify; white-space: pre-line;&quot;&gt;负载均衡的核心代码为&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190105/da1228d147c570471491a250232200df.png&quot; data-filename=&quot;img&quot; style=&quot;width: 676px;&quot;&gt;&lt;span style=&quot;color: rgb(74, 74, 74); font-family: Avenir, -apple-system-font, 微软雅黑, sans-serif; font-size: 16px; letter-spacing: 0.544px; text-align: justify; white-space: pre-line;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(74, 74, 74); font-family: Avenir, -apple-system-font, 微软雅黑, sans-serif; font-size: 16px; letter-spacing: 0.544px; text-align: justify; white-space: pre-line;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;text-align: justify;&quot;&gt;&lt;font color=&quot;#4a4a4a&quot; face=&quot;Avenir, -apple-system-font, 微软雅黑, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px; letter-spacing: 0.544px; white-space: pre-line;&quot;&gt;这里我配置了2台服务器，当然实际上是一台，只是端口不一样而已，而8081的服务器是不存在的,也就是说访问不到，但是我们访问http://localhost 的时候,也不会有问题，会默认跳转到http://localhost:8080 具体是因为Nginx会自动判断服务器的状态，如果服务器处于不能访问（服务器挂了），就不会跳转到这台服务器，所以也避免了一台服务器挂了影响使用的情况，由于Nginx默认是RR策略，所以我们不需要其他更多的设置。&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;text-align: justify;&quot;&gt;&lt;font color=&quot;#4a4a4a&quot; face=&quot;Avenir, -apple-system-font, 微软雅黑, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px; letter-spacing: 0.544px; white-space: pre-line;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;text-align: justify;&quot;&gt;&lt;font color=&quot;#4a4a4a&quot; face=&quot;Avenir, -apple-system-font, 微软雅黑, sans-serif&quot;&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 16px; letter-spacing: 0.544px; white-space: pre-line;&quot;&gt;2、权重&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 16px; letter-spacing: 0.544px; white-space: pre-line;&quot;&gt;指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。例如&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;img src=&quot;/upload/article/20190105/6225bdac3f815625fea57321e792ff66.png&quot; data-filename=&quot;img&quot; style=&quot;width: 680px;&quot;&gt;&lt;span style=&quot;font-size: 16px; letter-spacing: 0.544px; white-space: pre-line;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 16px; letter-spacing: 0.544px; white-space: pre-line;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 16px; letter-spacing: 0.544px; white-space: pre-line;&quot;&gt;那么10次一般只会有1次会访问到8081，而有9次会访问到8080\r\n\r\n3、ip_hash\r\n上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;img src=&quot;/upload/article/20190105/a8f38f11fcae51dee3c2fab51c3733a3.png&quot; data-filename=&quot;img&quot; style=&quot;width: 676px;&quot;&gt;&lt;span style=&quot;font-size: 16px; letter-spacing: 0.544px; white-space: pre-line;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 16px; letter-spacing: 0.544px; white-space: pre-line;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 16px; letter-spacing: 0.544px; white-space: pre-line;&quot;&gt;4、fair（第三方）\r\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;img src=&quot;/upload/article/20190105/7f521e5eaa04b6d06b4d38c7d7a5e1f6.png&quot; data-filename=&quot;img&quot; style=&quot;width: 674px;&quot;&gt;&lt;span style=&quot;font-size: 16px; letter-spacing: 0.544px; white-space: pre-line;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;br&gt;&lt;div&gt;5、url_hash（第三方）&lt;/div&gt;&lt;div&gt;按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190105/d75ebbdf1e2c05f1e74cc66bc411f56f.png&quot; data-filename=&quot;img&quot; style=&quot;width: 677px;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;/font&gt;&lt;br&gt;&lt;/span&gt;以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过fair和url_hash需要安装第三方模块才能使用，由于本文主要介绍Nginx能做的事情，所以Nginx安装第三方模块不会再本文介绍&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;HTTP服务器&lt;/b&gt;&lt;/div&gt;&lt;div&gt;Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现，首先看看Nginx做静态资源服务器&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190105/7dd71ea3aa09f07cfb55f41899e922fd.png&quot; data-filename=&quot;img&quot; style=&quot;width: 680px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;这样如果访问http://localhost 就会默认访问到E盘wwwroot目录下面的index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;动静分离动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190105/c18a7e6c198bf703343176e12c46dcdc.png&quot; data-filename=&quot;img&quot; style=&quot;width: 675px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这样我们就可以吧HTML以及图片和css以及js放到wwwroot目录下，而tomcat只负责处理jsp和请求，例如当我们后缀为gif的时候，Nginx默认会从wwwroot获取到当前请求的动态图文件返回，当然这里的静态文件跟Nginx是同一台服务器，我们也可以在另外一台服务器，然后通过反向代理和负载均衡配置过去就好了，只要搞清楚了最基本的流程，很多配置就很简单了，另外localtion后面其实是一个正则表达式，所以非常灵活&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;正向代理&lt;/b&gt;&lt;/div&gt;&lt;div&gt;正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。当你需要把你的服务器作为代理服务器的时候，可以用Nginx来实现正向代理&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\r\n                                                            ',0,'2016-06-14 00:00:00','26',43),(55,1,'redis缓存和mysql数据库同步的问题','','&lt;div&gt;解决方案&lt;/div&gt;&lt;div&gt;一、对强一致要求比较高的，应采用实时同步方案，即查询缓存查询不到再从DB查询，保存到缓存；更新缓存时，先更新数据库，再将缓存的设置过期(建议不要去更新缓存内容，直接设置缓存过期)。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;二、对于并发程度较高的，可采用异步队列的方式同步，可采用kafka等消息中间件处理消息生产和消费。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;三、使用阿里的同步工具canal，canal实现方式是模拟mysql slave和master的同步机制，监控DB bitlog的日志更新来触发缓存的更新，此种方法可以解放程序员双手，减少工作量，但在使用时有些局限性。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;四、采用UDF自定义函数的方式，面对mysql的API进行编程，利用触发器进行缓存同步，但UDF主要是c/c++语言实现，学习成本高。&lt;/div&gt;\r\n                                                            ',0,'2016-06-07 00:00:00','11,16',51),(56,1,'解决高并发应该从哪几方面考虑？','','\r\n                                \r\n                                &lt;p&gt;并发的概念：&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp;并发当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间 段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。.这种方式我们称之为并发(Concurrent)。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp;在互联网时代，并发，高并发通常是指并发访问。也就是在某个时间点，有多少个访问同时到来；&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp;大并发量：在同一时间点（1秒内），有多少个用户同时访问我们的网站。对同一个网址，同时刷新浏览器。达到500，就非常大了。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp;大并发的解决方案：&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp;1.硬件&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;配置性能更佳的硬件服务器&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp;2.流量优化&amp;nbsp;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;对静态资源进行防盗链处理(去除恶意请求)&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp;3.前端优化&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; (1) 减少HTTP请求[将css,js等合并]&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;(2) 添加异步请求(不将所有数据都展示给用户,用户触发某个事件,才会异步请求数据)&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;(3) 启用浏览器缓存和文件压缩&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;(4) CDN加速&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;(5) 可以把比较占用流量的一些资源，单独组建一个服务器，比如图片服务器，视频服务器等。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;(6) 启用压缩，减少数据传输的数据量，常见的压缩格式是：gzip,deflate.&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;(7) 页面静态化&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp;4、数据库优化&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;(1) 数据库缓存&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;(2) 分库分表,分区&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;(3) 读写分离&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;(4) 负载均衡&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp;5、web服务器优化&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; (1) 对服务器进行分布式集群部署，nginx反向代理实现负载均衡&lt;/p&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;                                                        ',0,'2015-06-09 00:00:00','33',40),(57,1,'什么是数据库的主从架构','','\r\n                                &lt;p&gt;&lt;b&gt;什么是数据库的主从架构&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; 主从架构主要是用来解决大型网站中由于用户量多，请求变大，造成的数据库性能瓶颈问题；让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE）操作，而从数据库处理SELECT查询操作，即实现读写分离的原理；单库的话，读、写都是操作一个数据库，数据多了之后，对数据库的读、写性能就会有很大影响。同时对于数据安全性，和系统的稳定性，也是挑战。&lt;/p&gt;&lt;p&gt;&amp;nbsp; 首先为什么要读写分离？&lt;/p&gt;&lt;p&gt;　　对于一个小型网站，可能单台数据库服务器就能满足需求，但是在一些大型的网站或者应用中，单台的数据库服务器可能难以支撑大的访问压力，升级服务器性能，成本又太高，必须要横向扩展。还有就是，单库的话，读、写都是操作一个数据库，数据多了之后，对数据库的读、写性能就会有很大影响。同时对于数据安全性，和系统的稳定性，也是挑战。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　数据库的读写分离的好处？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;　　　　1. 将读操作和写操作分离到不同的数据库上，避免主服务器出现性能瓶颈；&lt;/p&gt;&lt;p&gt;　　　　2. 主服务器进行写操作时，不影响查询应用服务器的查询性能，降低阻塞，提高并发；&lt;/p&gt;&lt;p&gt;　　　　3. 数据拥有多个容灾副本，提高数据安全性，同时当主服务器故障时，可立即切换到其他服务器，提高系统可用性；&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190114/96cdfa686fe9c10afb148e6e972ffcca.png&quot; data-filename=&quot;img&quot; style=&quot;width: 680px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;读写分离的基本原理就是让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE）操作，而从数据库处理SELECT查询操作。数据库复制被用来把事务性操作导致的变更同步到其他从数据库。以SQL为例，主库负责写数据、读数据。读库仅负责读数据。每次有写库操作，同步更新到读库。写库就一个，读库可以有多个，采用日志同步的方式实现主库和多个读库的数据同步。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一：Sql Server 读写分离的配置&lt;/p&gt;&lt;p&gt;　　　　SQL Server 提供了三种技术，可以用于主从架构之间的数据同步的实现：日志传送、事务复制和SQL 2012 中新增的功能Always On 技术。各自优劣，&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190114/dc81969ee88bf4d21e15f74ba6c06493.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 576px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;二：数据库读写操作&lt;/p&gt;&lt;p&gt;　请求数据库操作，单数据库和主从架构的数据库还是不一样的。主从架构的数据库，为了保证数据一致性，一般主库可读可写，从库只负责读，不负责写入。所以，实际C#在请求数据库的时候，还是要区别对待。&lt;/p&gt;&lt;p&gt;　1. 最简单的就是：配置两个数据库连接，然后在各个数据库调用的位置，区分读写请求相应的数据库服务器，&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; 2. 第二种解决方案就是判断SQL语句是写语句（insert 、update、Create、 Alter）还是读语句（Select）。&lt;/p&gt;&lt;pre&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; /// 根据数据库的语句，选择相应的DB&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; public static DB SelectDB(string sql,)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; bool redirect2WritableDB = false;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; sql = sql.Trim().TrimStart(\'\\r\').TrimStart(\'\\n\');&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (sql.IndexOf(&quot;UPDATE&quot;, StringComparison.OrdinalIgnoreCase) &amp;gt;= 0)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; redirect2WritableDB = true;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (sql.IndexOf(&quot;DELETE&quot;, StringComparison.OrdinalIgnoreCase) &amp;gt;= 0)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; redirect2WritableDB = true;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (sql.IndexOf(&quot;INSERT&quot;, StringComparison.OrdinalIgnoreCase) &amp;gt;= 0)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; redirect2WritableDB = true;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (sql.IndexOf(&quot;CREATE&quot;, StringComparison.OrdinalIgnoreCase) &amp;gt;= 0)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; redirect2WritableDB = true;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (sql.IndexOf(&quot;ALTER&quot;, StringComparison.OrdinalIgnoreCase) &amp;gt;= 0)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; redirect2WritableDB = true;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/pre&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;                            ',0,'2015-06-08 00:00:00','11,16',19),(58,1,'js数组与字符串的相互转换','','&lt;div&gt;一、数组转字符串&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;需要将数组元素用某个字符连接成字符串，示例代码如下：&lt;/div&gt;&lt;pre&gt;var a, b,c;&amp;nbsp;&lt;br&gt;a = new Array(a,b,c,d,e);&amp;nbsp;&lt;br&gt;b = a.join(\'-\'); //a-b-c-d-e&amp;nbsp; 使用-拼接数组元素&lt;br&gt;c = a.join(\'\'); //abcde&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;二、字符串转数组&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;实现方法为将字符串按某个字符切割成若干个字符串，并以数组形式返回，示例代码如下：&lt;/div&gt;&lt;pre&gt;var str = \'ab+c+de\';&lt;br&gt;var a = str.split(\'+\'); // [ab, c, de]&lt;br&gt;var b = str.split(\'\'); //[a, b, +, c, +, d, e]&lt;/pre&gt;\r\n                                                            ',0,'2015-06-09 00:00:00','22',54),(59,1,'mysql查询分组显示数据结果之GROUP_CONCAT使用','','\n                                \n                                &lt;p&gt;用mysql语句怎么把&amp;nbsp;&lt;img src=&quot;/upload/article/20190110/98d3dc91433681fbdef58ffeb65ec1e5.png&quot; data-filename=&quot;img&quot; style=&quot;width: 218px;&quot;&gt;&amp;nbsp;变成&amp;nbsp;&lt;img src=&quot;/upload/article/20190110/fdf3c4ab9a4685d72bd8f76340b54703.png&quot; data-filename=&quot;img&quot; style=&quot;width: 249px;&quot;&gt;&lt;/p&gt;&lt;p&gt;使用group_concat()函数；&lt;/p&gt;&lt;pre&gt;select GROUP_CONCAT(id) AS id,name from `de_demo1` group by name&lt;/pre&gt;&lt;p&gt;用了GROUP_CONCAT函数，SELECT语句中的LIMIT语句起不了任何作用。&lt;/p&gt;&lt;div class=&quot;line number3 index2 alt2&quot; style=&quot;font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace; font-size: 12px; color: rgb(51, 51, 51); margin: 0px !important; padding: 0px 1em !important; border-radius: 0px !important; background: none rgb(244, 244, 244) !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; min-height: auto !important; white-space: nowrap !important;&quot;&gt;&lt;code class=&quot;csharp plain&quot; style=&quot;margin: 0px !important; padding: 0px !important; border-radius: 0px !important; background: none !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace !important; font-size: 12px !important; min-height: auto !important; color: rgb(0, 0, 0) !important;&quot;&gt;完整的语法如下：&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot; style=&quot;font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace; font-size: 12px; color: rgb(51, 51, 51); margin: 0px !important; padding: 0px 1em !important; border-radius: 0px !important; background-image: none !important; background-position: initial !important; background-size: initial !important; background-repeat: initial !important; background-attachment: initial !important; background-origin: initial !important; background-clip: initial !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; min-height: auto !important; white-space: nowrap !important;&quot;&gt;&lt;code class=&quot;csharp plain&quot; style=&quot;margin: 0px !important; padding: 0px !important; border-radius: 0px !important; background: none !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace !important; font-size: 12px !important; min-height: auto !important; color: rgb(0, 0, 0) !important;&quot;&gt;group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排序字段] [Separator&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;csharp string&quot; style=&quot;margin: 0px !important; padding: 0px !important; border-radius: 0px !important; background: none !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace !important; font-size: 12px !important; min-height: auto !important; color: blue !important;&quot;&gt;\'分隔符\'&lt;/code&gt;&lt;code class=&quot;csharp plain&quot; style=&quot;margin: 0px !important; padding: 0px !important; border-radius: 0px !important; background: none !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace !important; font-size: 12px !important; min-height: auto !important; color: rgb(0, 0, 0) !important;&quot;&gt;])&lt;/code&gt;&lt;/div&gt;&lt;pre style=&quot;font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace; font-size: 12px; color: rgb(51, 51, 51); margin: 0px !important; padding: 0px 1em !important; border-radius: 0px !important; background-image: none !important; background-position: initial !important; background-size: initial !important; background-repeat: initial !important; background-attachment: initial !important; background-origin: initial !important; background-clip: initial !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; min-height: auto !important; white-space: nowrap !important;&quot;&gt;&lt;code class=&quot;csharp plain&quot; style=&quot;margin: 0px !important; padding: 0px !important; border-radius: 0px !important; background: none !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace !important; font-size: 12px !important; min-height: auto !important; color: rgb(0, 0, 0) !important;&quot;&gt;&lt;code class=&quot;csharp plain&quot; style=&quot;font-size: 12px; margin: 0px !important; padding: 0px !important; border-radius: 0px !important; background: none !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace !important; min-height: auto !important; color: rgb(0, 0, 0) !important;&quot;&gt;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;csharp keyword&quot; style=&quot;font-size: 12px; margin: 0px !important; padding: 0px !important; border-radius: 0px !important; background: none !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace !important; min-height: auto !important; color: rgb(0, 0, 255) !important;&quot;&gt;select&lt;/code&gt;&lt;span style=&quot;color: rgb(51, 51, 51);&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;code class=&quot;csharp plain&quot; style=&quot;font-size: 12px; margin: 0px !important; padding: 0px !important; border-radius: 0px !important; background: none !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace !important; min-height: auto !important; color: rgb(0, 0, 0) !important;&quot;&gt;id,group_concat(name order&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;csharp keyword&quot; style=&quot;font-size: 12px; margin: 0px !important; padding: 0px !important; border-radius: 0px !important; background: none !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace !important; min-height: auto !important; color: rgb(0, 0, 255) !important;&quot;&gt;by&lt;/code&gt;&lt;span style=&quot;color: rgb(51, 51, 51);&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;code class=&quot;csharp plain&quot; style=&quot;font-size: 12px; margin: 0px !important; padding: 0px !important; border-radius: 0px !important; background: none !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace !important; min-height: auto !important; color: rgb(0, 0, 0) !important;&quot;&gt;name desc)&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;csharp keyword&quot; style=&quot;font-size: 12px; margin: 0px !important; padding: 0px !important; border-radius: 0px !important; background: none !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace !important; min-height: auto !important; color: rgb(0, 0, 255) !important;&quot;&gt;from&lt;/code&gt;&lt;span style=&quot;color: rgb(51, 51, 51);&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;code class=&quot;csharp plain&quot; style=&quot;font-size: 12px; margin: 0px !important; padding: 0px !important; border-radius: 0px !important; background: none !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace !important; min-height: auto !important; color: rgb(0, 0, 0) !important;&quot;&gt;aa&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;csharp keyword&quot; style=&quot;font-size: 12px; margin: 0px !important; padding: 0px !important; border-radius: 0px !important; background: none !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace !important; min-height: auto !important; color: rgb(0, 0, 255) !important;&quot;&gt;group&lt;/code&gt;&lt;span style=&quot;color: rgb(51, 51, 51);&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;code class=&quot;csharp keyword&quot; style=&quot;font-size: 12px; margin: 0px !important; padding: 0px !important; border-radius: 0px !important; background: none !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace !important; min-height: auto !important; color: rgb(0, 0, 255) !important;&quot;&gt;by&lt;/code&gt;&lt;span style=&quot;color: rgb(51, 51, 51);&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;code class=&quot;csharp plain&quot; style=&quot;font-size: 12px; margin: 0px !important; padding: 0px !important; border-radius: 0px !important; background: none !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace !important; min-height: auto !important; color: rgb(0, 0, 0) !important;&quot;&gt;id;&lt;/code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre style=&quot;font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace; font-size: 12px; color: rgb(51, 51, 51); margin: 0px !important; padding: 0px 1em !important; border-radius: 0px !important; background-image: none !important; background-position: initial !important; background-size: initial !important; background-repeat: initial !important; background-attachment: initial !important; background-origin: initial !important; background-clip: initial !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; min-height: auto !important; white-space: nowrap !important;&quot;&gt;&lt;code class=&quot;csharp plain&quot; style=&quot;margin: 0px !important; padding: 0px !important; border-radius: 0px !important; background: none !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace !important; font-size: 12px !important; min-height: auto !important; color: rgb(0, 0, 0) !important;&quot;&gt;&lt;code class=&quot;csharp plain&quot; style=&quot;font-size: 12px; margin: 0px !important; padding: 0px !important; border-radius: 0px !important; background: none !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace !important; min-height: auto !important; color: rgb(0, 0, 0) !important;&quot;&gt;&lt;br&gt;&lt;/code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre style=&quot;font-family: Consolas, &amp;quot;Bitstream Vera Sans Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, Courier, monospace; font-size: 12px; margin: 0px !important; padding: 0px 1em !important; border-radius: 0px !important; background-image: none !important; background-position: initial !important; background-size: initial !important; background-repeat: initial !important; background-attachment: initial !important; background-origin: initial !important; background-clip: initial !important; border: 0px !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.8em !important; outline: 0px !important; overflow: visible !important; position: static !important; right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; min-height: auto !important;&quot;&gt;&lt;font color=&quot;#000000&quot;&gt;多个字段格式： &lt;/font&gt;GROUP_CONCAT&lt;span style=&quot;color: rgb(56, 58, 66); font-family: &amp;quot;Source Code Pro&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Ubuntu Mono&amp;quot;, &amp;quot;Anonymous Pro&amp;quot;, &amp;quot;Droid Sans Mono&amp;quot;, Menlo, Monaco, Consolas, Inconsolata, Courier, monospace, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, sans-serif; font-size: 14px; white-space: pre; background-color: rgb(250, 250, 250);&quot;&gt;(c.USER_NAME,&lt;/span&gt;&lt;span class=&quot;hljs-string&quot; style=&quot;outline: 0px; margin: 0px; padding: 0px; font-family: &amp;quot;Source Code Pro&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Ubuntu Mono&amp;quot;, &amp;quot;Anonymous Pro&amp;quot;, &amp;quot;Droid Sans Mono&amp;quot;, Menlo, Monaco, Consolas, Inconsolata, Courier, monospace, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, sans-serif; color: rgb(80, 161, 79); overflow-wrap: break-word; font-size: 14px; white-space: pre; background-color: rgb(250, 250, 250);&quot;&gt;\',\'&lt;/span&gt;&lt;span style=&quot;color: rgb(56, 58, 66); font-family: &amp;quot;Source Code Pro&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Ubuntu Mono&amp;quot;, &amp;quot;Anonymous Pro&amp;quot;, &amp;quot;Droid Sans Mono&amp;quot;, Menlo, Monaco, Consolas, Inconsolata, Courier, monospace, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, sans-serif; font-size: 14px; white-space: pre; background-color: rgb(250, 250, 250);&quot;&gt;, c.&lt;/span&gt;&lt;span class=&quot;hljs-string&quot; style=&quot;outline: 0px; margin: 0px; padding: 0px; font-family: &amp;quot;Source Code Pro&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Ubuntu Mono&amp;quot;, &amp;quot;Anonymous Pro&amp;quot;, &amp;quot;Droid Sans Mono&amp;quot;, Menlo, Monaco, Consolas, Inconsolata, Courier, monospace, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, sans-serif; color: rgb(80, 161, 79); overflow-wrap: break-word; font-size: 14px; white-space: pre; background-color: rgb(250, 250, 250);&quot;&gt;`PASSWORD`&lt;/span&gt;&lt;span style=&quot;color: rgb(56, 58, 66); font-family: &amp;quot;Source Code Pro&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Ubuntu Mono&amp;quot;, &amp;quot;Anonymous Pro&amp;quot;, &amp;quot;Droid Sans Mono&amp;quot;, Menlo, Monaco, Consolas, Inconsolata, Courier, monospace, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, sans-serif; font-size: 14px; white-space: pre; background-color: rgb(250, 250, 250);&quot;&gt; SEPARATOR &lt;/span&gt;&lt;span class=&quot;hljs-string&quot; style=&quot;outline: 0px; margin: 0px; padding: 0px; font-family: &amp;quot;Source Code Pro&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Ubuntu Mono&amp;quot;, &amp;quot;Anonymous Pro&amp;quot;, &amp;quot;Droid Sans Mono&amp;quot;, Menlo, Monaco, Consolas, Inconsolata, Courier, monospace, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, sans-serif; color: rgb(80, 161, 79); overflow-wrap: break-word; font-size: 14px; white-space: pre; background-color: rgb(250, 250, 250);&quot;&gt;\'|\'&lt;/span&gt;&lt;span style=&quot;color: rgb(56, 58, 66); font-family: &amp;quot;Source Code Pro&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Ubuntu Mono&amp;quot;, &amp;quot;Anonymous Pro&amp;quot;, &amp;quot;Droid Sans Mono&amp;quot;, Menlo, Monaco, Consolas, Inconsolata, Courier, monospace, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, sans-serif; font-size: 14px; white-space: pre; background-color: rgb(250, 250, 250);&quot;&gt;)&lt;/span&gt;&lt;/pre&gt;                                                        ',0,'2015-02-03 00:00:00','11',18),(60,1,' MySQL数据 汇总和分组查询总结','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;一 汇总和分组数据&lt;/b&gt;&lt;/p&gt;&lt;pre&gt;SELECT 语句的执行顺序&lt;br&gt;from 子句指定数据源&lt;br&gt;where 子句基于指定的条件对记录进行筛选&lt;br&gt;group by 子句将数据划分为多个分组&lt;br&gt;使用聚合函数进行计算&lt;br&gt;使用having子句筛选分组&lt;br&gt;使用order by 子句对结果集进行排序&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;查询语句 ---&amp;gt; 结果集（多条数据） ---&amp;gt; 聚合函数&amp;nbsp; ----&amp;gt; 单行记录&lt;/p&gt;&lt;p&gt;1.常用的聚合函数：&lt;/p&gt;&lt;p&gt;sum()&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;数字&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 对指定列中的所有非空值求总和&lt;/p&gt;&lt;p&gt;avg()&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 数字&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 对指定列中的所有非空值求平均值&lt;/p&gt;&lt;p&gt;min()&amp;nbsp; &amp;nbsp; 数字，字符，datetime&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 返回指定列中的最小数字，最早的日期或者最小的字符串&lt;/p&gt;&lt;p&gt;max()&amp;nbsp; &amp;nbsp;数字，字符，datetime&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 返回指定列中的最大数字，最近的日期或者最大的字符集&lt;/p&gt;&lt;p&gt;count()&amp;nbsp; &amp;nbsp;任意基于行的数据类型&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;统计结果集合众全部记录行的数量&lt;/p&gt;&lt;p&gt;例：查询玩家表中一共有多少名玩家信息&lt;/p&gt;&lt;p&gt;select count (user_qq) from users&lt;/p&gt;&lt;p&gt;或&lt;/p&gt;&lt;p&gt;select count(*) from users&lt;/p&gt;&lt;p&gt;例：查询QQ号是12301的玩家游戏的总分数&lt;/p&gt;&lt;p&gt;select sum(score) as \'总分数\' from scores where user_qq=\'12301\'&lt;/p&gt;&lt;p&gt;例：查询QQ号是12302玩家的评价分数&lt;/p&gt;&lt;p&gt;select avg(score) as \'平均分数’ from scores where user_qq=\'12302\'&lt;/p&gt;&lt;p&gt;例：查询游戏编号的1的最高分数&lt;/p&gt;&lt;p&gt;select max(score) as \'最高分数\' from score where gno=1&lt;/p&gt;&lt;p&gt;例： 查询QQ号是12302的玩家的总分数，平均分数和最高分数&lt;/p&gt;&lt;p&gt;select sum(score) as \'总分\',avg(score) as \'平均分\',max(score) as \'最高分\' from scores where user_qq =\'12302\'&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. 使用GROUP BY分组&lt;/b&gt;&lt;/p&gt;&lt;p&gt;例：查询每个玩家的总分数，平均分数，最高分数&lt;/p&gt;&lt;p&gt;select sum(score) as \'总分\',avg(score) as \'平均分\',max(score) as \'最高分\' from scores group by user_qq&lt;/p&gt;&lt;p&gt;例： 查询每个玩家的平均分数，并显示玩家QQ号和平均分数&lt;/p&gt;&lt;p&gt;select user_qq, avg(score) as \'平均分数\' from scores group by user_qq&lt;/p&gt;&lt;p&gt;&lt;b&gt;3. 筛选分组结果&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; 在使用GROUP BY子句时，可用HAVING子句为分组统计进一步设置统计条件，HAVING子句与GROUP BY 子句的关系相当于WHERE子句与SELECT子句之间的关系&lt;/p&gt;&lt;p&gt;&amp;nbsp;与WHERE子句的区别是，在HAVING子句中是以聚合函数的统计结果为筛选条件。&lt;/p&gt;&lt;p&gt;&amp;nbsp;例：查询平均分数大于4000的玩家QQ号，总分数，平均分数&lt;/p&gt;&lt;p&gt;select user_qq, sum(score) as\'总分数\', avg(score) as \'平均分数\' from scores group by user_qq having avg(score) &amp;gt; 4000&lt;/p&gt;&lt;p&gt;例：查询所有用户的平均分数，和总分数，并按平均分数倒序排列&lt;/p&gt;&lt;p&gt;select user_qq,avg(score) as \'平均分数\' , sun(score) as \'总分数\' from scores group by user_qq orde by avg(score) desc&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;二 连接查询&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;1. 多表连接&lt;/p&gt;&lt;p&gt;例：查询分数信息，显示玩家昵称，游戏名称和分数&lt;/p&gt;&lt;p&gt;select user_name as \'昵称\', game as \'游戏名称\' , score as \'分数\' from users.user_qq = scores.user_qq and game.gno= scores.gno&lt;/p&gt;&lt;p&gt;&lt;u style=&quot;background-color: rgb(255, 255, 255); color: rgb(255, 0, 0);&quot;&gt;连接查询分为内连接和外连接两种&lt;/u&gt;&lt;/p&gt;&lt;p&gt;内连接特点：相连接的两张表地位平等&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;如果一张表中在另一张表中不存在对应数据，则不做连接&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;from 子句后面直接出现多个表名，这种连接方式即属于内连接，是隐式内连接&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;显示内连接格式：select col_list from table1[inner] join table2 on table1.col=table2.clo1&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;例：查询分数信息，显示玩家昵称，游戏名称和分数&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;select user_name as \'昵称\', g_name as \'游戏名称\', score as \'分数\' from games inner join scores on games.gno =scores.gno&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;inner join users on score.user_qq=user.user_qq&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;例：查询每个玩家的昵称，总分和平均分&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; select user_name as \'昵称\',sum(score) as \'总分\',avg(score) as \'平均分\' from users U inner join scores S on S.user_qq = U.user_qq group by&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;U.user_qq,user_name&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;例：查询平均分数大于3500的分数信息，显示玩家昵称，总分数，平均分数，并按照平均分数降序排列&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; select user_name as \'昵称\',sum(score) as \'总分\',avg(score) as \'平均分\' from users U inner join scores S on S.user_qq = U.user_qq group by&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;U.user_qq,user_name having avg(score)&amp;gt;3500 order by avg(score) desc&lt;/p&gt;&lt;p&gt;&lt;u style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;外连接分为左连接和右外连接&lt;/u&gt;&lt;/p&gt;&lt;p&gt;外连接特点：做连接的两个表地位不平等，其中有一张的基础表&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;基础表中的每条数据必须出现，即使另一张表中没有数据与之匹配，也要用NULL补齐&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;左外连接时左表是基础表，右表外连接时右表是基础表&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;语句中先出现的表为\'左表\', 后出现的表为\'右表\'&lt;/p&gt;&lt;p&gt;外连接格式： SELECT COL_LIST FROM TABLE1 LEFT/RIGHT[OUTER] JOIN TABLE2 ON TABLE1.COL=TABLE2.COL&lt;/p&gt;&lt;p&gt;&amp;nbsp;例：查询所有玩家关于5号游戏的分数信息&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp;select user_name as\'昵称\' gno as \'游戏编号\', score as \'分数\' from users U left join scores S on U.user_qq=S.user_qq and S.gno=5&lt;/p&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;',0,'2015-07-08 00:00:00','11',36),(61,1,'PHP定时器实现实现消息队列','','\r\n                                &lt;div&gt;php是服务器端脚本了并不像js那样有专业的settimeout函数来定时执行了，但只要浏览器不关闭各阶层是可以做到了，下面一起来看看。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;下面写个简单例子来讲解这个方法。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;&amp;lt;?php&amp;nbsp;&lt;br&gt;ignore_user_abort();//关闭浏览器仍然执行&lt;br&gt;set_time_limit(0);//让程序一直执行下去&lt;br&gt;$interval=3;//每隔一定时间运行&lt;br&gt;do{&lt;br&gt;&amp;nbsp; &amp;nbsp; $msg=date(&quot;Y-m-d H:i:s&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; file_put_contents(&quot;log.log&quot;,$msg,FILE_APPEND);//记录日志&lt;br&gt;&amp;nbsp; &amp;nbsp; sleep($interval);//等待时间，进行下一次操作。&lt;br&gt;}while(true);&lt;br&gt;?&amp;gt;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;需要说明的是：程序没有写结束判断语句，他会无限循环下去。当然如果想停止的话，可以重启apache，重启后就无效了。想再次进行定时执行，那么把这段代码再一次运行。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;上面简单例子可以说明这个原理。&lt;/div&gt;&lt;div&gt;那么针对上面的例子，我可以进行一下改良方案。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;你需要一个执行脚本的开关，你可以用外部文件引入的方法来实现，在while循环的时候，include开关变量即可。那么就可以这样实现：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;建立外部引入变量文件 switch.php 内容如下：&lt;/div&gt;&lt;pre&gt;&lt;br&gt;&amp;lt;?php&lt;br&gt;return 1;//1执行脚本 0退出执行脚本&lt;br&gt;?&amp;gt;&lt;br&gt;改良脚本如下：&lt;br&gt;&amp;lt;?php&lt;br&gt;&amp;nbsp; &amp;nbsp; ignore_user_abort();//关闭浏览器后，继续执行php代码&lt;br&gt;&amp;nbsp; &amp;nbsp; set_time_limit(0);//程序执行时间无限制&lt;br&gt;&amp;nbsp; &amp;nbsp; $sleep_time = 5;//多长时间执行一次&lt;br&gt;&amp;nbsp; &amp;nbsp; $switch = include \'switch.php\';&lt;br&gt;&amp;nbsp; &amp;nbsp; while($switch){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; $switch = include \'switch.php\';&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; $msg=date(&quot;Y-m-d H:i:s&quot;).$switch;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; file_put_contents(&quot;log.log&quot;,$msg,FILE_APPEND);//记录日志&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; sleep($sleep_time);//等待时间，进行下一次操作。&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; exit();&lt;br&gt;&amp;nbsp;&lt;br&gt;?&amp;gt;&lt;br&gt;&lt;/pre&gt;&lt;div&gt;&lt;div&gt;【上面这种方式，稳定性不好，执行脚本会由于一些不确定性的终止】&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;当然我们也可以使用系统的定时执行php脚本了，下面看个linux的例子。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在Crontab中使用PHP执行脚本&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;就像在Crontab中调用普通的shell脚本一样（具体Crontab用法），使用PHP程序来调用PHP脚本。&amp;nbsp;&lt;/div&gt;&lt;div&gt;每一小时执行myscript.php如下：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;# crontab -e&amp;nbsp;&lt;/div&gt;&lt;div&gt;00 * * * * /usr/local/bin/php /home/john/myscript.php&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;/usr/local/bin/php为PHP程序的路径。&lt;/div&gt;&lt;/div&gt;\r\n                                                                                        ',0,'2015-02-03 00:00:00','23',15),(62,1,'什么是程序的原子性','','&lt;div&gt;&lt;b&gt;程序的原子性指&lt;/b&gt;：整个程序中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;原子性操作：原子性在一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉。即使在多个线程一起执行的时候，也是一个线程一个线程的依次执行操作，不会被其它线程所干扰。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;扩展资料：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;redis的原子性：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis所有单个命令的执行都是原子性的，这与它的单线程机制有关；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis命令的原子性使得我们不用考虑并发问题，可以方便的利用原子性自增操作 实现简单计数器功能;&lt;/div&gt;\r\n                                                            ',0,'2015-02-12 00:00:00','33',41),(63,1,'redis实现高并发下的抢购/秒杀功能','','\n                                &lt;p&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; color: rgb(68, 68, 68); font-family: tahoma, arial, sans-serif; font-size: 12px; line-height: 1.5 !important;&quot;&gt;抢购/秒杀是如今很常见的一个应用场景，那么高并发竞争下如何解决超抢(或超卖库存不足为负数的问题)呢？&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; color: rgb(68, 68, 68); font-family: tahoma, arial, sans-serif; font-size: 12px; line-height: 1.5 !important;&quot;&gt;常规写法：&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; color: rgb(68, 68, 68); font-family: tahoma, arial, sans-serif; font-size: 12px; line-height: 1.5 !important;&quot;&gt;查询出对应商品的库存，看是否大于0，然后执行生成订单等操作，但是在判断库存是否大于0处，如果在高并发下就会有问题，导致库存量出现负数，所以在高并发下只使用mysql来做处理的话，是无法保证商品不会出现超卖的。&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; color: rgb(68, 68, 68); font-family: tahoma, arial, sans-serif; font-size: 12px; line-height: 1.5 !important;&quot;&gt;这里我就只谈redis的解决方案吧...&lt;br style=&quot;margin: 0px; padding: 0px;&quot;&gt;我们先来看以下代码（这里我以laravel为例吧）是否能正确解决超抢/卖的问题：&lt;/p&gt;&lt;pre style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; line-height: 1.5 !important;&quot;&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;&amp;lt;?php&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;&amp;nbsp;$num = 10;&amp;nbsp; &amp;nbsp;//系统库存量&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;&amp;nbsp;$user_id =&amp;nbsp; \\Session::get(\'user_id\');//当前抢购用户id&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;&amp;nbsp;$len = \\Redis::llen(\'order:1\');&amp;nbsp; //检查库存，order:1 定义为健名&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;&amp;nbsp;if($len &amp;gt;= $num)&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;&amp;nbsp;　　return \'已经抢光了哦\';&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;$result = \\Redis::lpush(\'order:1\',$user_id);&amp;nbsp; //把抢到的用户存入到列表中&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;if($result)&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;　　return \'恭喜您!抢到了哦\';&lt;/span&gt;&lt;/font&gt;&lt;/pre&gt;&lt;span style=&quot;color: rgb(68, 68, 68); font-family: tahoma, arial, sans-serif; font-size: 12px;&quot;&gt;如果代码正常运行，按照预期理解的是列表order:1中最多只能存储10个用户的id，因为库存只有10个。&lt;/span&gt;&lt;br style=&quot;margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-family: tahoma, arial, sans-serif; font-size: 12px;&quot;&gt;&lt;span style=&quot;color: rgb(68, 68, 68); font-family: tahoma, arial, sans-serif; font-size: 12px;&quot;&gt;然而，但是,在使用jmeter工具模拟多用户并发请求时，最后发现order:1中总是超过5个用户，也就是出现了“超抢/超卖”。&lt;/span&gt;&lt;br style=&quot;margin: 0px; padding: 0px; color: rgb(68, 68, 68); font-family: tahoma, arial, sans-serif; font-size: 12px;&quot;&gt;&lt;span style=&quot;color: rgb(68, 68, 68); font-family: tahoma, arial, sans-serif; font-size: 12px;&quot;&gt;分析问题就出在这一段代码：&lt;/span&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;&amp;nbsp;$len = \\Redis::llen(\'order:1\');&amp;nbsp; //检查库存，order:1 定义为健名&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;&amp;nbsp;if($len &amp;gt;= $num)&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;&amp;nbsp;　　return \'已经抢光了哦\';&lt;/span&gt;&lt;/font&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;在抢购进行到一定程度，假如现在已经有9个人抢购成功，又来了3个用户同时抢购，这时if条件将会被绕过(llen命令并不是原子性操作，也就是说多个用户可以同时查询到同样的结果，条件同时被满足了),这三个用户都能抢购成功。而实际上只剩下一件库存可以抢了。&lt;div&gt;在高并发下，很多看似不大可能是问题的，都成了实际产生的问题了。要解决“超抢/超卖”的问题，核心在于保证检查库存时的操作是依次执行的，再形象的说就是把“多线程”转成“单线程”。即使有很多用户同时到达，也是一个个检查并给与抢购资格，一旦库存抢尽，后面的用户就无法继续了。&lt;/div&gt;&lt;div&gt;我们需要使用redis的原子操作来实现这个“单线程”。首先我们把库存存在goods_store:1这个列表中，假设有10件库存，就往列表中push10个1进去，当然这个1并没有实际意义，仅仅只是代表一件库存。抢购开始后，每到来一个用户，就从goods_store:1中pop一个数，表示用户抢购成功。当列表为空时，表示已经被抢光了。因为列表的pop操作是原子的，即使有很多用户同时到达，也是依次执行的。抢购的示例代码如下：&lt;/div&gt;&lt;div&gt;比如这里我先把库存(可用库存,这里我强调下,一般都是商品详情页抢购,后来者进来看到的库存可能不再是后台系统配置的10个库存数了)放入redis队列：&lt;/div&gt;&lt;div&gt;&lt;pre&gt; $num=10; //库存&lt;br&gt;&amp;nbsp;for($i=0;$i&amp;lt;$num;$i++)&lt;br&gt;&amp;nbsp;　　\\Redis::lpush(\'goods_store\',1);//往goods_store列表中,未抢购之前这里应该是默认滴push10个库存数了&lt;/pre&gt;&lt;div&gt;上面代码可以在抢购之前把库存先入队列。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(68, 68, 68); font-family: tahoma, arial, sans-serif; font-size: 12px;&quot;&gt;抢购时间到了：（大量用户进入请求下面代码，）&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;&quot;&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;/* 模拟抢购操作,抢购前判断redis队列库存量 */&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;&amp;nbsp;$count=\\Redis::lpop(\'goods_store:1\');//lpop是移除并返回列表的第一个元素。&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;&amp;nbsp;if(!$count)&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;&amp;nbsp; &amp;nbsp; return \'已经抢光了哦\';&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;&amp;nbsp;/* 下面处理抢购成功流程 */&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#444444&quot; face=&quot;tahoma, arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;\\DB::table(\'goods\')-&amp;gt;decrement(\'num\', 1);//减少num库存字段，同时在订单表里生成订单数据&lt;/span&gt;&lt;/font&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(68, 68, 68); font-family: tahoma, arial, sans-serif; font-size: 12px;&quot;&gt;为了检测实际效果，我使用jmeter工具模拟100、200、1000个用户并发进行抢购，经过大量的测试，最终抢购成功的用户始终为10，没有出现“超抢/超卖”。&lt;/span&gt;&lt;span style=&quot;color: rgb(68, 68, 68); font-family: tahoma, arial, sans-serif; font-size: 12px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;                            ',0,'2015-06-16 00:00:00','16',49),(64,1,'redis如何解决缓存雪崩？','','&lt;p&gt;&amp;nbsp; 为什么要用缓存(Redis)：&lt;/p&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190114/684e7094731cee652154274767908c82.png&quot; data-filename=&quot;img&quot; style=&quot;width: 634px;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;现在有个问题，如果我们的缓存挂掉了，这意味着我们的全部请求都跑去数据库了。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190114/8fa09e3b2dec064b7cd3e4e4056e8114.png&quot; data-filename=&quot;img&quot; style=&quot;width: 615px;&quot;&gt;&lt;/p&gt;&lt;p&gt;我们都知道Redis不可能把所有的数据都缓存起来(内存昂贵且有限)，所以Redis需要对数据设置过期时间，并采用的是惰性删除+定期删除两种策略对过期键删除。&lt;/p&gt;&lt;p&gt;如果缓存数据设置的过期时间是相同的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存同时失效，全部请求到数据库中。&lt;/p&gt;&lt;p&gt;&lt;b&gt;这就是缓存雪崩：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;1.Redis挂掉了，请求全部走数据库。&lt;/p&gt;&lt;p&gt;2.对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。&lt;/p&gt;&lt;p&gt;缓存雪崩如果发生了，很可能就把我们的数据库搞垮，导致整个服务瘫痪！&lt;/p&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;如何解决缓存雪崩？&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;&quot;&gt;（1）、对于“对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。”这种情况，非常好解决：&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;u&gt;解决方法：在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。&lt;/u&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;（2）、对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;事发前：实现Redis的高可用(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。&lt;/div&gt;&lt;div style=&quot;&quot;&gt;事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)&lt;/div&gt;&lt;div style=&quot;&quot;&gt;事发后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。&lt;/div&gt;&lt;div style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/div&gt;原文地址：&lt;a href=&quot;https://juejin.im/post/5c3c1df2e51d45207f54b189&quot; target=&quot;_blank&quot;&gt;https://juejin.im/post/5c3c1df2e51d45207f54b189&lt;/a&gt;&lt;/div&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;',0,'2016-06-08 00:00:00','16',64),(65,1,'redis如何解决缓存穿透','','&lt;div&gt;&lt;b&gt;什么是缓存穿透&lt;/b&gt;&lt;/div&gt;&lt;div&gt;比如，我们有一张数据库表，ID都是从1开始的(正数)：&lt;/div&gt;&lt;div&gt;但是可能有黑客想把我的数据库搞垮，每次请求的ID都是负数。这会导致我的缓存就没用了，请求全部都找数据库去了，但数据库也没有这个值啊，所以每次都返回空出去。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;u&gt;缓存穿透是指查询一个一定不存在的数据。由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。&lt;/u&gt;&lt;/div&gt;&lt;div&gt;&lt;u&gt;&lt;br&gt;&lt;/u&gt;&lt;img src=&quot;/upload/article/20190114/127b405c9cf2fa11d3bffe365cf835b5.png&quot; data-filename=&quot;img&quot; style=&quot;width: 381px; height: 377.19px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;这就是缓存穿透：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;请求的数据在缓存大量不命中，导致请求走数据库。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;缓存穿透如果发生了，也可能把我们的数据库搞垮，导致整个服务瘫痪！&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;解决缓存穿透也有两种方案：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1.由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截，不合法就不让这个请求到数据库层！&lt;/div&gt;&lt;div&gt;2.当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。这种情况我们一般会将空对象设置一个较短的过期时间。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;\r\n                                                            ',0,'2016-06-08 00:00:00','16',58),(66,1,'如何保证redis缓存与数据库mysql双写时一致的问题？','','\r\n                                \r\n                                &lt;div&gt;&lt;b&gt;一、对于读操作，流程是这样的&lt;/b&gt;&lt;/div&gt;&lt;div&gt;讲缓存穿透的时候也提到了：如果从数据库查不到数据则不写入缓存。&lt;/div&gt;&lt;div&gt;一般我们对读操作的时候有这么一个固定的套路：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1.如果我们的数据在缓存里边有，那么就直接取缓存的。&lt;/div&gt;&lt;div&gt;2.如果缓存里没有我们想要的数据，我们会先去查询数据库，然后将数据库查出来的数据写到缓存中。&lt;/div&gt;&lt;div&gt;3.最后将数据返回给请求&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;二、什么是缓存与数据库双写一致问题？&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。但是，当我们要更新时候呢？各种情况很可能就造成数据库和缓存的数据不一致了。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;这里不一致指的是：数据库的数据跟缓存的数据不一致&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190114/945cc1b810913ec5bde12c200ad73ea8.png&quot; data-filename=&quot;img&quot; style=&quot;width: 557px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;从理论上说，只要我们设置了键的过期时间，我们就能保证缓存和数据库的数据最终是一致的。因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。&lt;/div&gt;&lt;div&gt;除了设置过期时间，我们还需要做更多的措施来尽量避免数据库与缓存处于不一致的情况发生。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;1.1对于更新操作&lt;/b&gt;&lt;/div&gt;&lt;div&gt;一般来说，执行更新操作时，我们会有两种选择：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;先操作数据库，再操作缓存&lt;/li&gt;&lt;li&gt;先操作缓存，再操作数据库&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;首先，要明确的是，无论我们选择哪个，我们都希望这两个操作要么同时成功，要么同时失败。所以，这会演变成一个分布式事务的问题。&lt;/div&gt;&lt;div&gt;所以，如果原子性被破坏了，可能会有以下的情况：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;操作数据库成功了，操作缓存失败了。&lt;/li&gt;&lt;li&gt;操作缓存成功了，操作数据库失败了。&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;u&gt;如果第一步已经失败了，我们直接返回Exception出去就好了，第二步根本不会执行。&lt;/u&gt;&lt;/div&gt;&lt;div&gt;&lt;u&gt;&lt;br&gt;&lt;/u&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 15px;&quot;&gt;下面我们具体来分析一下吧。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;-apple-system, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 15px;&quot;&gt;&lt;b&gt;1.1.1操作缓存&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;-apple-system, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 15px;&quot;&gt;操作缓存也有两种方案：&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;&lt;font color=&quot;#333333&quot; face=&quot;-apple-system, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 15px;&quot;&gt;更新缓存&lt;/span&gt;&lt;/font&gt;&lt;/li&gt;&lt;li&gt;&lt;font color=&quot;#333333&quot; face=&quot;-apple-system, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 15px;&quot;&gt;删除缓存&lt;/span&gt;&lt;/font&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;-apple-system, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 15px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;-apple-system, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 15px;&quot;&gt;一般我们都是采取&lt;b&gt;删除缓存&lt;/b&gt;策略的，原因如下：&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;&lt;font color=&quot;#333333&quot; face=&quot;-apple-system, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 15px;&quot;&gt;高并发环境下，无论是先操作数据库还是后操作数据库而言，如果加上更新缓存，那就更加容易导致数据库与缓存数据不一致问题。(删除缓存直接和简单很多)&lt;/span&gt;&lt;/font&gt;&lt;/li&gt;&lt;li&gt;&lt;font color=&quot;#333333&quot; face=&quot;-apple-system, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 15px;&quot;&gt;如果每次更新了数据库，都要更新缓存【这里指的是频繁更新的场景，这会耗费一定的性能】，倒不如直接删除掉。等再次读取时，缓存里没有，那我到数据库找，在数据库找到再写到缓存里边(体现懒加载)&lt;/span&gt;&lt;/font&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;-apple-system, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 15px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;-apple-system, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 15px;&quot;&gt;基于这两点，对于缓存在更新时而言，都是建议执行删除操作！&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 15px;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;1.1.2先更新数据库，再删除缓存&lt;/b&gt;&lt;/div&gt;&lt;div&gt;正常的情况是这样的：&lt;/div&gt;&lt;ul&gt;&lt;li&gt;先操作数据库，成功；&lt;/li&gt;&lt;li&gt;再删除缓存，也成功；&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果原子性被破坏了：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;第一步成功(操作数据库)，第二步失败(删除缓存)，会导致数据库里是新数据，而缓存里是旧数据。&lt;/li&gt;&lt;li&gt;如果第一步(操作数据库)就失败了，我们可以直接返回错误(Exception)，不会出现数据不一致。&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果在高并发的场景下，出现数据库与缓存数据不一致的概率特别低，也不是没有：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;缓存刚好失效&lt;/div&gt;&lt;div&gt;线程A查询数据库，得一个旧值&lt;/div&gt;&lt;div&gt;线程B将新值写入数据库&lt;/div&gt;&lt;div&gt;线程B删除缓存&lt;/div&gt;&lt;div&gt;线程A将查到的旧值写入缓存&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;要达成上述情况，还是说一句概率特别低：&lt;/div&gt;&lt;div&gt;&lt;u&gt;因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。&lt;/u&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;删除缓存失败的解决思路：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;将需要删除的key发送到消息队列中&lt;/li&gt;&lt;li&gt;自己消费消息，获得需要删除的key&lt;/li&gt;&lt;li&gt;不断重试删除操作，直到成功&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;1.1.3先删除缓存，再更新数据库&lt;/b&gt;&lt;/p&gt;&lt;p&gt;正常情况是这样的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;先删除缓存，成功；&lt;/li&gt;&lt;li&gt;再更新数据库，也成功；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果原子性被破坏了：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一步成功(删除缓存)，第二步失败(更新数据库)，数据库和缓存的数据还是一致的。&lt;/li&gt;&lt;li&gt;如果第一步(删除缓存)就失败了，我们可以直接返回错误(Exception)，数据库和缓存的数据还是一致的。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;看起来是很美好，但是我们在并发场景下分析一下，就知道还是有问题的了：&lt;/p&gt;&lt;p&gt;线程A删除了缓存&lt;/p&gt;&lt;p&gt;线程B查询，发现缓存已不存在&lt;/p&gt;&lt;p&gt;线程B去数据库查询得到旧值&lt;/p&gt;&lt;p&gt;线程B将旧值写入缓存&lt;/p&gt;&lt;p&gt;线程A将新值写入数据库&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;所以也会导致数据库和缓存不一致的问题。&lt;/p&gt;&lt;p&gt;&lt;b&gt;并发下解决数据库与缓存不一致的思路：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;将删除缓存、修改数据库、读取缓存等的操作积压到队列里边，实现串行化。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190114/560c48d65ab8d51f1f10e2deafc6a3b3.png&quot; data-filename=&quot;img&quot; style=&quot;width: 617px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;对比两种策略&lt;/b&gt;&lt;/div&gt;&lt;div&gt;我们可以发现，两种策略各自有优缺点：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;先删除缓存，再更新数据库&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;在高并发下表现不如意，在原子性被破坏时表现优异&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;先更新数据库，再删除缓存(Cache Aside Pattern设计模式)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;在高并发下表现优异，在原子性被破坏时表现不如意&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div&gt;原文地址：&lt;a href=&quot;https://juejin.im/post/5c3c1df2e51d45207f54b189&quot; target=&quot;_blank&quot;&gt;https://juejin.im/post/5c3c1df2e51d45207f54b189&lt;/a&gt;&lt;/div&gt;\r\n                                                                                                                    ',0,'2016-06-08 00:00:00','11,16',39),(67,1,'float元素浮动后高度不一致导致错位的解决办方法','','&lt;div&gt;当N个元素浮动后，会导致错位的问题。一般给元素一个固定的height就没有这个现象。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;但是当高度不一致时，就需要想别的办法来解决了：&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、给父元素定义font-size:0; 浮动子元素定义需要的font-size， 再定义display:inline-block;vertical-align:top;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;ul{&amp;nbsp;&lt;br&gt;margin:0;&amp;nbsp;&lt;br&gt;padding:0;&amp;nbsp;&lt;br&gt;list-style-type:none;&amp;nbsp;&lt;br&gt;font-size:0;&amp;nbsp;&lt;br&gt;}&amp;nbsp;&lt;br&gt;ul li{&amp;nbsp;&lt;br&gt;width:160px;&amp;nbsp;&lt;br&gt;display:inline-block;&amp;nbsp;&lt;br&gt;vertical-align:top;&amp;nbsp;&lt;br&gt;font-size:12px;&amp;nbsp;&lt;br&gt;}&amp;nbsp;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;2、给换行后的第一个li添加clear:left 如： （比如每两个li换一行）&lt;/p&gt;&lt;pre&gt;ul li{float:left;width:160px;}&amp;nbsp;&lt;br&gt;.c{clear:left;}&amp;nbsp;&lt;br&gt;&amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;&amp;nbsp;&lt;br&gt;&amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;&amp;nbsp;&lt;br&gt;&amp;lt;li class=&quot;c&quot;&amp;gt;clear&amp;lt;/li&amp;gt;&lt;br&gt;&amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;&amp;nbsp;&lt;br&gt;&amp;lt;li&amp;gt;5&amp;lt;/li&amp;gt;&amp;nbsp;&lt;br&gt;&amp;lt;li class=&quot;c&quot;&amp;gt;clear&amp;lt;/li&amp;gt;&lt;br&gt;&amp;lt;li&amp;gt;6&amp;lt;/li&amp;gt;&amp;nbsp;&lt;/pre&gt;&lt;p&gt;可以通过js取余判断偶数，添加&amp;lt;li class=&quot;c&quot;&amp;gt;clear&amp;lt;/li&amp;gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;\r\n                                                            ',0,'2019-01-15 00:00:00','21',68),(68,1,'redis过期策略和持久化','','\r\n                                \r\n                                \r\n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;1.1键的过期时间\r\n&lt;/b&gt;&lt;br class=&quot;Apple-interchange-newline&quot;&gt;&lt;/div&gt;&lt;div&gt;Redis是基于内存，内存是比较昂贵的，容量肯定比不上硬盘的。就我们现在一台普通的机子，可能就8G内存，但硬盘随随便便都1T了。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;因为我们的内存是有限的。所以我们会干掉不常用的数据，保留常用的数据。这就需要我们设置一下键的过期(生存)时间了。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;设置键的生存时间可以通过EXPIRE或者PEXPIRE命令。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;设置键的过期时间可以通过EXPIREAT或者PEXPIREAT命令。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;其实&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;EXPIRE&lt;/span&gt;、&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;PEXPIRE&lt;/span&gt;、&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;EXPIREAT&lt;/span&gt;这三个命令都是通过&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;PEXPIREAT&lt;/span&gt;命令来实现的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;我们在redisDb结构体中还发现了dict *expires;属性，存放所有键过期的时间。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;举个例子基本就可以理解了：&lt;/div&gt;&lt;pre&gt;redis &amp;gt; PEXPIREAT message 1391234400000&lt;br&gt;(integer) 1&lt;/pre&gt;&lt;p&gt;设置了message键的过期时间为1391234400000&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190115/d7f8fe6cf03cd4d29734f61b3aba9293.png&quot; data-filename=&quot;img&quot; style=&quot;width: 500px;&quot;&gt;&lt;/p&gt;&lt;p&gt;既然有设置过期(生存)时间的命令，那肯定也有移除过期时间，查看剩余生存时间的命令了：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;PERSIST(移除过期时间)&lt;/li&gt;&lt;li&gt;TTL(Time To Live)返回剩余生存时间，以秒为单位&lt;/li&gt;&lt;li&gt;PTTL以毫秒为单位返回键的剩余生存时间&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;1.2.过期策略&lt;/span&gt;&lt;/p&gt;&lt;p&gt;上面我们已经能够了解到：过期键是保存在哈希表中了。那这些过期键到了过期的时间，就会立马被删除掉吗？？&lt;/p&gt;&lt;p&gt;要回答上面的问题，需要我们了解一下删除策略的知识，删除策略可分为三种&lt;/p&gt;&lt;ul&gt;&lt;li&gt;定时删除(对内存友好，对CPU不友好)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;到时间点上就把所有过期的键删除了。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;惰性删除(对CPU极度友好，对内存极度不友好)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 每次从键空间取键的时候，判断一下该键是否过期了，如果过期了就删除。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;定期删除(折中)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;每隔一段时间去删除过期键，限制删除的执行时长和频率。&lt;/p&gt;&lt;p&gt;Redis采用的是惰性删除+定期删除两种策略，所以说，在Redis里边如果过期键到了过期的时间了，未必被立马删除的！&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.3内存淘汰机制&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果定期删除漏掉了很多过期key，也没及时去查(没走惰性删除)，大量过期key堆积在内存里，导致redis内存块耗尽了，咋整？&lt;/p&gt;&lt;p&gt;我们可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。&lt;/p&gt;&lt;p&gt;Redis的内存淘汰机制有以下几种：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190115/1edae22b6bcd8037bd5b8ade27bcb289.png&quot; data-filename=&quot;img&quot; style=&quot;width: 500px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一般场景：&lt;/p&gt;&lt;p&gt;&lt;u&gt;使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用allkeys-lru淘汰策略，将最近最少使用的数据淘汰&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.Redis持久化&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Redis是基于内存的，如果不想办法将数据保存在硬盘上，一旦Redis重启(退出/故障)，内存的数据将会全部丢失。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&amp;nbsp; &amp;nbsp;我们肯定不想Redis里头的数据由于某些故障全部丢失(导致所有请求都走MySQL)，即便发生了故障也希望可以将Redis原有的数据恢复过来，这就是持久化的作用。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Redis提供了两种不同的持久化方法来讲数据存储到硬盘里边：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&amp;nbsp; &amp;nbsp;RDB(基于快照)，将某一时刻的所有数据保存到一个RDB文件中。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&amp;nbsp; &amp;nbsp;AOF(append-only-file)，当Redis服务器执行写命令的时候，将执行的写命令保存到AOF文件中。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;2.1.RDB(快照持久化)&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp;RDB持久化可以手动执行，也可以根据服务器配置定期执行。RDB持久化所生成的RDB文件是一个经过压缩的二进制文件，Redis可以通过这个文件还原数据库的数据。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190116/4058dfe9b76a68bdea09d238068e8343.png&quot; data-filename=&quot;img&quot; style=&quot;width: 671px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;有两个命令可以生成RDB文件：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;SAVE会阻塞Redis服务器进程，服务器不能接收任何请求，直到RDB文件创建完毕为止。&lt;/li&gt;&lt;li&gt;BGSAVE创建出一个子进程，由子进程来负责创建RDB文件，服务器进程可以继续接收请求。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Redis服务器在启动的时候，如果发现有RDB文件，就会自动载入RDB文件(不需要人工干预)&lt;/p&gt;&lt;p&gt;服务器在载入RDB文件期间，会处于阻塞状态，直到载入工作完成。&lt;/p&gt;&lt;p&gt;除了手动调用SAVE或者BGSAVE命令生成RDB文件之外，我们可以使用配置的方式来定期执行：&lt;/p&gt;&lt;p&gt;在默认的配置下，如果以下的条件被触发，就会执行BGSAVE命令&lt;/p&gt;&lt;pre&gt;save 900 1&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; #在900秒(15分钟)之后，至少有1个key发生变化，&lt;br&gt;save 300 10&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; #在300秒(5分钟)之后，至少有10个key发生变化&lt;br&gt;save 60 10000&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; #在60秒(1分钟)之后，至少有10000个key发生变化&lt;/pre&gt;&lt;p&gt;总结：通过手动调用SAVE或者BGSAVE命令或者配置条件触发，将数据库某一时刻的数据快照，生成RDB文件实现持久化。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2.AOF(文件追加)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;上面已经介绍了RDB持久化是通过将某一时刻数据库的数据“快照”来实现的，下面我们来看看AOF是怎么实现的。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;AOF是通过保存Redis服务器所执行的写命令来记录数据库的数据的。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190116/91069a0af8e0b7e7f733a4a4163d9507.png&quot; data-filename=&quot;img&quot; style=&quot;width: 621px;&quot;&gt;&lt;/p&gt;&lt;p&gt;AOF持久化功能的实现可以分为3个步骤：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;命令追加：命令写入aof_buf缓冲区&lt;/li&gt;&lt;li&gt;文件写入：调用flushAppendOnlyFile函数，将aof_buf缓冲区写入AOF文件中&lt;/li&gt;&lt;li&gt;文件同步：考虑是否将内存缓冲区的数据真正写入到硬盘（由存缓冲区内容是否已满决定）&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190116/edf85ad81b04e03b969f238026016b62.png&quot; data-filename=&quot;img&quot; style=&quot;width: 667px;&quot;&gt;&lt;/p&gt;&lt;p&gt;flushAppendOnlyFile函数的行为由服务器配置的appendfsyn选项来决定的：&lt;/p&gt;&lt;pre&gt;&amp;nbsp; &amp;nbsp; appendfsync always&amp;nbsp; &amp;nbsp; &amp;nbsp;# 每次有数据修改发生时都会写入AOF文件。&lt;br&gt;&amp;nbsp; &amp;nbsp; appendfsync everysec&amp;nbsp; &amp;nbsp;# 每秒钟同步一次，该策略为AOF的默认策略。&lt;br&gt;&amp;nbsp; &amp;nbsp; appendfsync no&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;# 从不同步。高效但是数据不会被持久化。&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;总结：服务器将写命令保存在AOF文件然后同步到硬盘里，首先写命令会进入aof_buf缓冲区，然后通过调用flushAppendOnlyFile函数，将缓冲区内容写入AOF文件中（此时的AOF文件还在缓冲区）；等缓冲区内容满了以后，才会将AOF文件同步到硬盘里。&lt;/p&gt;&lt;p&gt;下面来看一下AOF是如何载入与数据还原的：&lt;/p&gt;&lt;p&gt;创建一个伪客户端(本地)来执行AOF的命令，直到AOF命令被全部执行完毕。&lt;/p&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190116/02d2f111b949c6f2b2af8a0086dc3b20.png&quot; data-filename=&quot;img&quot; style=&quot;width: 609px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;2.3RDB和AOF对过期键的策略&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;RDB持久化对过期键的策略：&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;执行SAVE或者BGSAVE命令创建出的RDB文件，程序会对数据库中的过期键检查，已过期的键不会保存在RDB文件中。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;载入RDB文件时，程序同样会对RDB文件中的键进行检查，过期的键会被忽略。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;AOF持久化对过期键的策略：&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;如果数据库的键已过期，但还没被惰性/定期删除，AOF文件不会因为这个过期键产生任何影响(也就说会保留)，当过期的键被删除了以后，会追加一条DEL命令来显示记录该键被删除了&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;重写AOF文件时，程序会对RDB文件中的键进行检查，过期的键会被忽略。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;复制模式：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;主服务器来控制从服务器统一删除过期键(保证主从服务器数据的一致性)&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;2.4RDB和AOF用哪个？&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;RDB和AOF并不互斥，它俩可以同时使用。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;RDB的优点：载入时恢复数据快、文件体积小。&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;RDB的缺点：会一定程度上丢失数据(因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。)&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;AOF的优点：丢失数据少(默认配置只丢失一秒的数据)。&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;AOF的缺点：恢复数据相对较慢，文件体积大&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果Redis服务器同时开启了RDB和AOF持久化，服务器会优先使用AOF文件来还原数据(因为AOF更新频率比RDB更新频率要高，还原的数据更完善)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;可能涉及到RDB和AOF的配置：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;redis持久化，两种方式&lt;br&gt;1、rdb快照方式&lt;br&gt;2、aof日志方式&lt;br&gt;----------rdb快照------------&lt;br&gt;save 900 1&lt;br&gt;save 300 10&lt;br&gt;save 60 10000&lt;br&gt;stop-writes-on-bgsave-error yes&lt;br&gt;rdbcompression yes&lt;br&gt;rdbchecksum yes&lt;br&gt;dbfilename dump.rdb&lt;br&gt;dir /var/rdb/&lt;br&gt;-----------Aof的配置-----------&lt;br&gt;appendonly no # 是否打开 aof日志功能&lt;br&gt;appendfsync always #每一个命令都立即同步到aof，安全速度慢&lt;br&gt;appendfsync everysec&lt;br&gt;appendfsync no 写入工作交给操作系统，由操作系统判断缓冲区大小，统一写入到aof&amp;nbsp; 同步频率低，速度快&lt;br&gt;&lt;br&gt;no-appendfsync-on-rewrite yes 正在导出rdb快照的时候不要写aof&lt;br&gt;auto-aof-rewrite-percentage 100&lt;br&gt;auto-aof-rewrite-min-size 64mb&amp;nbsp;&lt;br&gt;&lt;br&gt;./bin/redis-benchmark -n 20000&lt;/pre&gt;&lt;p&gt;原文地址：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;amp;mid=2247484386&amp;amp;idx=1&amp;amp;sn=323ddc84dc851a975530090fcd6e2326&amp;amp;chksm=ebd742e3dca0cbf52bc65d430447e639d81cc13e0ac34613edf464dae3950b10e2e1df74dcc5&amp;amp;token=1834317504&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;参考原文&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;\r\n                                                                                                                                                ',0,'2016-06-09 00:00:00','16',59),(69,1,'jquery获取某个元素距离其父级的偏移量','','&lt;pre&gt;&amp;lt;ul style=&quot;position: relative&quot;&amp;gt; &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;&lt;br&gt;&amp;nbsp; &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;&lt;br&gt;&amp;nbsp; &amp;lt;li id=&quot;flag&quot;&amp;gt;&amp;lt;/li&amp;gt;&lt;br&gt;&amp;nbsp; &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;&lt;br&gt;&amp;lt;/ul&amp;gt;&lt;br&gt;&amp;lt;script&amp;gt;&lt;br&gt;&amp;nbsp; $(function(){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var flag=$(&quot;#flag&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; alert(flag.position().top);//距离UI的上边距 50&lt;br&gt;&amp;nbsp; &amp;nbsp; alert(flag.position().top+flag.height());//得到75，需加上自身高度&lt;br&gt;&amp;nbsp; });&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;lt;/script&amp;gt;&lt;/pre&gt;\r\n                                                            ',0,'2019-01-21 00:00:00','22',61),(70,1,'js如何通过正则表达式获取DOM节点中的图片地址','','&lt;div&gt;思路：&lt;/div&gt;&lt;div&gt;1.匹配出图片img标签（即匹配出所有图片），过滤其他不需要的字符&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.从匹配出来的结果（img标签中）循环匹配出图片地址（即src属性）&lt;/div&gt;&lt;pre&gt;var str = &quot;this is test string &amp;lt;img src=\\&quot;http:yourweb.com/test.jpg\\&quot; width=\'50\' &amp;gt; 123 and the end &amp;lt;img src=\\&quot;所有地址也能匹配.jpg\\&quot; /&amp;gt; 33! &amp;lt;img src=\\&quot;/uploads/attached/image/20120426/20120426225658_92565.png\\&quot; alt=\\&quot;\\&quot; /&amp;gt;&quot;&lt;br&gt;//匹配所有img标签&lt;br&gt;var imgReg = /&amp;lt;img.*?(?:&amp;gt;|\\/&amp;gt;)/gi;&lt;br&gt;//匹配img标签中的src属性&lt;br&gt;var srcReg = /src=[\\\'\\&quot;]?([^\\\'\\&quot;]*)[\\\'\\&quot;]?/i;&lt;br&gt;var imgList = str.match(imgReg);&lt;br&gt;for (var i = 0; i &amp;lt; imgList.length; i++) {&lt;br&gt;&amp;nbsp; &amp;nbsp;var src = imgList[i].match(srcReg);&lt;br&gt;&amp;nbsp; &amp;nbsp;//获取图片地址&lt;br&gt;&amp;nbsp; &amp;nbsp;console.log(\'已匹配的图片地址src：\'+src[1]);&lt;br&gt;}&lt;/pre&gt;\r\n                                                            ',0,'2015-06-09 00:00:00','22',22),(71,1,'js根据图片地址计算图片真实像素大小','','&lt;pre&gt;1.获取图片地址链接&amp;nbsp;&lt;br&gt;&amp;nbsp; var img_url;&lt;br&gt;2.实例化一个Image对象&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; var img = new Image();&lt;br&gt;3.给对象赋值src&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; img.src = img_url;&lt;br&gt;获取图片真实的宽高&lt;br&gt;&amp;nbsp; img.width&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; img.height&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\r\n                                                            ',0,'2015-06-12 00:00:00','22',52),(72,1,'js等比例缩放图片大小计算公式','','&lt;p&gt;有这样的一个需求就是使div里显示的图片显示大小不被拉伸（即不变形），可以通过css的样式属性object-fit实现；&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;但是我们也可以通过计算图片的真实宽高和div宽高来实现&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre&gt;&lt;br&gt;div宽高：&lt;br&gt;var div_width,div_height;&lt;br&gt;图片真实的像素宽高:&lt;br&gt;var img = new Image();&lt;br&gt;img.src = img_url;&lt;br&gt;获取图片真实的宽高&lt;br&gt;var img_width&amp;nbsp; = img.width&amp;nbsp;&amp;nbsp;&lt;br&gt;var img_height = img.height&lt;br&gt;计算div和图片的宽高比例：&lt;br&gt;var div_ratio = div_width / div_height;&lt;br&gt;var img_ratio = img_width / img_height;&lt;br&gt;缩放后的图片大小计算：&lt;br&gt;if(img_ratio &amp;gt; div_ratio) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;var zoom_img_width = div_width;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;var zoom_img_height = div_width / img_ratio;&lt;br&gt;}else if(img_ratio &amp;lt; div_ratio) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;var zoom_img_width = div_height * img_ratio;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;var zoom_img_height = div_height;&lt;br&gt;}else{&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;var zoom_img_width = div_width;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;var zoom_img_height = div_height;&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;',0,'2015-10-06 00:00:00','22',48),(73,1,'Python中常出现TabError: inconsistent use of tabs and spaces in indentation','','&lt;div&gt;abError: inconsistent use of tabs and spaces in indentation&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这个错误目前笔者在Subline3遇到的都是看似空格实则没有空格引起的:&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Subline3显示空格制表符的设置方法：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;①.Preferences -&amp;gt;&amp;nbsp; Setting&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;②在Preferences-&amp;gt;Settings-User中添加以下代码：&lt;/div&gt;&lt;pre&gt;&quot;draw_white_space&quot;: &quot;all&quot;,&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\r\n                                                            ',0,'2016-06-13 00:00:00','24',66),(74,1,'python简单的爬虫脚本入门详解','','\r\n                                \r\n                                \r\n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;本脚本实例以爬取本站文章为例讲解，具体代码如下：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;from time import sleep&lt;br&gt;import random&amp;nbsp; #生成随机字符串&lt;br&gt;import os&lt;br&gt;import urllib.request  #python3.*&amp;nbsp; urllib的引入用法&lt;br&gt;from bs4 import BeautifulSoup&lt;br&gt;os.makedirs(\'./images/\', exist_ok=True)&lt;br&gt;for n in range(60,67):&amp;nbsp; &amp;nbsp;#爬取指定范围的文章ID&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;#*******URL管理器*******#&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;url = &quot;http://www.liuzaichun.cn/index/index/articledetail.html?article_id=&quot;+ str(n) #转成字符串后拼接&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;# url = &quot;http://www.liuzaichun.cn/index/index/articledetail.html?article_id=64&quot;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;#*******网页下载*******#&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;page = urllib.request.urlopen(url)&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;# code = page.getcode()&amp;nbsp; # 返回打开的网页的状态码&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;html = page.read()&amp;nbsp; #读取网页内容即下载网页&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;html = html.decode(\'utf-8\')&amp;nbsp; #转utf-8编码&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;#**************常用的网页解析方式******************#&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;#*******正则解析方式*******#&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;# import re&amp;nbsp; # 正则&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;# imgre = re.compile(r\'src=&quot;(.+?)&quot;\')&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;# head = re.findall(imgre,html)&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;#*******beautifulsoup解析方式（第三方库更加便捷简单）*******#&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;soup = BeautifulSoup(html,\'html.parser\')&amp;nbsp; # html.parser参数需要安装 HTMLParser 可以不用引入&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;file = open(\'content.html\', mode=\'a+\',encoding=&quot;utf-8&quot;)&amp;nbsp; # 打开文件并设置utf8编码 否则会乱码&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;#*******异常捕获（防止解析出来的html页面出现不存在需要找的DOM树节点）*******#&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;try:&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;#*******保存爬取的数据*******#&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;title&amp;nbsp; = soup.find(\'div\',attrs={&quot;class&quot;:&quot;article-title&quot;}).find(\'h3\').get_text()&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;file.write(\'\\r\\n文章标题：\'+title)&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;content = soup.find(\'div\',attrs={&quot;class&quot;:&quot;article-title&quot;}).find_next_sibling().get_text()&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;file.write(\'\\r\\n文章内容：\'+content)&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;imgUrl = soup.find(\'div\',attrs={&quot;class&quot;:&quot;article-title&quot;}).find_next_sibling().find_all(\'img\')&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;for img in imgUrl:&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;imgN = \'\'.join(random.sample(\'zyxwvutsrqponmlkjihgfedcba\',10)) #随机生成字符串&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;urllib.request.urlretrieve(\'http://www.liuzaichun.cn/\'+img.get(\'src\'), \'./images/\'+imgN+\'.png\')&amp;nbsp; #根据图片链接下载保存图片文件&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;file.close()&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;print(\'爬取第\'+str(n)+\'篇文章成功\')&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;except :&amp;nbsp; # except 后面可以不写错误类型，写了错误类型，出现异常的错误必须要与之相同，否则还是会报错，不会执行 except 下面的语句&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;print(\'未知错误\')&lt;br&gt;sleep(2)&amp;nbsp; # 2秒执行一次&lt;br&gt;print(\'---------------所有文章爬取完成----------------\')&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;a href=&quot;https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#attributes&quot; target=&quot;_blank&quot;&gt;Beautiful Soup 4.2.0 文档&lt;/a&gt;&lt;br&gt;&lt;/div&gt;\r\n                                                                                                                                                ',0,'2016-11-24 00:00:00','24',42),(75,1,'JQ和CSS3的translate、scale属性实现图片缩放和拖动效果','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br&gt;&amp;lt;html&amp;gt;&lt;br&gt;&amp;lt;head&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;br&gt;&amp;lt;/head&amp;gt;&lt;br&gt;&amp;lt;style type=&quot;text/css&quot;&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;#img-container{width:800px;height:550px;text-align:center;background-color:#ccc;line-height:550px;position:relative;overflow:hidden;}&lt;br&gt;&amp;lt;/style&amp;gt;&lt;br&gt;&amp;lt;body&amp;gt;&lt;br&gt;&amp;nbsp;&amp;lt;div id=&quot;img-container&quot;&amp;gt;&lt;br&gt;&amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;img src=&quot;12.jpg&quot; width=&quot;300&quot; height=&quot;200&quot; style=&quot;cursor:move;&quot;&amp;gt;&lt;br&gt;&amp;nbsp;&amp;lt;/div&amp;gt;&lt;br&gt;&amp;lt;/body&amp;gt;&lt;br&gt;&amp;lt;/html&amp;gt;&lt;br&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;./jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;br&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;(function(){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;var wheel = 0,mousedown = false,startX=0,startY=0,endX=0,endY=0,zoomSize=1,tranX=0,tranY=0,offsetX=0,offsetY=0;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;$(&quot;#img-container img&quot;).on(\'mousewheel\',function(e){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;var e&amp;nbsp; &amp;nbsp; = e || window.event,&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;nbsp; &amp;nbsp; step = 0.15; // 每次缩放的大小&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;// 兼容chrome下鼠标滚动事件&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;if(e.originalEvent.wheelDelta &amp;gt; 0) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;zoomSize = zoomSize+step &amp;gt; 2 ? 2 :zoomSize+step;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;}else{&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;zoomSize = zoomSize-step &amp;lt;=0.5 ? 0.5 : zoomSize-step;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;}&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;$(&quot;#img-container img&quot;).css({\'transform\':\'translate(\'+tranX+\'px,\'+tranY+\'px) scale(\'+zoomSize+\')\',\'transition\':\'all 0.7s ease-out\'});&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;});&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;$(&quot;#img-container img&quot;).on(\'mousedown\',function(e){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; var e = e || window.event;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; if(!e.button) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;startX = e.clientX;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;startY = e.clientY;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;mousedown = true;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;});&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;$(&quot;#img-container img&quot;).on(\'mouseup\',function(e){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; mousedown = false;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; /******************mouseup时记住当前图片的坐标位置，每次鼠标mousedown时，都是以这个值为基础值*********************/&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; tranX = offsetX;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; tranY = offsetY;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;});&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; $(&quot;#img-container img&quot;).on(\'mousemove\',function(e){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; var e = e || window.event;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; if(mousedown){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;endX = e.clientX;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;endY = e.clientY;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;offsetX = (endX - startX) + tranX;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;offsetY = (endY - startY) + tranY;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;$(&quot;#img-container img&quot;).css({\'transform\':\'translate(\'+offsetX+\'px,\'+offsetY+\'px) scale(\'+zoomSize+\')\',\'transition\':\'all 0s ease-out\'});&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; e.preventDefault(); // 阻止鼠标移动默认事件&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;});&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;})();// 闭包函数防止变量被污染&lt;br&gt;&amp;lt;/script&amp;gt;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;',0,'2018-07-04 00:00:00','21,22',40),(76,1,'jq实现鼠标拖动，改变DIV宽度','','&lt;pre&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br&gt;&amp;lt;html&amp;gt;&lt;br&gt;&amp;lt;head&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;br&gt;&amp;lt;/head&amp;gt;&lt;br&gt;&amp;lt;style type=&quot;text/css&quot;&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;#main{width:600px;height:400px;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;#main &amp;gt; div{float:left;width:50%;height:100%;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;#main .left-main {background-color:#ccc;position:relative;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;#main .right-main {background-color:#eee;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;#drag-border{padding:0 5px;position:absolute;right:-7px;top:0px;bottom:0px;z-index:2;cursor:col-resize;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;.inner-line{width:4px;background-color:#000;height:100%;}&lt;br&gt;&amp;lt;/style&amp;gt;&lt;br&gt;&amp;lt;body&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;lt;div id=&quot;main&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;div class=&quot;left-main&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;lt;div id=&quot;drag-border&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;&amp;lt;div class=&quot;inner-line&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;div class=&quot;right-main&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;lt;/div&amp;gt;&lt;br&gt;&amp;lt;/body&amp;gt;&lt;br&gt;&amp;lt;/html&amp;gt;&lt;br&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;(function(){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;var mousedown = false,startX=0,endX=0,main_w,left_main_w;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;$(&quot;#drag-border&quot;).on(\'mousedown\',function(e){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;var e&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;= e || window.event;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;main_w&amp;nbsp; &amp;nbsp; &amp;nbsp; = $(&quot;#main&quot;).outerWidth();&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;left_main_w = $(&quot;.left-main&quot;).outerWidth();&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;mousedown&amp;nbsp; &amp;nbsp;= true;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;startX&amp;nbsp; &amp;nbsp; = e.clientX;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;e.preventDefault();&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;});&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;$(&quot;body&quot;).on(\'mousemove\',function(e){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;var e&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;= e || window.event;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;if(mousedown) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;				&lt;/span&gt;endX = e.clientX;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;				&lt;/span&gt;var offsetX = endX - startX;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;				&lt;/span&gt;var left_percentage = (left_main_w + offsetX) / main_w, right_percentage = 1 - left_percentage;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;				&lt;/span&gt;$(&quot;.left-main&quot;).css(&quot;width&quot;,left_percentage*100+&quot;%&quot;);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;				&lt;/span&gt;$(&quot;.right-main&quot;).css(&quot;width&quot;,right_percentage*100+&quot;%&quot;);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;});&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;$(&quot;body&quot;).on(\'mouseup\',function(e){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;mousedown = false;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;})&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;})();&lt;br&gt;&amp;lt;/script&amp;gt;&lt;/pre&gt;\r\n                                                            ',0,'2016-06-08 00:00:00','22',20),(77,1,'windows下，python 安装 Scrapy 报错 import setuptools','','&lt;pre&gt;Command &quot;d:\\python\\python27\\python.exe -u -c &quot;import setuptools, tokenize;__file&lt;br&gt;__=\'c:\\\\users\\\\admini~1\\\\appdata\\\\local\\\\temp\\\\pip-build-9gywq7\\\\Twisted\\\\setup.&lt;br&gt;py\';f=getattr(tokenize, \'open\', open)(__file__);code=f.read().replace(\'\\r\\n\', \'\\&lt;br&gt;n\');f.close();exec(compile(code, __file__, \'exec\'))&quot; install --record c:\\users\\a&lt;br&gt;dmini~1\\appdata\\local\\temp\\pip-_jok3e-record\\install-record.txt --single-version&lt;br&gt;-externally-managed --compile&quot; failed with error code 1 in c:\\users\\admini~1\\app&lt;br&gt;data\\local\\temp\\pip-build-9gywq7\\Twisted\\&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;【解决方法】&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;（1）、先安装：twisted&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;（2）、下载地址：https://www.lfd.uci.edu/~gohlke/pythonlibs/&amp;nbsp; &amp;nbsp;找到Twisted 下载对应的版本到本地文件下，然后用 pip install Twisted文件路径&lt;/div&gt;&lt;div&gt;（3）、然后再使用：pip install Scrapy&lt;/div&gt;\r\n                                                            ',0,'2017-07-13 00:00:00','24',32),(78,1,'windows下利用（python）scrapy写爬虫，运行 scrapy crawl spider_name 命令时提示：exceptions.ImportError: No module named win32api','','&lt;div&gt;解决方案：&lt;/div&gt;&lt;div&gt;安装pywin32模块，可在http://sourceforge.net/projects/pywin32/下载（版本必须与当前python的相同）&lt;/div&gt;\r\n                                                            ',0,'2018-02-06 00:00:00','24',26),(79,1,'python如何去掉字符串‘\\xa0’','','&lt;div&gt;我们通常所用的空格是 \\x20 ，是在标准ASCII可见字符 0x20~0x7e 范围内。而 \\xa0 属于 latin1 （ISO/IEC_8859-1）中的扩展字符集字符，代表空白符nbsp(non-breaking space)。 latin1 字符集向下兼容 ASCII （ 0x20~0x7e ）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; s = \'09月27日\\xa0发布\'&lt;br&gt;&amp;gt;&amp;gt;&amp;gt; s = &quot;&quot;.join(s.split())&lt;br&gt;&amp;gt;&amp;gt;&amp;gt; s&lt;br&gt;\'09月27日发布\'&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;split():split方法中不带参数时，表示分割所有换行符、制表符、空格。&lt;/div&gt;\r\n                                                            ',0,'2017-06-07 00:00:00','24',62),(80,1,'windows下安装Scrapy(python3)及scrapy教程','','\r\n                                \r\n                                \r\n                                \r\n                                \r\n                                \r\n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一：安装wheel&lt;/p&gt;&lt;p&gt;　　 wheel介绍&amp;nbsp;&lt;/p&gt;&lt;p&gt;二：安装twisted&lt;/p&gt;&lt;p&gt;　　twisted是由python编写的一款基于事件驱动的网络引擎，使用twisted模块将python的异步请求（异步模型介绍）成为可能且简单易用。Twisted介绍&amp;nbsp;&amp;nbsp;&lt;/p&gt;&lt;p&gt;三：创建scrapy文件&lt;/p&gt;&lt;p&gt;&amp;nbsp;　　使用命令窗口进入目标目录后 使用命令&amp;nbsp;&lt;/p&gt;&lt;pre&gt;&amp;nbsp;scrapy startproject&amp;nbsp; spider_name&lt;/pre&gt;&lt;p&gt;&amp;nbsp; 工程目录结构如图：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190130/39635310df7d0bad8c86b88d01a8b5d6.png&quot; data-filename=&quot;img&quot; style=&quot;width: 535px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190131/81054ba9105f43c44346f603757fa5bc.png&quot; data-filename=&quot;img&quot; style=&quot;width: 550px;&quot;&gt;&lt;/p&gt;&lt;p&gt;更直观的解释图：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190131/e8e96c2f78b28b6703b59ce63b517ec1.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 960px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以在items.py同级目录下新建 （begin.py）作为启动文件，运行爬虫脚本时，只需要运行此文件即可。&lt;/p&gt;&lt;pre&gt;from scrapy import cmdline&lt;br&gt;cmdline.execute((&quot;scrapy crawl spider_name --nolog&quot;).split())&amp;nbsp;  #--nolog不输出日志信息&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;b&gt; 代码编写流程，&lt;/b&gt;&lt;/p&gt;&lt;p&gt;1.在items.py 文件里定义好需要爬取的字段名&lt;/p&gt;&lt;pre&gt;import scrapy&lt;br&gt;class MyscrapyItem(scrapy.Item):&lt;br&gt;&amp;nbsp; &amp;nbsp; article_tile&amp;nbsp; = scrapy.Field()&lt;br&gt;&amp;nbsp; &amp;nbsp; article_intro = scrapy.Field()&lt;br&gt;&amp;nbsp; &amp;nbsp; article_createtime = scrapy.Field()&lt;/pre&gt;&lt;p&gt;2.在spiders文件夹找到新建的爬虫文件名，编写核心的爬虫代码&lt;/p&gt;&lt;pre&gt;# -*- coding: utf-8 -*-&lt;br&gt;import scrapy,sys&lt;br&gt;from myscrapy.items import MyscrapyItem&lt;br&gt;class TestspiderSpider(scrapy.Spider):&lt;br&gt;&amp;nbsp; &amp;nbsp; name = \'testspider\'&lt;br&gt;&amp;nbsp; &amp;nbsp; allowed_domains = [\'www.liuzaichun.cn\']&lt;br&gt;&amp;nbsp; &amp;nbsp; start_urls = [\'http://www.liuzaichun.cn\']&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; # 重写start_requests() 方法 不再调用 star_urls&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; def start_requests(self):&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;# 由于不能在抓取的页面DOM中获取到下一页的链接，所以只能重写此方法拼接分页链接，循环请求每一页，并抓取之&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;for&amp;nbsp; p in range(1,5):&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;print(\'爬取第：\'+str(p))&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;next_url = &quot;http://www.liuzaichun.cn/?p=&quot;+str(p)&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;yield scrapy.Request(next_url , callback=self.parse)&lt;br&gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; ### 爬虫数据抓取的核心部分&lt;br&gt;&amp;nbsp; &amp;nbsp; def parse(self, response):&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;# file = open(\'../content.text\', mode=\'a+\',encoding=&quot;utf-8&quot;)&amp;nbsp; # 打开文件并设置utf8编码 否则会乱码&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;\'\'\'可以用.css选择器选择\'\'\'&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;# title= response.css(\'h3::text\').extract()&amp;nbsp;&lt;br&gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;\'\'\'.xpath选择器\'\'\'&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;\'\'\'&amp;nbsp; &amp;nbsp; &amp;nbsp; 从根（ 根为\'/\'，）节点下开始匹配单个标签\'\'\'&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;# title= response.xpath(\'/html/head/title/text()\').extract()&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;\'\'\'&amp;nbsp; &amp;nbsp; &amp;nbsp;\'//\'从下载的网页dom中找到所有匹配的元素，不管在任何位置&amp;nbsp; 但是 &quot;.//&quot; 是从当前标签下找到所有的匹配标签&amp;nbsp; \'\'\'&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;# title= response.xpath(&quot;//div[@class=\'m-portlet__body\']/div[1]/h3/text()&quot;).extract()[0]&amp;nbsp; # /text()获取某个标签的文本&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;# content = response.xpath(&quot;//div[@class=\'m-portlet__body\']/div[2]//text()&quot;).extract() # //text()获取某个标签以及它的所有子标签的文本&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;# 定义爬虫字段信息的类&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;fields = MyscrapyItem()&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;# 将获取的数据交给pipelines，pipelines在settings.py中需要开启 ITEM_PIPELINES&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;# yield fields&amp;nbsp; &amp;nbsp;#使用yield返回数据，不要使用return。这样子parse就会被当做一个生成器。scarpy将parse生成的数据，逐一返回&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;lis = response.xpath(&quot;//div[@class=\'m-portlet__body\']/div[1]//div[@class=\'ibox-content\']&quot;)&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;for it in lis:&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;fields[\'article_tile\']&amp;nbsp; &amp;nbsp;= it.xpath(&quot;./h4/a/text()&quot;).extract()[0]&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;		&lt;br&gt;&lt;/span&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;fields[\'article_intro\']&amp;nbsp; = \'\'.join(it.xpath(&quot;./div[1]/p/text()&quot;).extract()[0].split())&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;t = \'\'.join(it.xpath(&quot;./div[2]/div[1]//text()&quot;).extract())&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;fields[\'article_createtime\']&amp;nbsp; = \'\'.join(t).split()[0]&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;		&lt;br&gt;&lt;/span&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;yield fields&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;next_url = response.css(\'li.next_page\')&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;# print(next_url)&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;3.把爬取的数据通过管道文件存储入库&lt;/p&gt;&lt;pre&gt;import mongo,os,csv&lt;br&gt;#爬虫字段数据信息保存的类&lt;br&gt;class MyscrapyPipeline(object):&lt;br&gt;      def __init__(self):&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;self.mongo = mongo.MongoDb(\'27017\',\'localhost\',\'pybase\',\'spiderTable\')&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;# csv 文件&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;# store_file = os.path.dirname(__file__)+&quot;/content.csv&quot;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;# self.file = open(store_file,&quot;a+&quot;,newline=\'\',encoding=&quot;utf-8&quot;)&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;# self.writer = csv.writer(self.file)&lt;br&gt;      def process_item(self, item, spider):&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;\'\'\'存为csv文件\'\'\'&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;# try:&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;# &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;self.writer.writerow((&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;# &lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;item[&quot;article_tile&quot;],&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;# &lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;item[&quot;article_content&quot;],&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;				&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;# &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;))&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;# except:&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;# &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;print(\'unerror!!!\')&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;# return item&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;# print(item)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;#mongo存储数据&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;self.mongo.insert_one(dict(item))&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;4.运行begin.py文件，整个爬虫脚本就会工作啦&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;                                                                                                                                                                        ',0,'2017-05-09 00:00:00','24',27),(81,1,'python 爬虫原理分析图','','\r\n                                \r\n                                &lt;p&gt;一张简单的爬虫架构图&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190131/0d9e64deed33954ac154979afe3a3619.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 50%;&quot;&gt;&lt;/p&gt;&lt;p&gt;首先我们需要一个爬虫调度端来启动和停止爬虫，同时也要通过它来监视爬虫的状态，并通过它提供接口来作具体的数据应用。这个部分不属于爬虫本身。&lt;/p&gt;&lt;p&gt;图中阴影方框中的部分就是我们爬虫程序。因为有的页面的入口有很多，我们可以通过不同的URL调度路径来访问这个界面，那么作为一个智能的爬虫软件，当遇到我们已经爬取过的URL的时候，应该选择过滤，而不是再次爬取。URL管理器就是用来存储已经爬取URL和将要爬取URL的工具的。&lt;/p&gt;&lt;p&gt;从URL管理器中选择一个待爬取的URL，将其传送给网页下载器，下载器会把网页以字符串的形式下载下来，并把这个字符串交给网页解析器去解析，网页解析器一方面会把你需要获取的价值信息提取出来归还给调度器，另一方面，如果遇到该网页有新的URL待爬取，就会把这个URL传送给URL管理器。从此，这三个模块进行循环，直到该网页相关的所有URL都爬取完毕。&lt;/p&gt;&lt;p&gt;更加清晰的动态运行流程，可以用一个时序图来表示。大家可以对照着上面的步骤理解下。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190131/cee0064e239afea1e0a32f277d39630f.png&quot; data-filename=&quot;img&quot; style=&quot;width: 600px;&quot;&gt;&lt;/p&gt;&lt;p&gt;URL 管理器是用来管理待抓取的 URL 和已抓取的 URL，作为一只聪明的爬虫，我们当然应该会选择跳过那些我们已经爬取过的 URL ，这不仅是为了防止重复抓取，也为了防止一些循环抓取的问题，URL 间的互相调用会导致爬虫的无限死循环抓取。&lt;/p&gt;&lt;p&gt;URL 管理器就是为了解决这些问题而存在的，有了它，我们的爬虫才会更加聪明，从而避免重复抓取和循环抓取。上面列出的就是 URL 管理器所要做的工作，根据这些职能，我们就可以总结出实现 URL 管理器的一个大体思路。&lt;/p&gt;&lt;p&gt;我们需要两个容器 A 和 B，A 用来存储待爬取的 URL，B 用来存储已爬取的 URL，管理器从 A 中获取 URL 来交付给网页下载器去处理，如果 A 中没有 URL 就等待，每当爬虫爬取到新的 URL 的时候，就将这个 URL 添加到 A 中排队等待爬取。爬取完一个 URL 后，就把这个 URL 存放到 B 中。爬虫的时候，如果获取到的 URL 在 A 中或者 B 中存在了，就跳过该 URL。流程图如下：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190131/feeacee8fd2b0115eaa086eb96e7aea9.png&quot; data-filename=&quot;img&quot; style=&quot;width: 618px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;                                                        ',0,'2017-08-09 00:00:00','24',52),(82,1,'使用git命令回退历史版本','','\r\n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在git中每次commit就会生成一个版本号（即 commit id） 命令&lt;span style=&quot;color: rgb(231, 99, 99); background-color: rgb(239, 239, 239);&quot;&gt;: git reset --hard&amp;nbsp; commit_id&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;background-color: rgb(247, 247, 247);&quot;&gt;在Git中，我们用git log命令查看版本号：&lt;/span&gt;&lt;/p&gt;&lt;pre style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 10px; background: rgb(250, 250, 250); font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 12px; line-height: 18px; font-family: Consolas, monospace, serif; color: rgb(68, 68, 68); tab-size: 4; border-color: rgb(221, 221, 221); border-radius: 3px;&quot;&gt;&lt;code class=&quot;xml&quot;&gt;$ git log\r\ncommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&amp;gt; master)\r\nAuthor: Michael Liao &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;askxuefeng@gmail.com&lt;/span&gt;&amp;gt;&lt;/span&gt;\r\nDate:   Fri May 18 21:06:15 2018 +0800\r\n\r\n    append GPL\r\n\r\ncommit e475afc93c209a690c39c13a46716e8fa000c366\r\nAuthor: Michael Liao &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;askxuefeng@gmail.com&lt;/span&gt;&amp;gt;&lt;/span&gt;\r\nDate:   Fri May 18 21:03:36 2018 +0800\r\n\r\n    add distributed\r\n\r\ncommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0\r\nAuthor: Michael Liao &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;askxuefeng@gmail.com&lt;/span&gt;&amp;gt;&lt;/span&gt;\r\nDate:   Fri May 18 20:59:18 2018 +0800\r\n\r\n    wrote a readme file&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;git log命令显示从最近到最远的提交日志（如果当前版本号不是最新的版本，用git log 不能显示所有的版本号，所以需要用 git reflog 查看），我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。&lt;/p&gt;&lt;p&gt;每提交（commit）一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线。&lt;/p&gt;&lt;p&gt;首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（请参照自己版本号），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。（推荐使用 git reset --hard commit_id）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：&lt;/p&gt;&lt;pre&gt;$ git reset --hard HEAD^&lt;br&gt;HEAD is now at e475afc add distributed&lt;/pre&gt;&lt;p&gt;还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态：&lt;/p&gt;&lt;pre style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 10px; background: rgb(250, 250, 250); font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 12px; line-height: 18px; font-family: Consolas, monospace, serif; color: rgb(68, 68, 68); tab-size: 4; border-color: rgb(221, 221, 221); border-radius: 3px;&quot;&gt;&lt;code class=&quot;xml&quot;&gt;$ git log\r\ncommit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&amp;gt; master)\r\nAuthor: Michael Liao &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;askxuefeng@gmail.com&lt;/span&gt;&amp;gt;&lt;/span&gt;\r\nDate:   Fri May 18 21:03:36 2018 +0800\r\n\r\n    add distributed\r\n\r\ncommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0\r\nAuthor: Michael Liao &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;askxuefeng@gmail.com&lt;/span&gt;&amp;gt;&lt;/span&gt;\r\nDate:   Fri May 18 20:59:18 2018 +0800\r\n\r\n    wrote a readme file&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(102, 102, 102); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 14px; white-space: pre-wrap;&quot;&gt;最新的那个版本&lt;/span&gt;&lt;code style=&quot;font-size: 12px; font-family: Consolas, monospace, serif; color: rgb(221, 0, 85); padding-top: 0px; padding-bottom: 0px; border: 1px solid rgb(221, 221, 221); border-radius: 3px; background: rgb(250, 250, 250);&quot;&gt;append GPL&lt;/code&gt;&lt;span style=&quot;color: rgb(102, 102, 102); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 14px; white-space: pre-wrap;&quot;&gt;已经看不到了！想再回去已经回不去了，肿么办？ &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(102, 102, 102); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 14px; white-space: pre-wrap;&quot;&gt;现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的&lt;/span&gt;&lt;code style=&quot;font-size: 12px; font-family: Consolas, monospace, serif; color: rgb(221, 0, 85); padding-top: 0px; padding-bottom: 0px; border: 1px solid rgb(221, 221, 221); border-radius: 3px; background: rgb(250, 250, 250);&quot;&gt;commit id&lt;/code&gt;&lt;span style=&quot;color: rgb(102, 102, 102); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 14px; white-space: pre-wrap;&quot;&gt;怎么办？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(102, 102, 102); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 14px; white-space: pre-wrap;&quot;&gt;在Git中，当你用&lt;/span&gt;&lt;code style=&quot;font-size: 12px; font-family: Consolas, monospace, serif; color: rgb(221, 0, 85); padding-top: 0px; padding-bottom: 0px; border: 1px solid rgb(221, 221, 221); border-radius: 3px; background: rgb(250, 250, 250);&quot;&gt;$ git reset --hard HEAD^&lt;/code&gt;&lt;span style=&quot;color: rgb(102, 102, 102); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 14px; white-space: pre-wrap;&quot;&gt;回退到&lt;/span&gt;&lt;code style=&quot;font-size: 12px; font-family: Consolas, monospace, serif; color: rgb(221, 0, 85); padding-top: 0px; padding-bottom: 0px; border: 1px solid rgb(221, 221, 221); border-radius: 3px; background: rgb(250, 250, 250);&quot;&gt;add distributed&lt;/code&gt;&lt;span style=&quot;color: rgb(102, 102, 102); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 14px; white-space: pre-wrap;&quot;&gt;版本时，再想恢复到&lt;/span&gt;&lt;code style=&quot;font-size: 12px; font-family: Consolas, monospace, serif; color: rgb(221, 0, 85); padding-top: 0px; padding-bottom: 0px; border: 1px solid rgb(221, 221, 221); border-radius: 3px; background: rgb(250, 250, 250);&quot;&gt;append GPL&lt;/code&gt;&lt;span style=&quot;color: rgb(102, 102, 102); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 14px; white-space: pre-wrap;&quot;&gt;，就必须找到&lt;/span&gt;&lt;code style=&quot;font-size: 12px; font-family: Consolas, monospace, serif; color: rgb(221, 0, 85); padding-top: 0px; padding-bottom: 0px; border: 1px solid rgb(221, 221, 221); border-radius: 3px; background: rgb(250, 250, 250);&quot;&gt;append GPL&lt;/code&gt;&lt;span style=&quot;color: rgb(102, 102, 102); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 14px; white-space: pre-wrap;&quot;&gt;的commit id。Git提供了一个命令&lt;/span&gt;&lt;code style=&quot;font-size: 12px; font-family: Consolas, monospace, serif; color: rgb(221, 0, 85); padding-top: 0px; padding-bottom: 0px; border: 1px solid rgb(221, 221, 221); border-radius: 3px; background: rgb(250, 250, 250);&quot;&gt;git reflog&lt;/code&gt;&lt;span style=&quot;color: rgb(102, 102, 102); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 14px; white-space: pre-wrap;&quot;&gt;用来记录你的每一次命令：&lt;/span&gt;&lt;span style=&quot;color: rgb(102, 102, 102); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 14px; white-space: pre-wrap;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 10px; background: rgb(250, 250, 250); font-variant-numeric: normal; font-variant-east-asian: normal; font-stretch: normal; font-size: 12px; line-height: 18px; font-family: Consolas, monospace, serif; color: rgb(68, 68, 68); tab-size: 4; border-color: rgb(221, 221, 221); border-radius: 3px;&quot;&gt;&lt;code class=&quot;css&quot;&gt;$ &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;reflog&lt;/span&gt;\r\n&lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;e475afc&lt;/span&gt; &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;HEAD&lt;/span&gt;&lt;span class=&quot;at_rule&quot;&gt;@&lt;/span&gt;{1}: &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;reset&lt;/span&gt;: &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;moving&lt;/span&gt; &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;HEAD&lt;/span&gt;^\r\n1094&lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;adb&lt;/span&gt; (&lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;HEAD&lt;/span&gt; -&amp;gt; &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;master&lt;/span&gt;) &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;HEAD&lt;/span&gt;&lt;span class=&quot;at_rule&quot;&gt;@&lt;/span&gt;{2}: &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;commit&lt;/span&gt;: &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;append&lt;/span&gt; &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;GPL     #当前版本号&lt;/span&gt;\r\n&lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;e475afc&lt;/span&gt; &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;HEAD&lt;/span&gt;&lt;span class=&quot;at_rule&quot;&gt;@&lt;/span&gt;{3}: &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;commit&lt;/span&gt;: &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;distributed&lt;/span&gt;\r\n&lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;eaadf4e&lt;/span&gt; &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;HEAD&lt;/span&gt;&lt;span class=&quot;at_rule&quot;&gt;@&lt;/span&gt;{4}: &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;commit&lt;/span&gt; (&lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;initial&lt;/span&gt;): &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;wrote&lt;/span&gt; &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;readme&lt;/span&gt; &lt;span class=&quot;tag&quot; style=&quot;color: rgb(0, 0, 128);&quot;&gt;file&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过查看我们可以再次回退到最新的版本：&lt;/p&gt;&lt;pre&gt;git reset --hard&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: rgb(0, 0, 128); background-color: transparent; font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; font-size: inherit; white-space: pre-wrap;&quot;&gt;e475afc&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;现在总结一下：&lt;/p&gt;&lt;p&gt;HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。&lt;/p&gt;&lt;p&gt;穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。一般当前版本号为最新的版本可以用git log，否则显示不全&lt;/p&gt;&lt;p&gt;要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;                            ',0,'2016-06-16 00:00:00','32',41),(83,1,'关于自动化测试selenium','','&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;# selenium 是一个自动化测试工具 在Python中的应用&lt;/div&gt;&lt;div&gt;#1-selenium在Python中可以完全模拟浏览器操作，对动态数据进行获取&lt;/div&gt;&lt;div&gt;#2-动态数据由代码生成，在页面初始化过程中 没有传输无法获取，但是selenium可以获取&lt;/div&gt;&lt;div&gt;#3-有些数据是需要登录以后才可以获取，比如好友列表，评论等&lt;/div&gt;&lt;div&gt;#4-使用selenium可以避免人工登录，只需要得到账号密码，就可以实现模拟人登录&lt;/div&gt;&lt;div&gt;# selenium的特点：&lt;/div&gt;&lt;div&gt;# 1.由程序控制浏览器操作，而不是手动操作浏览器&lt;/div&gt;&lt;div&gt;# 2.程序控制浏览器操作的时候，速度非常慢&lt;/div&gt;&lt;div&gt;# 3.使用selenium控制浏览器的时候需要下载浏览器对应的驱动&lt;/div&gt;&lt;div&gt;# 4.selenium为开源免费，但是更新的没有浏览器数度快，要注意和浏览器之间的对应关系&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;selenium安装的过程还是比较简单的，在Python所在的命令行下执行pip install selenium然后很快就会下载安装完毕&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;此时在Python的.py文件中使用from selenium import webdriver#引入网页驱动，不会报错就表示安装完成了，但是并没有结束，想使用selenium工具操作浏览器还需要相应的浏览器驱动的安装，可以自行去网上下载geckodriver（火狐）和chromedriver（google）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;我这里使用的指定驱动的位置来执行把驱动的位置指定给executable_path,具体代码如下，&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;from selenium import webdriver#引入网页驱动&lt;/div&gt;&lt;div&gt;import time&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;driver=webdriver.Firefox(executable_path=\'D:/python/anaconda/Scripts/geckodriver\')&amp;nbsp; &amp;nbsp;#使用网页驱动来运行火狐浏览器&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;# driver=webdriver.Chrome(executable_path=\'D:/python/anaconda/Scripts/chromedriver\')&amp;nbsp; &amp;nbsp;#使用网页驱动来运行google浏览器&lt;/div&gt;&lt;div&gt;driver.get(\'http://www.baidu.com\')#通过驱动来执行指定的网页&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;#selenium提供了找到元素的方法find element by XXX&lt;/div&gt;&lt;div&gt;#这些方法全部都是用Python实现的&lt;/div&gt;&lt;div&gt;#如果只是想对这个元素进行查找，定位，建议使用xpath、css_selecotor&lt;/div&gt;&lt;div&gt;#如果需要对找到的内容进行点击等操作&amp;nbsp; 建议使用&lt;/div&gt;&lt;div&gt;#可能报错，代码的速度很快，但是浏览器的响应很慢&lt;/div&gt;&lt;div&gt;#代码执行到这里的时候，浏览器里面的元素还没有加载完，会出现找不到指定的元素&lt;/div&gt;&lt;div&gt;#time.sleep(1)&lt;/div&gt;&lt;div&gt;#driver.find_element_by_id(\'kw\').send_keys(\'selenium\')#find 找到&amp;nbsp; element元素 通过ID，name,class&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;#通过name值定位&lt;/div&gt;&lt;div&gt;# driver.find_element_by_name(\'wd\').send_keys(\'csdn\')&lt;/div&gt;&lt;div&gt;# driver.find_element_by_class_name(\'s_ipt\').send_keys(u\'今日头条\')#中文前最好是加一个U&lt;/div&gt;&lt;div&gt;# driver.find_element_by_tag_name(\'input\').send_keys(\'头条\')#寻找标签名称&lt;/div&gt;&lt;div&gt;# driver.find_element_by_css_selector(\'#kw\')#通过样式来选择#id，.类名&lt;/div&gt;&lt;div&gt;# driver.find_element_by_xpath(\'//from[id=&quot;form&quot;]/span/input[@id=&quot;kw&quot;]\')#通过xpath语法定位一个元素&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;time.sleep(3)&lt;/div&gt;&lt;div&gt;driver.find_element_by_link_text(u\'贴吧\').click()&lt;/div&gt;&lt;div&gt;driver.close()&lt;/div&gt;\r\n                                                            ',0,'2016-08-16 00:00:00','24',42),(84,1,'python的thread和threading区别','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;python提供了多种模块用来支持多线程编程，&lt;/p&gt;&lt;p&gt;thread（在python3中改名为_thread）,threading,和 queue模块。&lt;/p&gt;&lt;p&gt;通过加入queue模块，用户可以创建多个线程共享数据的队列数据结构。&lt;/p&gt;&lt;p&gt;thread和threading模块都可以用来创建和管理线程，而thread模块提供了基本的线程和锁支持。&lt;/p&gt;&lt;p&gt;threading提供的是更高级的完全的线程管理。&lt;/p&gt;&lt;p&gt;低级别的thread模块是推荐给高手用，一般应用程序推荐使用更高级的threading模块：&lt;/p&gt;&lt;p&gt;1.它更先进，有完善的线程管理支持，此外，在thread模块的一些属性会和threading模块的这些属性冲突。&lt;/p&gt;&lt;p&gt;2.thread模块有很少的（实际上是一个）同步原语，而threading却有很多。&lt;/p&gt;&lt;p&gt;3.thread模块没有很好的控制，特别当你的进程退出时，&lt;/p&gt;&lt;p&gt;比如：当主线程执行完退出时，其他的线程都会无警告，无保存的死亡，&lt;/p&gt;&lt;p&gt;而threading会允许默认，重要的子线程完成后再退出，它可以特别指定daemon类型的线程。&lt;/p&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;',0,'2017-07-06 00:00:00','24',59),(85,1,'解决方法 PHP Warning: File upload error - unable to create a temporary file in Unknown','','&lt;div&gt;原因:&lt;/div&gt;&lt;div&gt;上传文件时,没有管理员权限的你不能读取临时文件夹;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;解决办法：可以找到不能读取的临时文件，并修改权限，但是建议修改php.ini配置文件的 upload_tmp_dir = xxx 重新选择新的上传文件的临时目录&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\r\n                                                            ',0,'2018-04-04 00:00:00','23',44),(86,1,'python3 多线程编程之threading模块创建线程的方法','','\r\n                                &lt;div&gt;\'\'\'&lt;br&gt;&lt;/div&gt;&lt;div&gt;多线程类似于同时执行多个不同程序，多线程运行有如下优点：&lt;/div&gt;&lt;div&gt;使用线程可以把占据长时间的程序中的任务放到后台去处理。&lt;/div&gt;&lt;div&gt;用户界面可以更加吸引人，比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度&lt;/div&gt;&lt;div&gt;程序的运行速度可能加快&lt;/div&gt;&lt;div&gt;在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下我们可以释放一些珍贵的资源如内存占用等等。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;使用Thread类，可以有多种方法创建线程：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1.创建Thread类的实例，传递一个函数&lt;/div&gt;&lt;div&gt;2.创建Thread类的实例，传递一个可调用的类实例&lt;/div&gt;&lt;div&gt;3.派生Thread类的子类，并创建子类的实例&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;一般的，我们会采用第一种或者第三种方法。如果需要一个更加符合面向对象的接口时，倾向于选择第三种方法，否则就用第一种方法。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;\'\'\'&lt;/div&gt;&lt;pre&gt;import threading&lt;br&gt;from time import sleep,ctime&lt;br&gt;#创建两个线程分别在不同的时间段执行（用来演示多线程下是并发执行的，顺序是乱的），并把这些常量放进列表loops中&lt;br&gt;loops=[4,2]&lt;br&gt;def handel_excel(nloop,nsec):&lt;br&gt;&amp;nbsp; &amp;nbsp; print(\'子线程：\'+str(nloop),\'开始执行excel任务了\',\'at:\',ctime())&lt;br&gt;&amp;nbsp; &amp;nbsp; sleep(nsec)&lt;br&gt;&amp;nbsp; &amp;nbsp; print(\'子线程：\'+str(nloop),\'结束执行excel任务了\',\'at\',ctime())&lt;br&gt;def handel_word(nloop,nsec):&lt;br&gt;&amp;nbsp; &amp;nbsp; print(\'子线程：\'+str(nloop),\'开始执行word任务了\',\'at:\',ctime())&lt;br&gt;&amp;nbsp; &amp;nbsp; sleep(nsec)&lt;br&gt;&amp;nbsp; &amp;nbsp; print(\'子线程：\'+str(nloop),\'结束执行word任务了\',\'at\',ctime())&lt;br&gt;\'\'\'第一种方式创建\'\'\'&lt;br&gt;def main_first():&lt;br&gt;&amp;nbsp; &amp;nbsp; print(\'子线程开始工作于：\',ctime())&lt;br&gt;&amp;nbsp; &amp;nbsp; threads=[]&lt;br&gt;&amp;nbsp; &amp;nbsp; nloops=range(len(loops))&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; for i in nloops:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; #循环 实例化2个Thread类，传递函数及其参数，并将线程对象放入threads列表中,这个列表主要是为了后续便于实现阻塞主线程，&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; #让主线程等待所有的子线程都把任务执行完毕了才往下执行&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if i ==0 :&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; t=threading.Thread(target=handel_excel,args=(i,loops[i]))&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; else :&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; t=threading.Thread(target=handel_word,args=(i,loops[i]))&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; threads.append(t)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; for i in nloops:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; threads[i].start()&amp;nbsp; #循环 开始线程&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; for i in nloops:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; threads[i].join()&amp;nbsp; &amp;nbsp;#循环 join()方法可以让主线程等待所有的子线程都执行完毕才会往下执行，除非添加时间 join(时间秒)，表示多少秒后往下执行。&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; print(\'主线程任务完成于：\',ctime())&lt;br&gt;&lt;br&gt;&lt;br&gt;\'\'\'第三种方式创建\'\'\'&lt;br&gt;class Mythread(threading.Thread):&lt;br&gt;&amp;nbsp; &amp;nbsp; &quot;&quot;&quot;docstring for Mythread&quot;&quot;&quot;&lt;br&gt;&amp;nbsp; &amp;nbsp; def __init__(self,func,args):&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; threading.Thread.__init__(self)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; self.func = func&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; self.args = args&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; def run(self):&amp;nbsp; #重写run方法&amp;nbsp; run是运行线程需要处理的函数&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; self.func(*self.args)&amp;nbsp; &amp;nbsp;&lt;br&gt;&lt;br&gt;def main_third():&lt;br&gt;&amp;nbsp; &amp;nbsp; ths = []&lt;br&gt;&amp;nbsp; &amp;nbsp; for i in range(len(loops)):&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if i ==0 :&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; th&amp;nbsp; = Mythread(handel_excel,(i,loops[i]))&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; else :&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; th&amp;nbsp; = Mythread(handel_word,(i,loops[i]))&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ths.append(th)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; th.start()&lt;br&gt;&amp;nbsp; &amp;nbsp; for i in range(len(loops)):&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ths[i].join()&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; print(\'主线程任务完成于：\',ctime())&lt;br&gt;def tupelFunc(*args) :&lt;br&gt;&amp;nbsp; &amp;nbsp; for i in args:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; print(i)&amp;nbsp;&amp;nbsp;&lt;br&gt;if __name__==\'__main__\':&lt;br&gt;&amp;nbsp; &amp;nbsp; \'\'\'提示：用tupel类型传参需要在前面加*\'\'\'&lt;br&gt;&amp;nbsp; &amp;nbsp; # tupelFunc(*(\'tuple\',\'test\'))&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; # main_first()&lt;br&gt;&amp;nbsp; &amp;nbsp; main_third()&lt;/pre&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;&amp;nbsp;注意：只有把创建的线程先放入一个列表里，在循环join()线程，才能发挥多线程的意义，&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;pre&gt;这样子处理失去了多线程的意义：&lt;br&gt;for i in range(4):&lt;br&gt;&amp;nbsp; &amp;nbsp; t =threading.Thread(target=action,args=(i,))&lt;br&gt;&amp;nbsp; &amp;nbsp; t.start()&lt;br&gt;&amp;nbsp; &amp;nbsp; t.join()&lt;br&gt;程序只能顺序执行，每个线程都被上一个线程的join阻塞，使得“多线程”失去了多线程意义。&lt;/pre&gt;\r\n                                                                                        ',0,'2017-08-11 00:00:00','24',41),(87,1,'video标签中的视频资源以blob:http形式播放的探究','','&lt;div&gt;首先blob:https并不是一种协议，而是html5中blob对象在赋给video标签后生成的一串标记，blob对象对象包含的数据，浏览器内部会解析；&lt;/div&gt;&lt;div&gt;通过js代码处理可以把后端传来的视频二进制数据添加到video标签里&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br&gt;&amp;lt;html&amp;gt;&lt;br&gt;&amp;lt;head&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;meta charset=\'utf-8\'&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;title&amp;gt;测试video blob对象&amp;lt;/title&amp;gt;&lt;br&gt;&amp;lt;/head&amp;gt;&lt;br&gt;&amp;lt;body&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;p&amp;gt;视频播放&amp;lt;/p&amp;gt;&lt;br&gt;&amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;video controls id=&quot;mv&quot;&amp;gt;&amp;lt;/video&amp;gt;&lt;br&gt;&amp;lt;/body&amp;gt;&lt;br&gt;&amp;lt;/html&amp;gt;&lt;br&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;xhr = new XMLHttpRequest()&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;xhr.open(&quot;POST&quot;, &quot;http://localhost/video_blob.php&quot;, true);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;xhr.responseType = \'blob\';&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;xhr.onload = function(e) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;if (this.status==200) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;var blob = this.response; // 获取二进制blob数据&amp;nbsp; &amp;nbsp;responseText 获取文本数据&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;// 把blob视频二进制数据放入到video容器中&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;document.getElementById(\'mv\').src= window.URL.createObjectURL(blob);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;xhr.send()&lt;br&gt;&amp;lt;/script&amp;gt;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;PHP 返回视频二进制数据&lt;br&gt;header(\'Content-Type: text/html;charset=utf-8\');&lt;br&gt;header(\'Access-Control-Allow-Origin:*\'); // *代表允许任何网址请求&lt;br&gt;header(\'Access-Control-Allow-Methods:POST,GET,OPTIONS,DELETE\'); // 允许请求的类型&lt;br&gt;header(\'Access-Control-Allow-Credentials: true\'); // 设置是否允许发送 cookies&lt;br&gt;header(\'Access-Control-Allow-Headers: Content-Type,Content-Length,Accept-Encoding,X-Requested-with, Origin\'); // 设置允许自定义请求头的字段&lt;br&gt;$file = fopen(&quot;./test.wmv&quot;, \'rb\'); #rb表示只读方式打开一个二进制文件&amp;nbsp; wb写入一个二进制文件数据&lt;br&gt;$blob = fread($file,filesize(&quot;./test.wmv&quot;));&lt;br&gt;if($blob) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;echo $blob;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;exit;&lt;br&gt;}else{&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;echo \'\';&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;exit;&lt;br&gt;}&lt;/pre&gt;\r\n                                                            ',0,'2017-06-06 00:00:00','22,29',54),(88,1,'Python3 Tkinter Grid布局管理器详解','','&lt;div&gt;grid管理器是Tkinter里面最灵活的几何管理布局器。如果你不确定什么情况下从三种布局管理中选择，你至少要保证自己会使用grid。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;使用pack进行布局的话，你不得不使用一些额外的frame控件，而且还需要花费一些功夫让他们变得好看。如果你使用grid的话，你只需要对每个控件使用grid,所有的东西都会以合适的方式显示。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;注意：不要试图在一个主窗口中混合使用pack和grid。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Grid(网格)布局管理器会将控件放置到一个二维的表格里。主控件被分割成一系列的行和列，表格中的每个单元(cell)都可以放置一个控件。&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190227/63971b8d922a73d46d0aa93295d16ab0.png&quot; data-filename=&quot;img&quot; style=&quot;width: 946px;&quot;&gt;&lt;/div&gt;&lt;div&gt;sticky可以选择的值有：N/S/W/E，分别代表以单元格为容器进行上对齐/下对齐/左对齐/右对齐，&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;import tkinter as tk&lt;br&gt;win = tk.Tk()&amp;nbsp; &amp;nbsp;#创建主窗口容器&lt;br&gt;win.title(&quot;测试win&quot;) #设置窗口名称&lt;br&gt;\'\'\'窗体几何大小\'\'\'&lt;br&gt;win.geometry(&quot;500x200&quot;)&lt;br&gt;\'\'\'创建lab标签\'\'\'&lt;br&gt;# tk.Label(win,text=&quot;配置&quot;,bg=\'Azure\',font=(&quot;宋体&quot;,11)).grid(row=0) #默认column值为0，&lt;br&gt;# tk.Label(win,text=&quot;列表&quot;,bg=\'Azure\',font=(&quot;宋体&quot;,11)).grid(row=0,column=1)&lt;br&gt;# e1 = tk.Entry(win)&amp;nbsp; # 类似于HTML的 input输入框&lt;br&gt;# e2 = tk.Entry(win)&lt;br&gt;# e1.grid(row=1)&lt;br&gt;# e2.grid(row=2)&lt;br&gt;&lt;br&gt;\'\'\'用frame创建子容器\'\'\'&lt;br&gt;# frmLT = tk.Frame(width=500, height=320, bg=\'white\')&amp;nbsp; &amp;nbsp;#显示区&lt;br&gt;# frmLC = tk.Frame(width=500, height=150, bg=\'white\')&amp;nbsp; &amp;nbsp; &amp;nbsp;#输入区&lt;br&gt;# frmRT = tk.Frame(width=200, height=500)&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;#右侧区&lt;br&gt;# frmLB = tk.Frame(width=500, height=30)&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; #按钮区&lt;br&gt;# \'\'\'利用padx，pady 可以将子容器边界区分开 在插件内部填充 类似HTML padding\'\'\'&lt;br&gt;# frmLT.grid(row=0, column=0,padx=1,pady=3)&lt;br&gt;# frmLC.grid(row=1, column=0,padx=1,pady=3)&lt;br&gt;# frmRT.grid(row=0, column=1,rowspan=3,padx=2,pady=3)&lt;br&gt;# frmLB.grid(row=2, column=0)&lt;br&gt;# tk.Button(frmLB,text=&quot;确定&quot;,command=dowloacd).grid(row=0,column=0)&amp;nbsp; #command 触发事件&amp;nbsp; dowloacd为触发的调用函数&lt;br&gt;# tk.Button(frmLB,text=&quot;取消&quot;).grid(row=0,column=1)&lt;br&gt;# tk.Label(frmRT,text=&quot;联系人&quot;,bg=&quot;green&quot;,font=(&quot;宋体&quot;,13)).grid(row=0,column=2)&amp;nbsp; #bg背景色 fg字体颜色&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\r\n                                                            ',0,'2017-07-05 00:00:00','24',50),(89,1,'linux命令查看mysql数据保存的所在位置','','\n                                &lt;div&gt;使用命令：&lt;/div&gt;&lt;div&gt;1. mysql -p&amp;nbsp; &amp;nbsp; //进入数据库&lt;/div&gt;&lt;div&gt;2.show variables like \'%dir%\';&amp;nbsp; //显示存储文件信息&lt;/div&gt;&lt;pre&gt;+-----------------------------------------+----------------------------+&lt;br&gt;| Variable_name&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| Value&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;+-----------------------------------------+----------------------------+&lt;br&gt;| basedir&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| /usr/&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;| binlog_direct_non_transactional_updates | OFF&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;| character_sets_dir&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | /usr/share/mysql/charsets/ |&lt;br&gt;| datadir&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| /var/lib/mysql/&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;| ignore_db_dirs&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;| innodb_data_home_dir&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;| innodb_log_group_home_dir&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| ./&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| innodb_max_dirty_pages_pct&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | 75.000000&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;| innodb_max_dirty_pages_pct_lwm&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | 0.000000&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| innodb_tmpdir&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;| innodb_undo_directory&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| ./&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| lc_messages_dir&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| /usr/share/mysql/&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;| plugin_dir&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | /usr/lib64/mysql/plugin/&amp;nbsp; &amp;nbsp;|&lt;br&gt;| slave_load_tmpdir&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| /tmp&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;| tmpdir&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | /tmp&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;br&gt;+-----------------------------------------+----------------------------+&lt;/pre&gt;&lt;pre style=&quot;line-height: 1.42857;&quot;&gt;datadir&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| /var/lib/mysql/&amp;nbsp; &amp;nbsp;   这个就是mysql存储表数据的目录&lt;/pre&gt;\n                                                                                        ',0,'2015-04-02 00:00:00','17',44),(90,1,'Linux定时备份MySQL','','\n                                &lt;div&gt;#在目录下新建shell脚本文件 dbbak.sh&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;#!/bin/sh&lt;br&gt;mysqldump -uroot -proot fts | gzip &amp;gt; /usr/local/mysqlbakdata/fts_$(date +%Y%m%d_%H%M%S).sql.gz&lt;br&gt;find /usr/local/mysqlbakdata -mtime +7 -name &quot;*.sql.gz&quot; -exec rm -rf {} \\;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;#第一句是备份成压缩文件，第二句是删除7天前的备份文件&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;测试shell脚本是否可运行：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;在dbbak.sh最后一行输入测试语句：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;&amp;nbsp; echo 123 &amp;gt;&amp;gt;&amp;nbsp;&lt;span style=&quot;font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt; /usr/local/mysqlbakdata/test.txt&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;然后进入shell文件所在目录，运行命令 ./dbbak.sh&amp;nbsp; 看看是否有123输出到指定的文件里&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;#添加crontab定时任务 执行&amp;nbsp; crontab -e&amp;nbsp; &amp;nbsp;可以使用命令 vi /etc/crontab 查看crontab用法&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;# 下面设置为每天凌晨3点执行备份数据库的脚本&lt;/div&gt;&lt;pre&gt;* 3 * * * /usr/local/mysqlbakdata/dbbak.sh&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;crontab格式用法：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;# Example of job definition:&lt;/div&gt;&lt;div&gt;# .---------------- minute (0 - 59)&lt;/div&gt;&lt;div&gt;# |&amp;nbsp; .------------- hour (0 - 23)&lt;/div&gt;&lt;div&gt;# |&amp;nbsp; |&amp;nbsp; .---------- day of month (1 - 31)&lt;/div&gt;&lt;div&gt;# |&amp;nbsp; |&amp;nbsp; |&amp;nbsp; .------- month (1 - 12) OR jan,feb,mar,apr ...&lt;/div&gt;&lt;div&gt;# |&amp;nbsp; |&amp;nbsp; |&amp;nbsp; |&amp;nbsp; .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat&lt;/div&gt;&lt;div&gt;# |&amp;nbsp; |&amp;nbsp; |&amp;nbsp; |&amp;nbsp; |&lt;/div&gt;&lt;div&gt;# *&amp;nbsp; *&amp;nbsp; *&amp;nbsp; *&amp;nbsp; * user-name&amp;nbsp; command to be executed&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;举例如下：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;5&amp;nbsp; &amp;nbsp; &amp;nbsp; *&amp;nbsp; &amp;nbsp; &amp;nbsp; *&amp;nbsp; &amp;nbsp; &amp;nbsp; *&amp;nbsp; &amp;nbsp; *&amp;nbsp; &amp;nbsp; ls&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 指定每小时的第5分钟执行一次ls命令&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;30&amp;nbsp; &amp;nbsp; 5&amp;nbsp; &amp;nbsp; &amp;nbsp; *&amp;nbsp; &amp;nbsp; &amp;nbsp; *&amp;nbsp; &amp;nbsp; *&amp;nbsp; &amp;nbsp; ls&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 指定每天的 5:30 执行ls命令&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;30&amp;nbsp; &amp;nbsp; 7&amp;nbsp; &amp;nbsp; &amp;nbsp; 8&amp;nbsp; &amp;nbsp; &amp;nbsp; *&amp;nbsp; &amp;nbsp; *&amp;nbsp; &amp;nbsp; ls&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 指定每月8号的7：30分执行ls命令&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;30&amp;nbsp; &amp;nbsp; 5&amp;nbsp; &amp;nbsp; &amp;nbsp; 8&amp;nbsp; &amp;nbsp; &amp;nbsp; 6&amp;nbsp; &amp;nbsp; *&amp;nbsp; &amp;nbsp; ls&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 指定每年的6月8日5：30执行ls命令&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;30&amp;nbsp; &amp;nbsp; 6&amp;nbsp; &amp;nbsp; &amp;nbsp; *&amp;nbsp; &amp;nbsp; &amp;nbsp; *&amp;nbsp; &amp;nbsp; 0&amp;nbsp; &amp;nbsp; ls&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 指定每星期日的6:30执行ls命令[注：0表示星期天，1表示星期1，&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;#重启crontab （centos7命令重启）&lt;/div&gt;&lt;pre&gt;systemctl restart crond&lt;/pre&gt;\n                                                                                        ',0,'2015-03-03 00:00:00','17',65),(91,1,'在linux上安装svn服务器，windows客户端提交文件到指定的仓库','','\n                                \n                                \n                                \n                                \n                                \n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;用 yum install subversion 安装了SVN&amp;nbsp; (一般安装在 /var/svn )&lt;/p&gt;&lt;p&gt;然后创建了 /var/svn/svntest 目录&lt;/p&gt;&lt;p&gt;在使用命令&amp;nbsp;&lt;/p&gt;&lt;pre&gt;svnadmin create /var/svn/svntest&amp;nbsp;&lt;/pre&gt;&lt;p&gt;# 这条命令是创建一个版本库或仓库，可以理解为一个项目目录名为svntest，以后commit提交文件就会提交到这个目录下，但是在服务器端你是看不到提交的文件的。&lt;/p&gt;&lt;p&gt;#把文件上传到SVN版本库后,上传的文件不再以文件原来的格式存储,而是被svn以它自定义的格式压缩成版本库数据,存放在版本库中。&lt;/p&gt;&lt;p&gt;#如果是FSFS格式，这些数据存放在版本库的db目录中，里面的revs和revprops分别存放着每次提交的差异数据和日志等信息。&lt;/p&gt;&lt;p&gt;#SVN在服务器端的存储方式和客户端是不一样的，所以在服务器端是看不到源文件的。服务器端有两种存储方式FSFS和BDB，目前默认都是FSFS。&lt;/p&gt;&lt;p&gt;此时，svntest目录下生成一下文件目录：&lt;/p&gt;&lt;pre&gt;conf&amp;nbsp; db&amp;nbsp; format&amp;nbsp; hooks&amp;nbsp; locks&amp;nbsp; README.txt&lt;/pre&gt;&lt;p&gt;然后依次配置了一下文件：&lt;/p&gt;&lt;pre&gt;vim passwd&lt;br&gt;[users]&lt;br&gt;test=123456&amp;nbsp;&amp;nbsp;#帐号=密码&lt;br&gt;vim authz&amp;nbsp;&lt;br&gt;[/]&amp;nbsp; &amp;nbsp; &amp;nbsp;# 表示svntest目录下所有文件&lt;br&gt;test=rw #test用户 对/var/svn/svntest下所有文件具有可读可写权限&lt;br&gt;*=&amp;nbsp; #其它用户均无任何权限，最后一行*=很重要不能少。&lt;br&gt;vim svnserve.conf&amp;nbsp;&lt;br&gt;打开下面的5个注释&lt;br&gt;anon-access = none #匿名用户禁止读写&lt;br&gt;auth-access = write #授权用户可写&lt;br&gt;password-db = passwd #使用哪个文件作为账号文件&lt;br&gt;authz-db = authz #使用哪个文件作为权限文件&lt;br&gt;realm = svntest&amp;nbsp; # 改不改好像都一样，没具体尝试过&lt;/pre&gt;&lt;p&gt;然后启动svn服务&amp;nbsp;&lt;/p&gt;&lt;pre&gt;systemctl start svnserve.service&amp;nbsp; &amp;nbsp;#centos7命令&lt;/pre&gt;&lt;p&gt;客户端的使用：&lt;/p&gt;&lt;p&gt;1.客户端svn地址填写：svn://ip/svntest&amp;nbsp; 输入刚刚添加的账号密码即可使用svn下载提交文件了&lt;/p&gt;&lt;p&gt;2.在本地可以新建一个目录（比如svntest），然后使用checkout就可以下载svn://ip/svntest这个仓库下的文件了&lt;/p&gt;&lt;p&gt;3.要想把本地的代码提交到svn://ip/svntest这个仓库下，需要进入到代码存放的目录中，然后import就可以把本地文件commit到指定仓库了&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;svn仓库代码与web项目代码同步更新：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;使用post-commit 实现同步代码&lt;/p&gt;&lt;p&gt;代码同步需要使用到/var/svn/svntest/hooks文件目录下的post-commit勾子文件，在hooks下很多tmpl文件，这些文件都是勾子的模板来的，&lt;/p&gt;&lt;p&gt;如果需要使用的时候copy 一份去掉.tmpl后缀便可使用&lt;/p&gt;&lt;pre&gt;cp post-commit.tpml post-commit&lt;/pre&gt;&lt;p&gt;编辑post-commit:(&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;注意 “=” 两边不能有空格，否则报错&lt;/span&gt;)&lt;/p&gt;&lt;pre&gt;export LANG=en_US.UTF-8&lt;br&gt;SVN=/usr/bin/svn     # 使用 which svn 查看路径&lt;br&gt;WEB_PATH=/var/www/yxadmin&lt;br&gt;$SVN&amp;nbsp; update $WEB_PATH --username svn****date --password svn****&amp;nbsp; --no-auth-cache&lt;/pre&gt;&lt;p&gt;重启一下svn服务：&lt;/p&gt;&lt;pre&gt;systemctl restart svnserve.service&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;第一次把仓库的代码同步到指定目录中通过一下命令实现（&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;/var/www/yxadmin  该目录必须是干净的目录&lt;/span&gt;）,&lt;/p&gt;&lt;pre&gt;svn co svn://localhost/svntest/&amp;nbsp; /var/www/yxadmin --username test    # 可以理解为web项目与仓库指定的目录建立关系&lt;/pre&gt;&lt;p&gt;输入密码即可把svntest仓库下的代码都同步到/var/www/yxadmin目录下&lt;/p&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;                                                                                                                                                                        ',0,'2016-03-02 00:00:00','17',47),(92,1,'scrapy同一个爬虫里包含不同item，pipelines文件编写','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;items.py文件item类的名字对应pipelines.py文件中类的名字 如：AItem -&amp;gt;APipeline 、BItem -&amp;gt; BPipeline&lt;/p&gt;&lt;p&gt;这个pipeline类有优先级之分，可以在setting.py文件设置，数字越小优先级越高。&lt;/p&gt;&lt;p&gt;当Aitem传输时会传给Apipeline、Bpipeline中优先级高的，假设Bpipeline高，Aitem传入会出错，所以此时需要在pipelines.py文件里做判断&lt;/p&gt;&lt;p&gt;在pipeline.py文件中首先应该导入items文件里的不同的item类&lt;/p&gt;&lt;pre&gt;from myscrapy.items import AItem&lt;br&gt;from myscrapy.items import BItem&lt;br&gt;from myscrapy.items import CItem&lt;/pre&gt;&lt;p&gt;#然后在process_item方法里通过if判断方式进行items类别筛选，用 isinstance可以判断对象的类型&lt;/p&gt;&lt;pre&gt;def process_item(self, item, spider):&lt;br&gt;&amp;nbsp; &amp;nbsp; # 写入json文件&lt;br&gt;&amp;nbsp; &amp;nbsp; if isinstance(item, AItem):&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; print 1&amp;nbsp; （处理数据1）&lt;br&gt;&amp;nbsp; &amp;nbsp; elif isinstance(item, BItem):&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; print 2&amp;nbsp; （处理数据2）&lt;br&gt;&amp;nbsp; &amp;nbsp; elif isinstance(item, CItem):&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; print 3&amp;nbsp; （处理数据3）&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;',0,'2017-07-05 00:00:00','24',48),(93,1,'GIT的工作区和暂存区详解','','\r\n                                \r\n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;工作区（Working Directory）&lt;/p&gt;&lt;p&gt;就是.git(git版本库)隐藏目录所在的区，也就是我们存放代码的目录：&lt;/p&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190303/e1abc3348dd5db1d6fe3f5e4a6e0c33b.png&quot; data-filename=&quot;img&quot; style=&quot;width: 518px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;版本库（Repository）&lt;/div&gt;&lt;div&gt;工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190303/07e6849b18b9996184998d15dcc03626.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 458px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;往Git版本库里添加的时候，是分两步执行的：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190303/11fe5e94baf1447754239dee01ea028f.png&quot; data-filename=&quot;img&quot; style=&quot;width: 381px;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。（也可以切换分支，提交到指定的分支上去。命令：&lt;span style=&quot;background-color: rgb(245, 245, 245); font-family: &amp;quot;Courier New&amp;quot;, sans-serif; font-size: 12px; white-space: pre-wrap;&quot;&gt;git checkout -b 分支名&lt;/span&gt;）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;比如我们对readme.txt做个修改，加上一行内容：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;Git has a mutable index called stage.&lt;/pre&gt;&lt;p&gt;然后，在工作区新增一个LICENSE文本文件（内容随便写）。&lt;/p&gt;&lt;p&gt;先用git status查看一下状态：&lt;/p&gt;&lt;pre&gt;$ git status&lt;br&gt;On branch master&lt;br&gt;Changes not staged for commit:&lt;br&gt;&amp;nbsp; (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)&lt;br&gt;&amp;nbsp; (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)&lt;br&gt;&amp;nbsp; &amp;nbsp; modified:&amp;nbsp; &amp;nbsp;readme.txt&lt;br&gt;Untracked files:&lt;br&gt;&amp;nbsp; (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed)&lt;br&gt;&amp;nbsp; &amp;nbsp; LICENSE&lt;br&gt;no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)&lt;/pre&gt;&lt;p&gt;Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。&lt;/p&gt;&lt;p&gt;现在，使用两次命令git add，把readme.txt和LICENSE都添加后，&lt;/p&gt;&lt;pre&gt;git add&amp;nbsp; readme.txt&amp;nbsp; LICENSE&lt;/pre&gt;&lt;p&gt;用git status再查看一下：&lt;/p&gt;&lt;pre&gt;$ git status&lt;br&gt;On branch master&lt;br&gt;Changes to be committed:&lt;br&gt;&amp;nbsp; (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)&lt;br&gt;&amp;nbsp; &amp;nbsp; new file:&amp;nbsp; &amp;nbsp;LICENSE&lt;br&gt;&amp;nbsp; &amp;nbsp; modified:&amp;nbsp; &amp;nbsp;readme.txt&lt;/pre&gt;&lt;p&gt;&amp;nbsp;现在，暂存区的状态就变成这样了：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190303/f5d1cbdd9ed41f3527a410f829978f1c.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 458px;&quot;&gt;&lt;/p&gt;&lt;p&gt;（&lt;span style=&quot;background-color: rgb(255, 255, 255); color: rgb(255, 0, 0); font-weight: bold;&quot;&gt;注&lt;/span&gt;：如果是误把文件添加到暂存区的话，可以使用 &lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;git rm --cache readme.txt&lt;/span&gt; 把在&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;暂存区&lt;/span&gt;的文件删除掉，也可以用&lt;span style=&quot;background-color: rgb(250, 250, 250); color: rgb(221, 0, 85); font-family: Consolas, monospace, serif; font-size: 12px; white-space: nowrap;&quot;&gt;git reset HEAD &amp;lt;file&amp;gt;&amp;nbsp;&lt;/span&gt;&lt;font face=&quot;Consolas, monospace, serif&quot;&gt;&lt;span style=&quot;font-size: 12px; white-space: nowrap;&quot;&gt;把暂存区的修改撤销掉（unstage），重新放回工作区；&lt;/span&gt;&lt;/font&gt;而&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;git rm -rf&amp;nbsp; readme.txt &lt;/span&gt;是把&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;暂存区&lt;/span&gt;和&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;工作区&lt;/span&gt;的文件都删除掉）&lt;/p&gt;&lt;p&gt;所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。&lt;/p&gt;&lt;pre&gt;$ git commit -m &quot;understand how stage works&quot;&lt;br&gt;[master e43a48b] understand how stage works&lt;br&gt;&amp;nbsp;2 files changed, 2 insertions(+)&lt;br&gt;&amp;nbsp;create mode 100644 LICENSE&lt;/pre&gt;&lt;p&gt;&amp;nbsp;一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：&lt;/p&gt;&lt;pre&gt;$ git status&lt;br&gt;On branch master&lt;br&gt;nothing to commit, working tree clean&lt;/pre&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(102, 102, 102); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 14px; white-space: pre-wrap;&quot;&gt;现在版本库变成了这样，暂存区就没有任何内容了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190303/e42b01c6a55079df938a8a26c6de47f3.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 463px;&quot;&gt;&lt;span style=&quot;color: rgb(102, 102, 102); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 14px; white-space: pre-wrap;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(102, 102, 102); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 14px; white-space: pre-wrap;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;                                                        ',0,'2016-08-09 00:00:00','32',56),(94,1,'GIT管理修改删除文件的操作','','\r\n                                &lt;div&gt;Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;修改操作的情况：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1.当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是在你使用git add 后，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把第一次加入暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交，需要再次使用git add。&lt;/div&gt;&lt;div&gt;工作区和版本库里的文件对比：&lt;span style=&quot;background-color: rgb(255, 255, 255); color: rgb(255, 0, 0);&quot;&gt;git diff HEAD -- readme.txt&lt;/span&gt;命令可以查看工作区和版本库里面最新版本的区别：&lt;/div&gt;&lt;pre&gt;$ git diff HEAD -- readme.txt&amp;nbsp;&lt;br&gt;diff --git a/readme.txt b/readme.txt&lt;br&gt;index 76d770f..a9c5755 100644&lt;br&gt;--- a/readme.txt&lt;br&gt;+++ b/readme.txt&lt;br&gt;@@ -1,4 +1,4 @@&lt;br&gt;&amp;nbsp;Git is a distributed version control system.&lt;br&gt;&amp;nbsp;Git is free software distributed under the GPL.&lt;br&gt;&amp;nbsp;Git has a mutable index called stage.&lt;br&gt;-Git tracks changes.&lt;br&gt;+Git tracks changes of files.    // 前面的&quot;+&quot;表示工作区的改动内容&lt;/pre&gt;&lt;p&gt;2.如果一个文件已经被提交到版本库，要是删错文件了，那么你永远不用担心误删，因为版本库里还有呢。但是要小心，你只能恢复文件到最新版本，所以可以很轻松地把误删的文件恢复到最新版本&lt;/p&gt;&lt;pre&gt;git checkout -- test.txt&lt;/pre&gt;&lt;p&gt;&lt;span style=&quot;background-color: rgb(255, 255, 255); color: rgb(255, 0, 0);&quot;&gt;git checkout&lt;/span&gt;其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;3.如果是误把文件添加到暂存区的话，可以使用 &lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;git rm --cache readme.txt &lt;/span&gt;把在暂存区的文件删除掉，也可以用&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/span&gt; 把暂存区的修改撤销掉（unstage），重新放回工作区；而&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;git rm -rf&amp;nbsp; readme.txt &lt;/span&gt;是把暂存区和工作区的文件都删除掉）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;\r\n                                                                                        ',0,'2016-07-05 00:00:00','32',50),(95,1,'GIT 关联本地仓库与github上的远程仓库','','\r\n                                \r\n                                &lt;p&gt;如果你已经在本地创建了一个Git仓库后，又想与在GitHub上创建的仓库关联起来，方便本地修改后提交到github远程仓库上，你可以现在GitHub上创建仓库（创建方法省略...）&lt;/p&gt;&lt;p&gt;假设在GitHub上我们创建了study-git仓库，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库&lt;/p&gt;&lt;p&gt;本地创建仓库可以在指定目录文件下使用：&lt;/p&gt;&lt;pre&gt;git init&amp;nbsp;&lt;/pre&gt;&lt;p&gt;&lt;span style=&quot;font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 14px; white-space: pre-wrap;&quot;&gt;瞬间Git就把仓库建好了,并生成一个.git隐藏文件（即git版本库文件）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 14px; white-space: pre-wrap;&quot;&gt;在本地的study-git仓库下运行命令：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;span style=&quot;font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif; font-size: 14px; white-space: pre-wrap;&quot;&gt;$ git remote add origin  https://github.com/gul/git-study.git&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。&lt;/p&gt;&lt;p&gt;下一步，就可以把本地库的所有内容推送到远程库上：&lt;/p&gt;&lt;pre&gt;$ git push -u origin master&lt;br&gt;Counting objects: 20, done.&lt;br&gt;Delta compression using up to 4 threads.&lt;br&gt;Compressing objects: 100% (15/15), done.&lt;br&gt;Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.&lt;br&gt;Total 20 (delta 5), reused 0 (delta 0)&lt;br&gt;remote: Resolving deltas: 100% (5/5), done.&lt;br&gt;To github.com:michaelliao/learngit.git&lt;br&gt;&amp;nbsp;* [new branch]&amp;nbsp; &amp;nbsp; &amp;nbsp; master -&amp;gt; master&lt;br&gt;Branch \'master\' set up to track remote branch \'master\' from \'origin\'.&lt;/pre&gt;&lt;p&gt;把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。&lt;/p&gt;&lt;p&gt;由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解决每次提交都要输入账号密码：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;第一步：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在git的安装目录的bin下，双击bash.exe，在命令行中输入（一直enter就行）&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;$ ssh-keygen -t rsa -C 122....71@qq.com&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;此时还在C:\\Users\\Administrator\\.ssh 目录下会生成&amp;nbsp;id_rsa.pub，直接把里面的内容复制到GitHub上。在setting-&amp;gt;add new ssh key&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;第二步：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;font face=&quot;Helvetica Neue, Helvetica, Verdana, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;把https调整为ssh的方式就可以了,进入到工作目录，使用&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;git remote -v&lt;/span&gt; 可以看到当前使用的是https方式&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190303/bc21ff5588153c43ff8bd110fbaca702.png&quot; data-filename=&quot;img&quot; style=&quot;width: 414px;&quot;&gt;&lt;font face=&quot;Helvetica Neue, Helvetica, Verdana, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;h4&gt;&lt;br&gt;添加新的git方式的origin&amp;nbsp;&lt;/h4&gt;&lt;/p&gt;&lt;pre&gt;$ git remote add origin git@github.com:g....2/git-study.git&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;再次使用&amp;nbsp;&lt;span style=&quot;font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Verdana, Arial, sans-serif; font-size: 14px;&quot;&gt;git remote -v&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Verdana, Arial, sans-serif; font-size: 14px;&quot;&gt;$ git remote -v&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Verdana, Arial, sans-serif; font-size: 14px;&quot;&gt;origin&amp;nbsp; git@github.com:gulang12/git-study.git (fetch)&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Verdana, Arial, sans-serif; font-size: 14px;&quot;&gt;origin&amp;nbsp; git@github.com:gulang12/git-study.git (push)&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;现在再添加就不会提示需要输入账号密码了&lt;/div&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;                                                        ',0,'2016-08-02 00:00:00','32',25),(96,1,'GIT创建与合并分支详解','','&lt;p&gt;在git中每次提交都会生成一个节点，Git都把它们串成一条时间线，这条时间线就是一个分支，在最开始时，git只有一条分支，即主分支（master）。HEAD严格来说不是指向提交，而是指向当前分支，分支才是指向提交的，所以，HEAD指向的就是当前分支。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190304/4f4deff75bd02799576f1f3c350b9254.png&quot; data-filename=&quot;img&quot; style=&quot;width: 358px;&quot;&gt;&lt;/p&gt;&lt;p&gt;每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长：&lt;/p&gt;&lt;p&gt;当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交（在未向新的分支做提交之前，一般默认指向当前master分支所指的提交节点上），再把HEAD指向dev，就表示当前分支在dev上（创建并切换到新分支）：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190304/994d05bc21b707ad6b3eebac560fefb8.png&quot; data-filename=&quot;img&quot; style=&quot;width: 511px;&quot;&gt;&lt;/p&gt;&lt;p&gt;此时这条时间线上现在有两个分支了，并把当前分支指向了新分支（dev）&lt;/p&gt;&lt;p&gt;不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190304/66012657761588d4c45cbbf673cf4ec1.png&quot; data-filename=&quot;img&quot; style=&quot;width: 518px;&quot;&gt;&lt;/p&gt;&lt;p&gt;假如我们在dev上的工作完成了，就可以把dev合并到master上。最简单的方法，就是直接把master指向dev的当前提交，就完成了合并:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190304/a70b9eee50703e713190e1d9c2195e05.png&quot; data-filename=&quot;img&quot; style=&quot;width: 488px;&quot;&gt;&lt;/p&gt;&lt;p&gt;举例说明：&lt;/p&gt;&lt;p&gt;创建dev分支，然后切换到dev分支：&lt;/p&gt;&lt;pre&gt;$ git checkout -b dev&lt;br&gt;Switched to a new branch \'dev\'&lt;/pre&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;git checkout&lt;/span&gt;命令加上&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;-b&lt;/span&gt;参数表示创建并切换，相当于以下两条命令：&lt;/p&gt;&lt;pre&gt;$ git branch dev&lt;br&gt;$ git checkout dev&lt;br&gt;Switched to branch \'dev\'&lt;/pre&gt;&lt;p&gt;然后，用git branch命令查看当前分支（git branch -a 查看远程和本地分支）：&lt;/p&gt;&lt;pre&gt;$ git branch&lt;br&gt;* dev&lt;br&gt;&amp;nbsp; master&lt;/pre&gt;&lt;p&gt;git branch命令会列出当前所有分支，当前分支前面会标一个*号。&lt;/p&gt;&lt;p&gt;然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：&lt;/p&gt;&lt;pre&gt;Creating a new branch is quick.&lt;/pre&gt;&lt;p&gt;然后提交（必须是切换到dev分支上）：&lt;/p&gt;&lt;pre&gt;$ git add readme.txt&amp;nbsp;&lt;br&gt;$ git commit -m &quot;branch test&quot;&lt;br&gt;[dev b17d20e] branch test&lt;br&gt;&amp;nbsp;1 file changed, 1 insertion(+)&lt;/pre&gt;&lt;p&gt;现在，dev分支的工作完成，我们就可以切换回master分支：&lt;/p&gt;&lt;pre&gt;$ git checkout master&lt;br&gt;Switched to branch \'master\'&lt;/pre&gt;&lt;p&gt;切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：&lt;/p&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190304/0b3042a0ce9ec4675c4d180329fe0137.png&quot; data-filename=&quot;img&quot; style=&quot;width: 444px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;现在，我们把dev分支的工作成果合并到master分支上(切换当前分支到master分支)：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;$ git merge dev&lt;br&gt;Updating d46f35e..b17d20e&lt;br&gt;Fast-forward&lt;br&gt;&amp;nbsp;readme.txt | 1 +&lt;br&gt;&amp;nbsp;1 file changed, 1 insertion(+)&lt;/pre&gt;&lt;p&gt;git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。&lt;/p&gt;&lt;p&gt;注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。&lt;/p&gt;&lt;p&gt;当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。&lt;/p&gt;&lt;p&gt;合并完成后，就可以放心地删除dev分支了：&lt;/p&gt;&lt;pre&gt;$ git branch -d dev&lt;br&gt;Deleted branch dev (was b17d20e).&lt;/pre&gt;&lt;p&gt;总结：&lt;/p&gt;&lt;pre&gt;查看分支：git branch&lt;br&gt;创建分支：git branch &amp;lt;name&amp;gt;&lt;br&gt;切换分支：git checkout &amp;lt;name&amp;gt;&lt;br&gt;创建+切换分支：git checkout -b &amp;lt;name&amp;gt;&lt;br&gt;合并某分支到当前分支：git merge &amp;lt;name&amp;gt;&lt;br&gt;删除分支：git branch -d &amp;lt;name&amp;gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;',0,'2016-08-10 00:00:00','32',54),(97,1,'总结收藏的41个JavaScript实用技巧','','&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1392295&quot; target=&quot;_blank&quot;&gt;https://cloud.tencent.com/developer/article/1392295&lt;/a&gt;\r\n                                                            &lt;/p&gt;',0,'2017-06-06 00:00:00','22',36),(98,1,'Apache与Nginx的优缺点比较','','&lt;div&gt;1、nginx相对于apache的优点：&amp;nbsp;&lt;/div&gt;&lt;div&gt;轻量级，同样起web 服务，比apache 占用更少的内存及资源&amp;nbsp;&lt;/div&gt;&lt;div&gt;抗并发，nginx 处理请求是异步非阻塞的，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能&amp;nbsp;&lt;/div&gt;&lt;div&gt;反向代理功能和静态文件缓存&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.apache 相对于nginx 的优点：&amp;nbsp;&lt;/div&gt;&lt;div&gt;rewrite ，比nginx 的rewrite 强大&amp;nbsp;&lt;/div&gt;&lt;div&gt;模块超多，基本想到的都可以找到&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;4、最核心的区别在于apache是同步多进程模型，一个连接对应一个进程；nginx是异步的，多个连接（万级别）可以对应一个进程&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;概括：&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 一般来说，需要性能的web 服务，用nginx 。如果不需要性能只求稳定，那就apache 吧。后者的各种功能模块实现得比前者，例如ssl 的模块就比前者好，可配置项多。这里要注意一点，网络IO 模型是nginx 处理性能高的根本理由，但并不是所有的情况下都是epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的select 模型或许比epoll 更高性能。当然，这只是根据网络IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;select/poll这两个多路复用实现的特点是：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;01.每次调用select和poll都要把用户关心的事件集合（select为readfds,writefds,exceptfds集合，poll为fds结构体数组）从用户空间到内核空间。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;02.如果某一时间段内，只有少部分事件是活跃的（用户关心的事件集合只有少部分事件会发生），会浪费cpu在对无效事件轮询上，使得效率较低，比如，用户关心1024个tcp socket的读事件，当是，每次调用select或poll时只有1个tcp链接是活跃的，那么对其他1023个事件的轮询是没有必要的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;select支持的文件描述符数量较小，一般只有1024，poll虽然没有这个限制，但基于上面两个原因，poll和select存在同样一个缺点，就是包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而且不论这些文件描述符是否就绪，每次都会轮询所有描述符的状态，使得他们的开销随着文件描述符数量的增加而线性增大。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select和poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;epoll针对这几个缺点进行了改进，不再像select和poll那样，每次调用select和poll都把描述符集合拷贝到内核空间，而是一次注册永久使用；另一方面，epoll也不会对每个描述符都轮询时间是否发生，而是只针对事件已经发生的文件描述符进行资源抢占（因为同一个描述符资源（如可读或可写）可能阻塞了多个进程，调用epoll的进程需要与这些进程抢占该相应资源）。下面记录一下自己对epoll的学习和理解。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\r\n                                                            ',0,'2016-05-02 00:00:00','25,26',42),(99,1,'nginx 配置文件中对优化比较有作用的几项：','','&lt;div&gt;1.开启利用多核cpu的配置。nginx默认是没有开启利用多核cpu的配置的，cpu是任务处理，当计算最费时的资源的时候，cpu核使用上的越多，性能就越好。需要通过增加worker_cpu_affinity配置参数来充分利用多核cpu(可以通过命令lscpu 查看cpu数)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;nginx 进程数，建议按照cpu 数目来指定，一般为它的倍数 (如,2个四核的cpu计为8个进程)。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;worker_processes&amp;nbsp; &amp;nbsp; &amp;nbsp;8;&lt;/div&gt;&lt;div&gt;worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;&lt;/div&gt;&lt;div&gt;解释：worker_cpu_affinity配置是写在 xxx/nginx/nginx.conf里面的；2核是 01，四核是0001，8核是00000001，有多少个核，就有几位数，1表示该内核开启，0表示该内核关闭。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.nginx 进程打开的最多文件描述符数目&lt;/div&gt;&lt;div&gt;理论值应该是最多打开文件数（ulimit -n）与nginx 进程数相除，但是nginx 分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。(通过ulimit -n 查看)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.use epoll; 使用epoll 的I/O 模型&lt;/div&gt;&lt;div&gt;&amp;nbsp;epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select和poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;epoll针对这几个缺点进行了改进，不再像select和poll那样，每次调用select和poll都把描述符集合拷贝到内核空间，而是一次注册永久使用；另一方面，epoll也不会对每个描述符都轮询时间是否发生，而是只针对事件已经发生的文件描述符进行资源抢占（因为同一个描述符资源（如可读或可写）可能阻塞了多个进程，调用epoll的进程需要与这些进程抢占该相应资源）。下面记录一下自己对epoll的学习和理解。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;4. worker_connections 65535;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;每个进程允许的最多连接数， 理论上每台nginx 服务器的最大连接数为worker_processes*worker_connections。&lt;/div&gt;&lt;div&gt;5. keepalive_timeout 60;&lt;/div&gt;&lt;div&gt;&amp;nbsp; keepalive 超时时间。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;6. client_header_buffer_size 4k;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;分页大小可以用命令getconf PAGESIZE 取得。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;7. open_file_cache max=65535 inactive=60s;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这个将为打开文件指定缓存，默认是没有启用的，max 指定缓存数量，建议和打开文件数一致，inactive 是指经过多长时间文件没被请求后删除缓存。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;8. open_file_cache_valid 80s;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这个是指多长时间检查一次缓存的有效信息。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;9. open_file_cache_min_uses 1;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;open_file_cache 指令中的inactive 参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive 时间内一次没被使用，它将被移除。&lt;/div&gt;\r\n                                                            ',0,'2017-07-06 00:00:00','26',54),(100,1,'Linux服务器时间同步','','&lt;div&gt;Linux服务器运行久时，系统时间就会存在一定的误差，一般情况下可以使用date命令进行时间设置&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;date命令：&lt;/div&gt;&lt;div&gt;date :查看当前时间，结果如下：Tue Mar 4 01:36:45 CST 2014&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;设置时间&lt;/div&gt;&lt;div&gt;date -s 09:38:40 :设置当前时间，结果如下：Tue Mar 4 09:38:40 CST 2014（设置日期：date -s 11/03/2009）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;也可以使用ntpdate进行时间同步。&lt;/div&gt;&lt;div&gt;ntpdate命令：&lt;/div&gt;&lt;div&gt;ntpdate -u 210.72.145.44 :网络时间同步命令&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;注意：若不加上-u参数， 会出现以下提示：no server suitable for synchronization found&lt;/div&gt;&lt;div&gt;-u：从man ntpdate中可以看出-u参数可以越过防火墙与主机同步；&lt;/div&gt;&lt;div&gt;210.72.145.44：中国国家授时中心的官方服务器。&lt;/div&gt;&lt;div&gt;ntp常用服务器：&lt;/div&gt;&lt;div&gt;中国国家授时中心：210.72.145.44&lt;/div&gt;&lt;div&gt;NTP服务器(上海) ：ntp.api.bz&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\r\n                                                            ',0,'2016-07-06 00:00:00','17',39),(101,1,'MyISAM锁表解析及应对方法','','&lt;div&gt;MyISAM适合于读频率远大于写频率这一情况。而我目前的应用可能会出现在某一时段读写频率相当。大致如下：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;一个客户端发出需要长时间运行的SELECT&lt;/div&gt;&lt;div&gt;其他客户端在同一个表上发出INSERT或者UPDATE，这个客户将等待SELECT完成&lt;/div&gt;&lt;div&gt;另一个客户在同一个表上发出另一个SELECT；因UPDATE或INSERT比SELECT有更高有优先级，该SELECT将等待UPDATE或INSERT完成，也将等待第一个SELECT完成&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 也就是说对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM表的读操作与写操作之间，以及写操作之间是串行的！&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write&lt;/div&gt;&lt;div&gt;Lock）。MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 所以对MyISAM表进行操作，会有以下情况：&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; a、对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; b、对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 由于MySQL认为写请求一般比读请求要重要，所以如果有读写请求同时进行的话，MYSQL将会优先执行写操作。这样MyISAM表在进行大量的更新操作时（特别是更新的字段中存在索引的情况下），会造成查询操作很难获得读锁，从而导致查询阻塞。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 解决方案大概有如下几种：&lt;/div&gt;&lt;div&gt;MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。&lt;/div&gt;&lt;div&gt;0 不允许并发操作&lt;/div&gt;&lt;div&gt;1 如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。&lt;/div&gt;&lt;div&gt;2 无论MyISAM表中有没有空洞，都允许在表尾并发插入记录&lt;/div&gt;&lt;div&gt;使用--low-priority-updates启用mysqld。这将给所有更新(修改)一个表的语句以比SELECT语句低的优先级。在这种情况下，在先前情形的最后的SELECT语句将在INSERT语句前执行。&lt;/div&gt;&lt;div&gt;为max_write_lock_count设置一个低值，使得在一定数量的WRITE锁定后，给出READ锁定&lt;/div&gt;&lt;div&gt;使用LOW_PRIORITY属性给于一个特定的INSERT，UPDATE或DELETE较低的优先级&lt;/div&gt;&lt;div&gt;使用HIGH_PRIORITY属性给于一个特定的SELECT&lt;/div&gt;&lt;div&gt;使用INSERT DELAYED语句&lt;/div&gt;\r\n                                                            ',0,'2016-06-16 00:00:00','11',62),(102,1,'MySQL缓冲查询和非缓冲查询','','&lt;div&gt;MySQL的客户端有两种类型的查询：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;缓冲查询：将接收查询的结果并把他们存储在客户端的缓存中，而且接下来获取行记录的请求仅仅从本地内获取。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;优点：可以在结果集中自由地移动“当前行”的指针，这样很容易找到，因为结果是存在客户端的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;缺点：需要额外的内存来存储这些结果集，而且需要大量的内存，另外，php中用来运行查询的函数会一直到所有的结果都接收才会返回值。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;无缓冲查询：会限制你通过严格的顺序访问查询结果。但他不需要额外的内存来存储整个结果集。你可以在MySQL服务器开始返回值的时候就开始获取而处理或显示数据行。当使用无缓冲结果集时，必须使用mysql_fetch_row函数获取所以的数据行，或者在给服务器发送其他任何命令前用mysql_free_result函数关闭结果集。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;哪种类型的查询好？最好的根据是具体情况而定，无缓冲查询在结果集巨大的时为你节省大量的临时内存，而且查询不需要排序时，php在MySQL数据库实际上还在处理时就可以获得第一个数据行。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;缓存查询便于寻找，它可以提供一个全面的寻找加速。因为每一个单独的查询的都会快读结束，mysql快速的获取结果集并存放在内存中，而不是在处理PHP代码时保持查询为可用的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;另外一个无缓冲查询的限制是在所有的数据行都被读取或者结果集用mysqli_free_result释放之前，你将无法向服务器发送任何命令。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;PHP MySQL查询(mysqli,pdo_mysql)默认使用缓冲模式.&lt;/div&gt;&lt;div&gt;也就是说查询结果将一次性从MySQL传输到PHP进程内存中,&lt;/div&gt;&lt;div&gt;这时可以统计结果集的行数,以及移动结果集指针.&lt;/div&gt;&lt;div&gt;缓冲模式下,如果结果集很大,那么PHP进程也会占用大量的内存,&lt;/div&gt;&lt;div&gt;直到结果集被unset或者free.&lt;/div&gt;&lt;div&gt;store_result也用于缓冲模式,所有结果一次性存储到PHP进程中:&lt;/div&gt;&lt;div&gt;mysqli::store_result&lt;/div&gt;&lt;div&gt;mysqli_stmt::store_result&lt;/div&gt;&lt;div&gt;如果PHP的MySQL数据库驱动底层用的是libmysqlclient,那么memory_limit不能统计到结果集占用的内存,&lt;/div&gt;&lt;div&gt;除非结果集已经赋值给PHP变量,如果底层使用mysqlnd作为驱动时则可以统计到(PHP从5.4开始默认底层默认使用mysqlnd).&lt;/div&gt;&lt;div&gt;无缓冲模式下执行的查询将会返回一个resource资源引用,位于MySQL查询结果等待PHP获取.&lt;/div&gt;&lt;div&gt;无缓冲模式下,PHP进程占用的内存很少,但会增大MySQL服务器的负载.&lt;/div&gt;&lt;div&gt;在PHP取回所有结果前,在当前数据库连接下不能发送其他的查询请求.&lt;/div&gt;&lt;div&gt;无缓冲查询简称use_result.&lt;/div&gt;&lt;div&gt;总结:&lt;/div&gt;&lt;div&gt;当结果集不大时,或者需要在读取所有行前获取结果集行数时,使用缓冲查询(默认).&lt;/div&gt;&lt;div&gt;当结果集很大时,使用无缓冲查询,避免PHP进程占用大量的内存.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;$rs = $mysqli-&amp;gt;query(&quot;SELECT * FROM City&quot;, MYSQLI_USE_RESULT);&lt;/div&gt;&lt;div&gt;$pdo-&amp;gt;setAttribute(&lt;/div&gt;&lt;div&gt;PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false);&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\r\n                                                            ',0,'2017-06-15 00:00:00','11',55),(103,1,'EventSource实现页面消息推送 与 websocket 的区别','','&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;WebSocket&lt;/div&gt;&lt;div&gt;是什么： WebSocket是一种通讯手段，基于TCP协议，默认端口也是80和443，协议标识符是ws（加密为wss），它实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端也能主动向客户端发送数据，不受跨域的限制。&lt;/div&gt;&lt;div&gt;有什么用： WebSocket用来解决http不能持久连接的问题，因为可以双向通信所以可以用来实现聊天室，以及其他由服务端主动推送的功能例如 实时天气、股票报价、余票显示、消息通知等。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;EventSource&lt;/div&gt;&lt;div&gt;是什么： EventSource的官方名称应该是 Server-sent events（缩写SSE）服务端派发事件，EventSource 基于http协议只是简单的单项通信，实现了服务端推的过程客户端无法通过EventSource向服务端发送数据。喜闻乐见的是ie并没有良好的兼容当然也有解决的办法比如 npm install event-source-polyfill。虽然不能实现双向通信但是在功能设计上他也有一些优点比如可以自动重连接,event IDs,以及发送随机事件的能力（WebSocket要借助第三方库比如socket.io可以实现重连。）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;有什么用： 因为受单项通信的限制EventSource只能用来实现像股票报价、新闻推送、实时天气这些只需要服务器发送消息给客户端场景中。EventSource的使用更加便捷这也是他的优点。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;WebSocket &amp;amp; EventSource 的区别&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1.WebSocket基于TCP协议，EventSource基于http协议。&lt;/div&gt;&lt;div&gt;2.EventSource是单向通信，而websocket是双向通信。&lt;/div&gt;&lt;div&gt;3.EventSource只能发送文本，而websocket支持发送二进制数据。&lt;/div&gt;&lt;div&gt;4.在实现上EventSource比websocket更简单。&lt;/div&gt;&lt;div&gt;5.EventSource有自动重连接（不借助第三方）以及发送随机事件的能力。&lt;/div&gt;&lt;div&gt;6.websocket的资源占用过大EventSource更轻量。&lt;/div&gt;&lt;div&gt;7.websocket可以跨域，EventSource基于http跨域需要服务端设置请求头。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;EventSource的实现案例&lt;/div&gt;&lt;div&gt;客户端代码：&lt;/div&gt;&lt;pre&gt;// 实例化 EventSource 参数是服务端监听的路由&lt;br&gt;var source = new EventSource(\'/EventSource-test\')&lt;br&gt;source.onopen = function (event) { // 与服务器连接成功回调&lt;br&gt;&amp;nbsp; console.log(\'成功与服务器连接\')&lt;br&gt;}&lt;br&gt;// 监听从服务器发送来的所有没有指定事件类型的消息(没有event字段的消息)&lt;br&gt;source.onmessage = function (event) { // 监听未命名事件&lt;br&gt;&amp;nbsp; console.log(\'未命名事件\', event.data)&lt;br&gt;}&lt;br&gt;source.onerror = function (error) { // 监听错误&lt;br&gt;&amp;nbsp; console.log(\'错误\')&lt;br&gt;}&lt;br&gt;// 监听指定类型的事件（可以监听多个）&lt;br&gt;source.addEventListener(&quot;myEve&quot;, function (event) {&lt;br&gt;&amp;nbsp; console.log(&quot;myEve&quot;, event.data)&lt;br&gt;})&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;服务端代码（php）&lt;/div&gt;&lt;pre&gt;//数据流传输方式&lt;br&gt;header(\'Content-Type:text/event-stream\')&lt;br&gt;header(\'Cache-Control:no-cache\')&lt;br&gt;$json = json_encode($data); //推送数据&lt;br&gt;echo &quot;data:$json\\n\\n&quot;;&lt;br&gt;echo &quot;retry:20000\\n\\n&quot;; //隔20s客户端请求服务端一次&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\r\n                                                            ',0,'2018-01-03 00:00:00','29',43),(104,1,'linux下添加mysql用户并授权','','\r\n                                &lt;div&gt;平时在开发的过程中我们有时需要用到线上mysql的数据，要是本地直接用root用户登入，可能会误删数据，所以我们可以添加一个权限比较小的账号来连接线上的mysql;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、以管理员身份登录mysql&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;mysql -u root -p&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、选择mysql数据库&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;use mysql&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3、创建用户同时设置权限&lt;/div&gt;&lt;pre&gt;grant select on mq.* to \'test\' identified by \'123456\';&amp;nbsp; &amp;nbsp;// mq.* 表示mq数据库下所有的表 test用户只能有select权限&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;（创建的用户test默认Host为 \'%\' 可以远程访问数据库）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;4、使操作生效&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;flush privileges&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;可用的权限：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;ALL: 所有可用的权限&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;CREATE: 创建库、表和索引&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;LOCK_TABLES: 锁定表&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;ALTER: 修改表&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;DELETE: 删除表&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;INSERT: 插入表或列&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;SELECT: 检索表或列的数据&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;CREATE_VIEW: 创建视图&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;SHOW_DATABASES: 列出数据库&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;DROP: 删除库、表和视图&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\r\n                                                                                        ',0,'2018-01-02 00:00:00','11',40),(105,1,'JavaScript 获取时间戳','','&lt;div&gt;js 时间戳&lt;/div&gt;&lt;div&gt;var ts = Date.parse(new Date());&lt;/div&gt;&lt;div&gt;// ts 得到永远 xxx000&amp;nbsp; 1493269366000&amp;nbsp; 毫秒部分以000表示&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;所以要想获取秒为单位的时间戳，需要&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;var tmp = Date.parse( new Date() ).toString(); // 转字符串在截取&lt;/div&gt;&lt;div&gt;&amp;nbsp; tmp = tmp.substr(0,10);&lt;/div&gt;\r\n                                                            ',0,'2018-10-10 00:00:00','22',50),(106,1,'Nginx与Php-fpm的工作原理','','&lt;div&gt;Nginx是什么&lt;/div&gt;&lt;div&gt;Nginx (&quot;engine x&quot;) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Php-fpm是什么&lt;/div&gt;&lt;div&gt;1、cgi、fast-cgi协议&lt;/div&gt;&lt;div&gt;cgi的历史&lt;/div&gt;&lt;div&gt;早期的webserver只处理html等静态文件，但是随着技术的发展，出现了像php等动态语言。&lt;/div&gt;&lt;div&gt;webserver处理不了了，怎么办呢？那就交给php解释器来处理吧！&lt;/div&gt;&lt;div&gt;交给php解释器处理很好，但是，php解释器如何与webserver进行通信呢？&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;为了解决不同的语言解释器(如php、python解释器)与webserver的通信，于是出现了cgi协议。只要你按照cgi协议去编写程序，就能实现语言解释器与webwerver的通信。如php-cgi程序。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;fast-cgi的改进&lt;/div&gt;&lt;div&gt;有了cgi协议，解决了php解释器与webserver通信的问题，webserver终于可以处理动态语言了。&lt;/div&gt;&lt;div&gt;但是，webserver每收到一个请求，都会去fork一个cgi进程，请求结束再kill掉这个进程。这样有10000个请求，就需要fork、kill php-cgi进程10000次。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;有没有发现很浪费资源？&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;于是，出现了cgi的改良版本，fast-cgi。fast-cgi每次处理完请求后，不会kill掉这个进程，而是保留这个进程，使这个进程可以一次处理多个请求。这样每次就不用重新fork一个进程了，大大提高了效率。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、php-fpm是什么&lt;/div&gt;&lt;div&gt;php-fpm即php-Fastcgi Process Manager.&lt;/div&gt;&lt;div&gt;php-fpm是 FastCGI 的实现，并提供了进程管理的功能。（php-fpm包含了php-cgi程序并提增加供了进程管理功能）&lt;/div&gt;&lt;div&gt;进程包含 master 进程和 worker 进程两种进程。&lt;/div&gt;&lt;div&gt;master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个(具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.Nginx如何与Php-fpm结合&lt;/div&gt;&lt;div&gt;上面我们说了，Nginx不只有处理http请求的功能，还能做反向代理。Nginx通过反向代理功能将动态请求转向后端Php-fpm。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;配置Nginx+Php-fpm&lt;/div&gt;&lt;div&gt;进入nginx目录下，编辑 nginx.conf文件。&lt;/div&gt;&lt;div&gt;在nginx.conf最后一行，添加include文件 比如：include vhost/*.conf&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;添加对应的server&lt;/div&gt;&lt;div&gt;进入上面include的路径vhost目录下，添加一个server配置文件 比如：test.conf&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;server {&lt;br&gt;&amp;nbsp; &amp;nbsp; listen&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;80; #监听80端口，接收http请求&lt;br&gt;&amp;nbsp; &amp;nbsp; server_name&amp;nbsp; www.example.com; #就是网站地址&lt;br&gt;&amp;nbsp; &amp;nbsp; root /usr/local/etc/nginx/www/huxintong_admin; # 准备存放代码工程的路径&lt;br&gt;&amp;nbsp; &amp;nbsp; #路由到网站根目录www.example.com时候的处理&lt;br&gt;&amp;nbsp; &amp;nbsp; location / {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; index index.php; #跳转到www.example.com/index.php&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; autoindex on;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&amp;nbsp; &amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; #当请求网站下php文件的时候，反向代理到php-fpm&lt;br&gt;&amp;nbsp; &amp;nbsp; location ~ \\.php$ {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; include /usr/local/etc/nginx/fastcgi.conf; #加载nginx的fastcgi模块&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fastcgi_intercept_errors on;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fastcgi_pass&amp;nbsp; &amp;nbsp;127.0.0.1:9000; #nginx fastcgi进程监听的IP地址和端口&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;nginx与php-fpm的结合，完整的流程是这样的。&lt;/p&gt;&lt;pre&gt;www.example.com&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; Nginx&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;路由到www.example.com/index.php&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;加载nginx的fast-cgi模块&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;fast-cgi监听127.0.0.1:9000地址&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;www.example.com/index.php请求到达127.0.0.1:9000&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;php-fpm 监听127.0.0.1:9000&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;php-fpm 接收到请求，启用worker进程处理请求&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;php-fpm 处理完请求，返回给nginx&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; |&lt;br&gt;nginx将结果通过http返回给浏览器&lt;/pre&gt;&lt;p&gt;（总结：Nginx本身不能处理PHP文件，所以ngxin先是加载fast-cgi模块,然后通过代理的形式把请求转发给负责监听127.0.0.1:9000 的php-fpm的 master进程服务，然后master主进程会把请求资源文件交给worker工作进程来处理php文件，执行php代码）&lt;br&gt;&lt;/p&gt;&lt;/div&gt;\r\n                                                            ',0,'2017-06-13 00:00:00','23,26',41),(107,1,'javascript中const,var,let区别','','&lt;div&gt;今天第一次遇到const定义的变量，查阅了相关资料整理了这篇文章。主要内容是：js中三种定义变量的方式const， var， let的区别。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;const定义的变量不可以修改，而且必须初始化。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;const b = 2;//正确&lt;br&gt;// const b;//错误，必须初始化&amp;nbsp;&lt;br&gt;console.log(\'函数外const定义b：\' + b);//有输出值&lt;br&gt;// b = 5;&lt;br&gt;// console.log(\'函数外修改const定义b：\' + b);//无法输出&amp;nbsp;&lt;/pre&gt;&lt;div&gt;var定义的变量可以修改，如果不初始化会输出undefined，不会报错。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;var a = 1;&lt;br&gt;// var a;//不会报错&lt;br&gt;console.log(\'函数外var定义a：\' + a);//可以输出a=1&lt;br&gt;function change(){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;a = 4;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;console.log(\'函数内var定义a：\' + a);//可以输出a=4&lt;br&gt;}&amp;nbsp;&lt;br&gt;change();&lt;br&gt;console.log(\'函数调用后var定义a为函数内部修改值：\' + a);//可以输出a=4&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;let是块级作用域，函数内部使用let定义后，对函数外部无影响。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;let c = 3;&lt;br&gt;console.log(\'函数外let定义c：\' + c);//输出c=3&lt;br&gt;function change(){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;let c = 6;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;console.log(\'函数内let定义c：\' + c);//输出c=6&lt;br&gt;}&amp;nbsp;&lt;br&gt;change();&lt;br&gt;console.log(\'函数调用后let定义c不受函数内部定义影响：\' + c);//输出c=3&lt;/pre&gt;\n                                                            ',0,'2016-06-08 00:00:00','22',29),(108,1,'如何修改Vuex中的变量值','','\n                                &lt;div&gt;众所周知，在vue的项目里父子组件间可以用props 或者 $emit 等方式，进行数据传递，而如果项目稍微大一点的话有很多平行组件，这个时候在这些组件间传递数据，使用这些方法会比较麻烦，代码也会变得不利于服用。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;我们可以vuex来解决这个问题&lt;/div&gt;&lt;div&gt;vuex其实官网上不是太好理解,可以直接看看代码怎么实现的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;首先还是要先安装vuex&lt;/div&gt;&lt;div&gt;可以创建一个单独的store文件目录，里面专门存放相关的文件&lt;/div&gt;&lt;div&gt;然后新建index.js文件。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;import Vue from \'vue\'&lt;br&gt;import Vuex from \'vuex\'&lt;br&gt;Vue.use(Vuex)&lt;br&gt;const store = new Vuex.Store({&lt;br&gt;&amp;nbsp; state: {   // state 类似于vue实例的data属性，&lt;br&gt;&amp;nbsp; &amp;nbsp; // 初始化全局的一个变量&lt;br&gt;&amp;nbsp; &amp;nbsp; testTxt: {&quot;tips&quot;:&quot;这是一条vuex的数据&quot;,&quot;id&quot;:1}&lt;br&gt;&amp;nbsp; }&lt;br&gt;})&lt;br&gt;export default store&lt;/pre&gt;&lt;p&gt;然后在main.js 中注册store&lt;/p&gt;&lt;pre&gt;import Vue from \'vue\'&lt;br&gt;import App from \'./App\'&lt;br&gt;import router from \'./router\'&lt;br&gt;import store from \'./../store/index\'&lt;br&gt;/* eslint-disable no-new */&lt;br&gt;new Vue({&lt;br&gt;&amp;nbsp; el: \'#app\',&lt;br&gt;&amp;nbsp; router,&lt;br&gt;&amp;nbsp; store,&lt;br&gt;&amp;nbsp; template: \'&amp;lt;App/&amp;gt;\',&lt;br&gt;&amp;nbsp; components: { App }&lt;br&gt;})&lt;/pre&gt;&lt;p&gt;接下来在a.vue组件中使用&lt;/p&gt;&lt;pre&gt;export default {&lt;br&gt;&amp;nbsp; ...&lt;br&gt;&amp;nbsp; data(){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; value : &quot;这又是修改后的value&quot;,&lt;br&gt;&amp;nbsp; &amp;nbsp; },&lt;br&gt;&amp;nbsp; computed: {&lt;br&gt;&amp;nbsp; &amp;nbsp; getTxt() {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; return this.$store.state.testTxt.tips;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; },&lt;br&gt;&amp;nbsp; &amp;nbsp;methods: {&lt;br&gt;&amp;nbsp; &amp;nbsp; modifyTxt: function() {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; this.$store.commit(\'modifyTips\', this.value)&amp;nbsp; // 可以通过store中mutations里面的方法修改state的变量值&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; }&lt;br&gt;&amp;nbsp; ...&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;添加store的&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;mutations属性和对应的方法，&lt;/span&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;在store目录的index.js文件里可以修改：&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;pre&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;const store = new Vuex.Store({&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;&amp;nbsp; &amp;nbsp;state: {&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// 初始化全局的一个变量&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;testTxt: {&quot;tips&quot;:&quot;这是一条vuex的数据&quot;,&quot;id&quot;:1}&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;&amp;nbsp; &amp;nbsp;}，&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;&amp;nbsp; &amp;nbsp;mutations: {  // 类似于vue实例中的method属性&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; modifyTips(state,msg) {&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;  state.testTxt.tips= msg;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;&amp;nbsp; &amp;nbsp;}&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;})&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;export default store&lt;/span&gt;&lt;/font&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;\n                                                                                        ',0,'2018-02-02 00:00:00','38',56),(109,1,'在Vuex使用 以及 dispatch和commit来调用mutations的区别','','\n                                &lt;pre&gt;Vue.use(vuex);&lt;br&gt;const store = new Vuex.store({&lt;br&gt;　　state: {&lt;br&gt;　　　　nickName: &quot;&quot;,&lt;br&gt;　　　　cartCount: 0　　&lt;br&gt;　　},&lt;br&gt;　　mutations: {&lt;br&gt;　　　　updateUserInfo(state,nickName) {&lt;br&gt;　　　　　　state.nickName = nickName;&lt;br&gt;　　　　},&lt;br&gt;　　　　updateCartCount(state,cartCount) {&lt;br&gt;　　　　　　state.cartCount += cartCount;&lt;br&gt;　　　　}&lt;br&gt;　　},&lt;br&gt;&amp;nbsp; &amp;nbsp; actions: {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; updateUserInfo(context) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; context.commit(&quot;updateUserInfo&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; },&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; updateCartCount(context) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; context.commit(&quot;updateCartCount&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;})&lt;br&gt;new Vue({&lt;br&gt;　　el: &quot;#app&quot;,&lt;br&gt;　　store,&lt;br&gt;　　router,&lt;br&gt;　　template: \'&amp;lt;App/&amp;gt;\',&lt;br&gt;　　components: {App}&lt;br&gt;})&lt;br&gt;组件中：&lt;br&gt;methods: {&lt;br&gt;&amp;nbsp; &amp;nbsp; increment(){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.$store.dispatch(&quot;updateUserInfo&quot;, \'nick\');&amp;nbsp; //this.$store.commit(&quot;increment&quot;, \'nick\');&lt;br&gt;&amp;nbsp; &amp;nbsp; },&lt;br&gt;&amp;nbsp; &amp;nbsp; decrement() {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.$store.dispatch(&quot;updateCartCount&quot;, 1);&amp;nbsp; // this.$store.commit(&quot;decrement&quot;, 1);&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;br&gt;&amp;nbsp;&lt;br&gt;区别：&lt;br&gt;dispatch：含有异步操作，例如向后台提交数据，写法： this.$store.dispatch(\'actions方法名\',值)&lt;br&gt;commit：同步操作，写法：this.$store.commit(\'mutations方法名\',值)&lt;/pre&gt;\n                                                                                        ',0,'2018-02-03 00:00:00','38',51),(110,1,'vuex的mutations如何传多个传参?','','\n                                &lt;div&gt;1、不传参时的写法（官网例子）：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;const store = new Vuex.Store({&lt;br&gt;&amp;nbsp; state: {&lt;br&gt;&amp;nbsp; &amp;nbsp; count: 1&lt;br&gt;&amp;nbsp; },&lt;br&gt;&amp;nbsp; mutations: {&lt;br&gt;&amp;nbsp; &amp;nbsp; increment (state) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // mutate state&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; state.count++&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; }&lt;br&gt;})&lt;br&gt;store.commit(\'increment\')&lt;/pre&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、传一个参数的写法（官网例子）：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;mutations: {&lt;br&gt;&amp;nbsp; increment (state, n) {&lt;br&gt;&amp;nbsp; &amp;nbsp; state.count += n&lt;br&gt;&amp;nbsp; }&lt;br&gt;}&lt;br&gt;store.commit(\'increment\', 10)&lt;/pre&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;3、传多个参数的写法：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　此时参数不能继续在后面加，后面的参数无效，传进去的参数为undefined；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　官网的解释：In most cases, the payload should be an object so that it can contain multiple fields, and the recorded mutation will also be more descriptive；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　所以，我们可以将参数以对象（数组）的方式传进去，多个属性就是多个参数了。&lt;/div&gt;&lt;pre&gt;&lt;br&gt;mutations: {&lt;br&gt;&amp;nbsp; increment (state, payload) {&lt;br&gt;&amp;nbsp; &amp;nbsp; state.count += payload.amount1；&lt;br&gt;&amp;nbsp; &amp;nbsp; state.count += payload.amount2；&lt;br&gt;&amp;nbsp; &amp;nbsp; state.count += payload.amount3；&lt;br&gt;&amp;nbsp; &amp;nbsp; state.count += payload.amount4；&lt;br&gt;} }&lt;br&gt;store.commit(\'increment\', {&lt;br&gt;&amp;nbsp; amount1: 10,&lt;br&gt;&amp;nbsp; amount2: 20，&lt;br&gt;&amp;nbsp; amount3: 30，&lt;br&gt;&amp;nbsp; amount4: 40，&lt;br&gt;}&lt;/pre&gt;\n                                                                                        ',0,'2018-02-02 00:00:00','38',49),(111,1,'在组件中如何使用vuex的值','','\n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;&lt;br&gt;import { mapState } from \'vuex\'&amp;nbsp; &amp;nbsp; //映射state&lt;br&gt;import { mapGetters } from \'vuex\'&amp;nbsp; //映射getters&lt;br&gt;&amp;nbsp;computed: {&lt;br&gt;&amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;/* 普通写法，利用方法返回值的形式输入state的值*/&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;count(){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;return this.$store.state.count;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;},&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; filteredList() {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;return this.$store.getters.filteredList;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; },&lt;br&gt;&amp;nbsp; &amp;nbsp; /* 使用对象展开运算符将 getter 混入 computed 对象中 */&lt;br&gt;&amp;nbsp; &amp;nbsp; ...mapState({&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; count: state =&amp;gt; state.count&lt;br&gt;&amp;nbsp; &amp;nbsp; }),&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; ...mapGetters([&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; \'filteredList\'&lt;br&gt;&amp;nbsp; &amp;nbsp; ])&lt;br&gt;},&lt;/pre&gt;\n                                                                                        ',0,'2018-03-02 00:00:00','38',36),(112,1,'vue.js解决刷新页面vuex数据丢失的问题','','\n                                &lt;div&gt;页面刷新store.state中的数据消失是不可避免的，可以使用localStorage来避免这个问题。但是一个一个数据添加实在是太麻烦了。那么就需要一个全局的方法来，将store的数据存储在localStorage里。具体的方法也是百度的很好用，也很方便。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 在App.vue中，created初始化生命周期中写入以下方法&lt;/div&gt;&lt;pre&gt;//在页面刷新时将vuex里的信息保存到localStorage里&lt;br&gt;window.addEventListener(&quot;beforeunload&quot;,()=&amp;gt;{&lt;br&gt;&amp;nbsp; localStorage.setItem(&quot;messageStore&quot;,JSON.stringify(this.$store.state))&lt;br&gt;})&lt;br&gt;&amp;nbsp;&lt;br&gt;//在页面加载时读取localStorage里的状态信息&lt;br&gt;localStorage.getItem(&quot;messageStore&quot;) &amp;amp;&amp;amp; this.$store.replaceState(Object.assign(this.$store.state,JSON.parse(localStorage.getItem(&quot;messageStore&quot;))));&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;replaceState这个方法呢，查了api，就是替换 store 的根状态，然后通过对象赋值assign将localStorage进行赋值&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;beforeunload这个方法是在页面刷新时触发的，将store中的信息存入localStorage&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这样就通过localStorage来避免vuex刷新数据消失的问题了。&lt;/div&gt;\n                                                                                        ',0,'2018-03-03 00:00:00','38',29),(113,1,'vuex2.x中mutation 和 action的基本使用','','\n                                &lt;div&gt;1, mutation&lt;/div&gt;&lt;div&gt;　　The only way to actually change state in a Vuex store is by committing a mutation, 在vue 中，只有mutation 才能改变state.&amp;nbsp; mutation 类似事件，每一个mutation都有一个类型和一个处理函数，因为只有mutation 才能改变state, 所以处理函数自动会获得一个默认参数 state. 所谓的类型其实就是名字，action去comit 一个mutation, 它要指定去commit哪个mutation, 所以mutation至少需要一个名字，commit mutation 之后， 要做什么事情，那就需要给它指定一个处理函数， 类型(名字) + 处理函数就构成了mutation. （Vue 建议我们mutation 类型用大写常量表示，修改一下，把mutation 类型改为大写）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.action 是异步的，还有的错误处理也都在这里操作。action 和mutions 的定义方法是类似的，我们要dispatch 一个action, 所以actions 肯定有一个名字，dispatch action 之后它要做事情，就是commit mutation, 所以还要给它指定一个函数。因为要commit mutation ,所以 函数也会自动获得一个默认参数context,&amp;nbsp; 它是一个store 实例，通过它可以获取到store 实例的属性和方法,如 context.state 就会获取到 state 属性， context.commit 就会执行commit命令。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;现在store.js里添加mutation、action&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;const store = new Vuex.Store({&lt;br&gt;&amp;nbsp; &amp;nbsp; state: {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; count:0&lt;br&gt;&amp;nbsp; &amp;nbsp; },&lt;br&gt;&amp;nbsp; &amp;nbsp; mutations: {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 加1&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; INCREMENT(state) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; state.count++;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; },&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 减1&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; DECREMENT(state) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; state.count--&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; },&lt;br&gt;&amp;nbsp; &amp;nbsp; actions: {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; increment({commit}) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; commit(&quot;INCREMENT&quot;)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; },&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; decrement({commit}) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; commit(&quot;DECREMENT&quot;)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; },&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; incrementWithValue({commit}, value){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; commit(&quot;INCREMENT_WITH_VALUE&quot;,&amp;nbsp; parseInt(value))&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;})&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3, dispatch&amp;nbsp; action&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　现在就剩下dispatch action 了。什么时候dispatch action 呢？ 只有当我们点击按钮的时候. 给按钮添加click 事件,在click 事件处理函数的中dispatch action.　打开increment.vue 组件，给两个按钮添加click 事件。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;&amp;lt;template&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;lt;div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;button @click=&quot;increment&quot;&amp;gt;+1&amp;lt;/button&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;button @click=&quot;decrement&quot;&amp;gt;-1&amp;lt;/button&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;lt;/div&amp;gt;&lt;br&gt;&amp;lt;/template&amp;gt;&lt;br&gt;&amp;lt;script&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; export default {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; methods: {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; increment(){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.$store.dispatch(&quot;increment&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; },&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; decrement() {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.$store.dispatch(&quot;decrement&quot;)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;lt;/script&amp;gt;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;其实像上面dispatch action 比较麻烦，如果有10 个按钮，我们要写10 个函数,vue 提供了mapAction 函数，它和mapState&amp;nbsp; 是一样的，把我们的 action 直接映射到store 里面的action中。&lt;/div&gt;&lt;pre&gt;&amp;lt;script&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; import {mapActions} from &quot;vuex&quot;;&lt;br&gt;&amp;nbsp; &amp;nbsp; export default {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; methods: {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ...mapActions([&quot;increment&quot;, &quot;decrement&quot;]),&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; incrementWithValue() {&amp;nbsp; // 调用带参数的action方法&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.$store.dispatch(&quot;incrementWithValue&quot;, this.incrementValue)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;lt;/script&amp;gt;&lt;/pre&gt;\n                                                                                        ',0,'2019-11-09 00:00:00','38',30),(114,1,'javascript 替换选中的文字','','&lt;pre&gt;&amp;lt;input type=&quot;button&quot;&amp;nbsp; id=&quot;Button1&quot; value=&quot;替换选中文字&quot; onclick=&quot;surroundContent()&quot;/&amp;gt;&lt;br&gt;&amp;lt;p&amp;gt;&lt;br&gt;&amp;nbsp; 其实，现实生活中，“常回家看看”的缺位，“宅居”自己房间的常态，沟通话题的日渐狭窄，这些无一不是“哦”的变种。打破这样的僵局，做子女的必须主动向父母搭腔。&lt;br&gt;　　要知道，跟爸妈多说几句话，既是心的陪伴，也是爱的嵌入。相反，回复越“简洁”，给亲情注水就越多。儿大可以不由娘，父亲的支柱地位可以被取代，但他们的尊严和情感不能被忽视。他们，可是那即便老得忘了你名字，也会记得你爱吃饺子的人&amp;lt;/p&amp;gt;&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;lt;script&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; function surroundContent() {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var r;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (document.selection) { //IE9 以下了浏览器&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; r = document.selection.createRange();&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (r.text != \'\') r.pasteHTML(\'&amp;lt;a href=&quot;#&quot;&amp;gt;\' + r.text + \'&amp;lt;/a&amp;gt;\')&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }else if (window.getSelection) { //其它浏览器&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; r = window.getSelection();&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (r.rangeCount &amp;gt; 0) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; r = r.getRangeAt(0);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var a = document.createElement(\'a\');&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; a.href = \'#\';&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; r.surroundContents(a)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; r.collapse(false);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;lt;/script&amp;gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/mafan121/article/details/78519348&quot; target=&quot;_blank&quot;&gt;js与鼠标光标的相关函数&lt;/a&gt;&lt;br&gt;&lt;/p&gt;\n                                                            ',0,'2016-06-08 00:00:00','22',24),(115,1,'如何处理大访问量的情况?','','\n                                &lt;div&gt;&lt;b&gt;阅读目录&lt;/b&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;一.硬件升级&lt;/div&gt;&lt;div&gt;二.负载均衡&lt;/div&gt;&lt;div&gt;三.服务器集群&lt;/div&gt;&lt;div&gt;四.数据库读写分离&lt;/div&gt;&lt;div&gt;五.数据库分表技术（垂直分割，水平分割）&lt;/div&gt;&lt;div&gt;六.表建立相应的索引&lt;/div&gt;&lt;div&gt;七.页面静态化&lt;/div&gt;&lt;div&gt;八.缓存技术（MemCache、Redis）&lt;/div&gt;&lt;div&gt;九.禁止外部盗链&lt;/div&gt;&lt;div&gt;十.控制大文件的下载&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;一.硬件升级&lt;/div&gt;&lt;div&gt;普通的P4服务器一般最多能支持每天10万独立IP，如果访问量比这个还要大， 那么必须首先配置一台更高性能的专用服务器才能解决问题 ，否则怎么优化都不可能彻底解决性能问题。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;二.负载均衡&lt;/div&gt;&lt;div&gt;它是根据某种负载策略把请求分发到集群中的每一台服务器上，让整个服务器群来处理网站的请求。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;公司比较有钱的，可以购买专门负责负载均衡的硬件（如：F5）,效果肯定会很好。对于大部分公司，会选择廉价有效的方法扩展整个系统的架构，来增加服务器的吞吐量和处理能力，以及承载能力。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;三.服务器集群&lt;/div&gt;&lt;div&gt;服务器集群就是指将N台服务器集中起来一起进行同一种服务，它们之间通过网络实现通信。让N台服务器之间相互协作，共同承载一个网站的请求压力。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在客户端看来就像是只有一个服务器。集群可以利用多个计算机进行并行计算从而获得很高的计算速度，也可以用多个计算机做备份，从而使得任何一个机器坏了整个系统还是能正常运行。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;四.数据库读写分离&lt;/div&gt;&lt;div&gt;基本的原理是让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库处理SELECT查询操作。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;五.数据库分表技术（垂直分割，水平分割）&lt;/div&gt;&lt;div&gt;当一张的数据达到几百万时，你查询一次所花的时间会变多，如果有联合查询的话，很有可能会死在那儿了。分表的目的就在于此，减小数据库的负担，缩短查询时间。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;六.表建立相应的索引&lt;/div&gt;&lt;div&gt;使用索引可快速访问数据库表中的特定信息。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;七.页面静态化&lt;/div&gt;&lt;div&gt;前台实现完全的静态化最好，可以完全不用访问数据库。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;八.缓存技术（MemCache、Redis）&lt;/div&gt;&lt;div&gt;缓存技术就是另一个解决方案，就是将动态数据存储到缓存文件中，动态网页直接调用 这些文件，而不必再访问数据库&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;九.禁止外部盗链&lt;/div&gt;&lt;div&gt;外部网站的图片或者文件盗链往往会带来大量的负载压力，因此应该严格限制外部对于自身的图片或者文件盗链&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;十.控制大文件的下载&lt;/div&gt;&lt;div&gt;&amp;nbsp;大文件的下载会占用很大的流量，并且对于非SCSI硬盘来说，大量文件下载会消耗 CPU，使得网站响应能力下降。因此，尽量不要提供超过2M的大文件下载，如果需要提供，建议将大文件放在另外一台服务器上。&lt;/div&gt;\n                                                                                        ',0,'2017-06-13 00:00:00','25,26',48),(116,1,'关于JWT的数据存储在哪里的问题','','\n                                \n                                &lt;div&gt;如何存储这些令牌。如果你正在构建一个web应用程序，你有两种选择:&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;*HTML5 Web Storage (localStorage或sessionStorage)&lt;/div&gt;&lt;div&gt;*Cookies&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1.JWT localStorage （localstorage,没有时间限制的存储，会一直存放在浏览器中）&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;当用户第一次登入成功后，返回JWT的token给客户端，客户端通过&lt;/div&gt;&lt;div&gt;localStorage.setItem(&quot;token&quot;,token)把token保存在本地&lt;/div&gt;&lt;div&gt;（注：这是HTML5.js中的一个方法，用来获取浏览器存放本地api LocalStorage可以被 javascript 访问，所以容易受到XSS攻击。尤其是项目中用到很多第三方的Javascript类库。）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;XSS攻击：&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;Web存储(localStorage/sessionStorage)可以通过同一域上JavaScript访问。这意味着任何在你的网站上运行的JavaScript都可以访问Web存储，因为这样容易受到跨站点脚本（XSS）攻击。XSS，简而言之，是一种漏洞，攻击者可以注入在页面上运行的JavaScript。基本的XSS攻击试图通过input表单注入JavaScript,攻击者将&amp;lt;script&amp;gt;alert(\'You are Hacked\');&amp;lt;/script&amp;gt;放入表单，以查看其是否能被浏览器运行，并能被其他用户查看。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;如果你使用的脚本中有一个被盗用了怎么办?恶意的JavaScript可以嵌入到页面上，并且Web存储被盗用。这些类型的XSS攻击可以得到每个人的Web存储来访问你的网站，没有他们的知识。这可能是为什么许多组织建议不要在Web存储中存储任何有价值或信任任何Web存储中的信息。这包括会话标识符和令牌。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.JWT Cookie Storage&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;当用户第一次登入成功后，通过响应使用Set-Cookie HTTP头:&lt;/div&gt;&lt;div&gt;例如：&lt;/div&gt;&lt;pre style=&quot;line-height: 1.42857;&quot;&gt;HTTP/1.1 200 OK&lt;br&gt;Set-Cookie: access_token=eyJhbGciOiJIUzI1NiIsI.eyJpc3MiOiJodHRwczotcGxlL.mFrs3Zo8eaSNcxiNfvRh9dqKP4F1cB; Secure; HttpOnly;&lt;/pre&gt;&lt;div&gt;（注：设置httpOnly 后 cookie 将不能被 JS 读取；设置 secure 的话，cookie 就只允许通过 HTTPS 传输）&lt;/div&gt;&lt;div&gt;CSRF攻击：&lt;/div&gt;&lt;div&gt;cookies也容易受到不同类型的攻击：跨站点请求伪造(CSRF)。CSRF攻击是当一个恶意网站，电子邮件或博客导致用户在当前已验证用户的可信站点上的web浏览器中，执行一个有害的动作时发生的攻击。这是一个浏览器如何处理cookies的漏洞。cookie只能被发送到的允许的域中。默认情况下，这个是最初设置cookie的域。请求将发送一个cookie无论你在galaxies.com或hahagonnahackyou.com。&lt;/div&gt;&lt;div&gt;CSRF的工作试图引诱你到hahagonnahackyou.com。该网站将有一个img标记或JavaScript来模拟一个表单post到galaxies.com，并试图劫持你的会话，如果它仍然有效，就修改您的帐户。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;例如：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre style=&quot;line-height: 1.42857;&quot;&gt;&amp;lt;body&amp;gt;&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;lt;!– CSRF 用img标签 –&amp;gt;&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;lt;img href=&quot;http://galaxies.com/stars/pollux?transferTo=tom@stealingstars.com&quot; /&amp;gt;&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;lt;!– 或用一个隐藏表单post–&amp;gt;&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;br&gt;&amp;nbsp; $(document).ready(function() {&lt;br&gt;&amp;nbsp; &amp;nbsp; window.document.forms[0].submit();&lt;br&gt;&amp;nbsp; });&lt;br&gt;&amp;nbsp; &amp;lt;/script&amp;gt;&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;lt;div style=&quot;display:none;&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;lt;form action=&quot;http://galaxies.com/stars/pollux&quot; method=&quot;POST&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;input name=&quot;transferTo&quot; value=&quot;tom@stealingstars.com&quot; /&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;lt;form&amp;gt;&lt;br&gt;&amp;nbsp; &amp;lt;/div&amp;gt;&lt;br&gt;&amp;lt;/body&amp;gt;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;两者都将发送cookie为galaxies.com，并可能导致未经授权的状态改变。针对这样的攻击，前端在每次请求时将JWT放入HTTP Header的Authorization中（可以理解为http头部的一个自定义属性）。可以解决XSS和XSRF问题，因为只有JavaScript运行在你的域才可以读取cookie。&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190415/6bee363994bef314785799c6ff7f3614.png&quot; data-filename=&quot;img&quot; style=&quot;width: 799px;&quot;&gt;&lt;/div&gt;&lt;div&gt;客户端每次请求时将JWT token放入HTTP Header的token中，虽然cookie中也包含有token,但是为了解决CSRF攻击，所以服务端不会去验证cookie的token, 而是获取http头部的token进行验证&lt;b&gt;，一般适用于SPA单页应用的异步请求API, ajax动态的添加header token值&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;cookie 优点：&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;可以指定 httponly，来防止被Javascript读取，也可以指定secure，来保证token只在HTTPS下传输。&lt;/div&gt;&lt;div&gt;缺点：&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;不符合Restful 最佳实践。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;容易遭受CSRF攻击 （可以在服务器端检查 Refer 和 Origin）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;相比较而言，Web Storage比Cookie更容易受到攻击，所以可以考虑选择cookie进行token信息的存储&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;（3）sessionStorage&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;针对一个session的用户存储，也可以被javascript访问，但当用户关闭浏览器时，也会随之消失&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\n                                                                                                                    ',0,'2018-02-05 00:00:00','23,22,29',62),(117,1,'Json Web Token（JWT） 解析','','\n                                &lt;div&gt;JWT 是一个开放标准(RFC 7519)，它定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。JWT 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名。它具备两个特点：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;简洁(Compact)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;自包含(Self-contained)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;负载中包含了所有用户所需要的信息，避免了多次查询数据库&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;JWT 组成&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190415/d3f8efdc59cf0450055a103f1ce94df5.png&quot; data-filename=&quot;img&quot; style=&quot;width: 345px;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Header 头部&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;头部包含了两部分，token 类型和采用的加密算法&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;{ &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot; }&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;它会使用 Base64 编码组成 JWT 结构的第一部分,如果你使用Node.js，可以用Node.js的包base64url来得到这个字符串。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Base64是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Payload 负载&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这部分就是我们存放信息的地方了，你可以把用户 ID 等信息放在这里，JWT 规范里面对这部分有进行了比较详细的介绍，常用的由 iss（签发者），exp（过期时间），sub（面向的用户），aud（接收方），iat（签发时间）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;{ &quot;iss&quot;: &quot;lion1ou JWT&quot;, &quot;iat&quot;: 1441593502, &quot;exp&quot;: 1441594722, &quot;aud&quot;: &quot;www.example.com&quot;, &quot;sub&quot;: &quot;lion1ou@163.com&quot; }&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;同样的，它会使用 Base64 编码组成 JWT 结构的第二部分&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Signature 签名&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;前面两部分都是使用 Base64 进行编码的，即前端可以解开知道里面的信息。Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥（secret），然后使用 header 中指定的签名算法（HS256）进行签名。签名的作用是保证 JWT 没有被篡改过。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;三个部分通过.连接在一起就是我们的 JWT 了，它可能长这个样子，长度貌似和你的加密算法和私钥有关系。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjU3ZmVmMTY0ZTU0YWY2NGZmYzUzZGJkNSIsInhzcmYiOiI&lt;/div&gt;&lt;div&gt;0ZWE1YzUwOGE2NTY2ZTc2MjQwNTQzZjhmZWIwNmZkNDU3Nzc3YmUz&lt;/div&gt;&lt;div&gt;OTU0OWM0MDE2NDM2YWZkYTY1ZDIzMzBlIiwiaWF0IjoxNDc2NDI3OTMzfQ.PA3QjeyZSUh7H0GfE0vJaKW4LjKJuC3dVLQiY4hii8s&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;其实到这一步可能就有人会想了，HTTP 请求总会带上 token，这样这个 token 传来传去占用不必要的带宽啊。如果你这么想了，那你可以去了解下 HTTP2，HTTP2 对头部进行了压缩，相信也解决了这个问题。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;签名的目的&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;信息暴露&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在这里大家一定会问一个问题：Base64是一种编码，是可逆的，那么我的信息不就被暴露了吗？&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;是的。所以，在JWT中，不应该在负载里面加入任何敏感的数据。在上面的例子中，我们传输的是用户的User ID。这个值实际上不是什么敏感内容，一般情况下被知道也是安全的。但是像密码这样的内容就不能被放在JWT中了。如果将用户的密码放在了JWT中，那么怀有恶意的第三方通过Base64解码就能很快地知道你的密码了。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;因此JWT适合用于向Web应用传递一些非敏感信息。JWT还经常用于设计用户认证和授权系统，甚至实现Web应用的单点登录。&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190415/0bbb90106e3c7f761a77745f6f4ce6f4.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 919px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;1.首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT。形成的JWT就是一个形同lll.zzz.xxx的字符串。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;4.前端在每次请求时将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;5.后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;6.验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\n                                                                                        ',0,'2018-02-07 00:00:00','23,22,29',42),(118,1,'集群间如何实现session共享的分析','','&lt;div&gt;&lt;b&gt;一、引言&lt;/b&gt;&lt;/div&gt;&lt;div&gt;针对企业，为了应对庞大的用户访问压力，目前大多数大型网站服务器都采用集群部署的方式；针对个人，仅一台服务器而言，也会安装多个tomcat进行错时更新，保证更新后台业务时服务不断开，即模拟了集群的运行方式。在此集群中，我们就不得不考虑一个用户鉴权的问题，即在不同服务上如何保证用户均已登录，并能获取相同的用户登录信息。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;二、 Web网站推荐的（公认的）用户鉴权机制&lt;/b&gt;&lt;/div&gt;&lt;div&gt;说此部分之前先了解几个概念：&amp;nbsp;&lt;/div&gt;&lt;div&gt;1.请求，即Request，指客户端向服务器发送的信息，通常是通信的发起方；&amp;nbsp;&lt;/div&gt;&lt;div&gt;2.响应，即Response，指服务器对请求的应答，通常是通信的回复方；&amp;nbsp;&lt;/div&gt;&lt;div&gt;3.会话，即Session，服务器可将请求&amp;lt;-&amp;gt;响应这一个完整的过程称为一次会话，并为这次会话生成一个唯一的标识符，即sessionId，用来表示这次会话，Session储存在服务器端；&amp;nbsp;&lt;/div&gt;&lt;div&gt;4.Cookie，客户端保存在本地终端的数据，即Cookie储存在客户端。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;Web网站的共用用户鉴权机制是采用Session-Cookie技术，实现原理是：用户登录时，请求到达服务器，服务器调用通过getSession()方法判断session是否存在，如果不存在，则新建session，并通过其算法为session生成一个随机数作为sessionId，开发者可在session中储存一些用户信息；第二次请求时，如获取用户信息，getSession()方法判断session存在，则取出session，而不是新建，从而从session中获取到用户的相关信息。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;客户端请求时，可以将cookie信息储存于request的head中发送给服务器；&amp;nbsp;&lt;/div&gt;&lt;div&gt;服务器响应时，可以将cookie信息置于response中回传给客户端。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;那么getSession()里究竟做了什么？&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1.第一次用户请求，客户端本地没有任何数据，即其cookie为空，朝服务器发送request，getSession()中会解析request,发现其约定的cookie为null，则认为没有session，所以会重新创建一个session对象；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.创建session后会将此session的id放入response中，回传给客户端，客户端则保存response中的cookie；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.再次请求，服务器getSession()又会重新解析request获取cookie，发现了其中的sessionId，那么根据此sessionId去服务器的中去找，则得到了上次创建的session对象，那么则认为鉴权成功。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;三、集群间如何实现session共享&lt;/b&gt;&lt;/div&gt;&lt;div&gt;按照前文所说的session-cookie机制，session是保存在每台服务器的，但在集群中，拥有多台服务器，每台各自为政，势必会造成在这台服务器中登录，获取session成功，但是到另一台服务器上，又会获取不到session，造成鉴权失败，这样对用户来说是极不友好的，那么怎么解决这个问题呢？&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;通过我们以上的分析，即可得出几种处理方式:&amp;nbsp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;A.找一块公共的空间用来储存session，而不是将session储存在集群节点的某台服务器上，此时，每一台服务器都能访问这块空间，从而实现session共享；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;B.仍在每台服务器上保存session信息，不作修改，但采用另一种同步机制，实时同步没一台服务器的session信息；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;C.构建一种全新的鉴权机制，不采用session-cookie机制，但要去除此鉴权机制对单个服务器的依赖。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;综上所述，列举几种的具体实现方案：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1.持久化session到数据库，即使用数据库来储存session。数据库正好是我们普遍使用的公共储存空间，一举两得，推荐使用mysql数据库，轻量并且性能良好。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;优点：就地取材，符合大多数人的思维，使用简单，不需要太多额外编码工作&amp;nbsp;&lt;/div&gt;&lt;div&gt;缺点：对mysql性能要求较高，访问mysql需要从连接池中获取连接，又因为大部分请求均需要进行登录鉴权，所以操作数据库非常频繁，当用户量达到一定程度之后，极易造成数据库瓶颈，不适用于处理高并发的情况。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.使用redis共享session。redis是一个key-value的储存系统。可以简单的将其理解为一个数据库，与传统数据库的区别是，它将数据储存于内存中，并自带有内存到硬盘的序列化策略，即按策略将内存中的数据同步到磁盘，避免数据丢失，是目前比较流行的解决方案。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;优点：无需增加数据库的压力，因为数据存储于内存中，所以读取非常快，高性能，并能处理多种类型的数据。&amp;nbsp;&lt;/div&gt;&lt;div&gt;缺点：额外增加一些编码，以便操作redis。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.使用memcache同步session，memcache可以实现分布式，可将服务器中的内存组合起来，形成一个“内存池”，以此充当公共空间，保存session信息。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;优点：数据储存在内存中，读取非常快，性能好；&amp;nbsp;&lt;/div&gt;&lt;div&gt;缺点：memcache把内存分成很多种规格的存储块，有大有小，不能完全利用内存，会产生内存碎片，浪费资源，如果储存块不足，还会产生内存溢出。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;4.通过脚本或守护进程在多台服务器之间同步session。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;优点：实现了session共享；&amp;nbsp;&lt;/div&gt;&lt;div&gt;缺点：对个人来说实现较为复杂，速度不稳定，有延时性，取决于现实中服务运行状态，偶然性较大，如果用于访问过快，可能出现session还没同步成功的情况。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;5.使用NFS共享session。NFS是Network File Server共享服务器的简称，最早由Sun公司为解决Unix网络主机间的目录共享而研发。选择一台公共的NFS做共享服务器，储存所有session数据，每台服务器所需的session均从此处获取。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;优点：较好的实现了session共享；&amp;nbsp;&lt;/div&gt;&lt;div&gt;缺点：成本较高，对于个人来说难以实现。NFS依托于复杂的安全机制和文件系统，因此并发效率不高。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;6.使用Cookie共享session。此方案可以说是独辟蹊径了，将分布式思想用到了极致。如上文分析所说，session-cookie机制中，session与cookie相互关联，以cookie做中转站，用来找到对应的session，其中session存放在服务器。那么如果将session中的内容存放在cookie中呢，那么则省略了服务器保存session的过程，后台只需要根据cookie中约定的标识进行鉴权校验即可。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;优点：完美的贯彻分布式的理念，将每个用户都利用起来，无需耗费额外的服务器资源；&amp;nbsp;&lt;/div&gt;&lt;div&gt;缺点：受http协议头长度限制，cookie中存储的信息不宜过多；为了保持cookie全局有效，所以其一般依赖在根域名下，所以基本上所有的http请求都需要传递cookie中的这些标记信息，所以会占用一些服务器的带宽；鉴权信息全存储于cookie中，cookie存在于客户端，服务器并没有储存相关信息，cookie存在着泄露的可能，或则其他人揣摩出规则后可以进行伪装，其安全性比其他方案差，故需要对cookie中信息进行加密解密，来增强其安全性。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;在此，我们将选择方案2使用redis来具体实现集群下的session共享。&lt;/b&gt;&lt;/div&gt;\n                                                            ',0,'2016-07-14 00:00:00','16',52),(119,1,'究竟什么是RESTful API？','','\n                                &lt;div&gt;RESTful API 只是API的设计规范或者是一套设计理论。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;单就URL和Method这两个点，你可以这样理解： URL 是用来唯一标示一个互联网资源的，而 Method 是用来标识当前请求对该资源进行什么操作。&lt;/div&gt;&lt;div&gt;比如：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;一般的api接口可以用&lt;/div&gt;&lt;pre&gt;GET http://www.xx.com/user?id=123&amp;nbsp;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这个接口可以表示用来删除一个用户，也可以表示用来获取一个用户的信息，但这是不符合 RESTful API 规范的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;符合RESTful API规范应该是&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;DELETE http://www.xx.com/user/123。&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这里 http://www.xx.com/user/123 用来标识一个互联网资源（某个站点的一个用户），DELETE 用来标识我这次请求是要删除一个用户。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;比如我要获取这个用户的详细信息，那么我的请求时&lt;/div&gt;&lt;div&gt;GET http://www.xx.com/user/123，这里还是相同的URL，但是我用GET方式请求，服务端就应该知道我只是要获取资源信息，而不是删除。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;有些额外的参数依然可以通过GET方式的QueryString参数传递，比如，用户列表：http://www.xx.com/users 你可能会加上一些查询参数，&lt;/div&gt;&lt;pre&gt;如：http://www.xx.com/users?sex=boy&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;设计符合RESTful API风格的接口，其实主要是想更加清楚明了的告诉别人这个操作是要干什么的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;1 资源与URI&lt;/b&gt;&lt;/div&gt;&lt;div&gt;REST全称是表述性状态转移，那究竟指的是什么的表述? 其实指的就是资源。任何事物，只要有被引用到的必要，它就是一个资源。资源可以是实体(例如手机号码)，也可以只是一个抽象概念(例如价值) 。下面是一些资源的例子：&lt;/div&gt;&lt;ul&gt;&lt;li&gt;某用户的手机号码&lt;/li&gt;&lt;li&gt;某用户的个人信息&lt;/li&gt;&lt;li&gt;最多用户订购的GPRS套餐&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;要让一个资源可以被识别，需要有个唯一标识，在Web中这个唯一标识就是URI(Uniform Resource Identifier)。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;URI既可以看成是资源的地址，也可以看成是资源的名称。如果某些信息没有使用URI来表示，那它就不能算是一个资源， 只能算是资源的一些信息而已。URI的设计应该遵循可寻址性原则，具有自描述性，需要在形式上给人以直觉上的关联。这里以github网站为例，给出一些还算不错的URI：&lt;/div&gt;&lt;ul&gt;&lt;li&gt;https://github.com/git&lt;/li&gt;&lt;li&gt;https://github.com/git/git&lt;/li&gt;&lt;li&gt;https://github.com/git/git/blob/master/block-sha1/sha1.h&lt;/li&gt;&lt;li&gt;https://github.com/git/git/pulls?state=closed&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;u&gt;下面让我们来看看URI设计上的一些技巧:&lt;/u&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;使用_或-来让URI可读性更好&lt;/div&gt;&lt;div&gt;曾经Web上的URI都是冰冷的数字或者无意义的字符串，但现在越来越多的网站使用_或-来分隔一些单词，让URI看上去更为人性化。 例如国内比较出名的开源中国社区，它上面的新闻地址就采用这种风格， 如http://www.oschina.net/news/38119/oschina-translate-reward-plan。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;使用/来表示资源的层级关系&lt;/div&gt;&lt;div&gt;例如上述/git/git/commit/e3af72cdafab5993d18fae056f87e1d675913d08就表示了一个多级的资源， 指的是git用户的git项目的某次提交记录，又例如/orders/2012/10可以用来表示2012年10月的订单记录。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;使用?用来过滤资源&lt;/div&gt;&lt;div&gt;很多人只是把?简单的当做是参数的传递，很容易造成URI过于复杂、难以理解。可以把?用于对资源的过滤， 例如/git/git/pulls用来表示git项目的所有推入请求，而/pulls?state=closed用来表示git项目中已经关闭的推入请求， 这种URL通常对应的是一些特定条件的查询结果或算法运算结果。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;,或;可以用来表示同级资源的关系&lt;/div&gt;&lt;div&gt;有时候我们需要表示同级资源的关系时，可以使用,或;来进行分割。例如哪天github可以比较某个文件在随意两次提交记录之间的差异，或许可以使用/git/git /block-sha1/sha1.h/compare/e3af72cdafab5993d18fae056f87e1d675913d08;bd63e61bdf38e872d5215c07b264dcc16e4febca作为URI。 不过，现在github是使用…来做这个事情的，例如/git/git/compare/master…next。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;2 统一资源接口&lt;/b&gt;&lt;/div&gt;&lt;div&gt;RESTful架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果按照HTTP方法的语义来暴露资源，那么接口将会拥有安全性和幂等性的特性，例如GET和HEAD请求都是安全的， 无论请求多少次，都不会改变服务器状态。而GET、HEAD、PUT和DELETE请求都是幂等的，无论对资源操作多少次， 结果总是一样的，后面的请求并不会产生比第一次更多的影响。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;下面列出了GET，DELETE，PUT和POST的典型用法:&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;GET（获取）&lt;/b&gt;&lt;/div&gt;&lt;pre&gt;安全且幂等&lt;br&gt;获取表示&lt;br&gt;变更时获取表示（缓存）&lt;br&gt;200（OK） - 表示已在响应中发出&lt;br&gt;204（无内容） - 资源有空表示&lt;br&gt;301（Moved Permanently） - 资源的URI已被更新&lt;br&gt;303（See Other） - 其他（如，负载均衡）&lt;br&gt;304（not modified）- 资源未更改（缓存）&lt;br&gt;400 （bad request）- 指代坏请求（如，参数错误）&lt;br&gt;404 （not found）- 资源不存在&lt;br&gt;406 （not acceptable）- 服务端不支持所需表示&lt;br&gt;500 （internal server error）- 通用错误响应&lt;br&gt;503 （Service Unavailable）- 服务端当前无法处理请求&lt;/pre&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;POST（添加）&lt;/b&gt;&lt;/div&gt;&lt;pre&gt;不安全且不幂等&lt;br&gt;使用服务端管理的（自动产生）的实例号创建资源&lt;br&gt;创建子资源&lt;br&gt;部分更新资源&lt;br&gt;如果没有被修改，则不过更新资源（乐观锁）&lt;br&gt;200（OK）- 如果现有资源已被更改&lt;br&gt;201（created）- 如果新资源被创建&lt;br&gt;202（accepted）- 已接受处理请求但尚未完成（异步处理）&lt;br&gt;301（Moved Permanently）- 资源的URI被更新&lt;br&gt;303（See Other）- 其他（如，负载均衡）&lt;br&gt;400（bad request）- 指代坏请求&lt;br&gt;404 （not found）- 资源不存在&lt;br&gt;406 （not acceptable）- 服务端不支持所需表示&lt;br&gt;409 （conflict）- 通用冲突&lt;br&gt;412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）&lt;br&gt;415 （unsupported media type）- 接受到的表示不受支持&lt;br&gt;500 （internal server error）- 通用错误响应&lt;br&gt;503 （Service Unavailable）- 服务当前无法处理请求&lt;/pre&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;PUT（修改）&lt;/b&gt;&lt;/div&gt;&lt;pre&gt;不安全但幂等&lt;br&gt;用客户端管理的实例号创建一个资源&lt;br&gt;通过替换的方式更新资源&lt;br&gt;如果未被修改，则更新资源（乐观锁）&lt;br&gt;200 （OK）- 如果已存在资源被更改&lt;br&gt;201 （created）- 如果新资源被创建&lt;br&gt;301（Moved Permanently）- 资源的URI已更改&lt;br&gt;303 （See Other）- 其他（如，负载均衡）&lt;br&gt;400 （bad request）- 指代坏请求&lt;br&gt;404 （not found）- 资源不存在&lt;br&gt;406 （not acceptable）- 服务端不支持所需表示&lt;br&gt;409 （conflict）- 通用冲突&lt;br&gt;412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）&lt;br&gt;415 （unsupported media type）- 接受到的表示不受支持&lt;br&gt;500 （internal server error）- 通用错误响应&lt;br&gt;503 （Service Unavailable）- 服务当前无法处理请求&lt;/pre&gt;&lt;p&gt;&lt;b&gt;DELETE（删除）&lt;/b&gt;&lt;/p&gt;&lt;pre&gt;不安全但幂等&lt;br&gt;删除资源&lt;br&gt;200 （OK）- 资源已被删除&lt;br&gt;301 （Moved Permanently）- 资源的URI已更改&lt;br&gt;303 （See Other）- 其他，如负载均衡&lt;br&gt;400 （bad request）- 指代坏请求&lt;br&gt;404 （not found）- 资源不存在&lt;br&gt;409 （conflict）- 通用冲突&lt;br&gt;500 （internal server error）- 通用错误响应&lt;br&gt;503 （Service Unavailable）- 服务端当前无法处理请求&lt;/pre&gt;&lt;p&gt;下面我们来看一些实践中常见的问题:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;POST和PUT用于创建资源时有什么区别?&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;POST和PUT在创建资源的区别在于，所创建的资源的名称(URI)是否由客户端决定。 例如为我的博文增加一个java的分类，生成的路径就是分类名/categories/java，那么就可以采用PUT方法。不过很多人直接把POST、GET、PUT、DELETE直接对应上CRUD，例如在一个典型的rails实现的RESTful应用中就是这么做的。&lt;/p&gt;&lt;p&gt;我认为，这是因为rails默认使用服务端生成的ID作为URI的缘故，而不少人就是通过rails实践REST的，所以很容易造成这种误解。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;2.客户端不一定都支持这些HTTP方法吧?&lt;/p&gt;&lt;p&gt;的确有这种情况，特别是一些比较古老的基于浏览器的客户端，只能支持GET和POST两种方法。&lt;/p&gt;&lt;p&gt;在实践上，客户端和服务端都可能需要做一些妥协。例如rails框架就支持通过隐藏参数_method=DELETE来传递真实的请求方法， 而像Backbone这样的客户端MVC框架则允许传递_method传输和设置X-HTTP-Method-Override头来规避这个问题。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;3.统一接口是否意味着不能扩展带特殊语义的方法?&lt;/p&gt;&lt;p&gt;统一接口并不阻止你扩展方法，只要方法对资源的操作有着具体的、可识别的语义即可，并能够保持整个接口的统一性。&lt;/p&gt;&lt;p&gt;像WebDAV就对HTTP方法进行了扩展，增加了LOCK、UPLOCK等方法。而github的API则支持使用PATCH方法来进行issue的更新，例如:&lt;/p&gt;&lt;pre&gt;PATCH /repos/:owner/:repo/issues/:number&lt;/pre&gt;&lt;p&gt;不过，需要注意的是，像PATCH这种不是HTTP标准方法的，服务端需要考虑客户端是否能够支持的问题。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 4.统一资源接口对URI有什么指导意义?&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;统一资源接口要求使用标准的HTTP方法对资源进行操作，所以URI只应该来表示资源的名称，而不应该包括资源的操作（url不能有动词，只能有名词）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;通俗来说，URI不应该使用动作来描述。例如，下面是一些不符合统一接口要求的URI:&lt;/p&gt;&lt;pre&gt;GET /getUser/1&lt;br&gt;POST /createUser&lt;br&gt;PUT /updateUser/1&lt;br&gt;DELETE /deleteUser/1&lt;/pre&gt;&lt;p&gt;如果GET请求增加计数器，这是否违反安全性?&lt;/p&gt;&lt;p&gt;安全性不代表请求不产生副作用，例如像很多API开发平台，都对请求流量做限制。像github，就会限制没有认证的请求每小时只能请求60次。&lt;/p&gt;&lt;p&gt;但客户端不是为了追求副作用而发出这些GET或HEAD请求的，产生副作用是服务端&quot;自作主张&quot;的。&lt;/p&gt;&lt;p&gt;另外，服务端在设计时，也不应该让副作用太大，因为客户端认为这些请求是不会产生副作用的。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;符合统一资源接口的restful api&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;GET /user/1&lt;br&gt;POST /user&lt;br&gt;PUT /user/1&lt;br&gt;DELETE /user/1&lt;/pre&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 5.直接忽视缓存可取吗?&lt;/p&gt;&lt;p&gt;即使你按各个动词的原本意图来使用它们，你仍可以轻易禁止缓存机制。 最简单的做法就是在你的HTTP响应里增加这样一个报头： Cache-control: no-cache。 但是，同时你也对失去了高效的缓存与再验证的支持(使用Etag等机制)。&lt;/p&gt;&lt;p&gt;对于客户端来说，在为一个REST式服务实现程序客户端时，也应该充分利用现有的缓存机制，以免每次都重新获取表示。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 6.响应代码的处理有必要吗?&lt;/p&gt;&lt;p&gt;HTTP的响应代码可用于应付不同场合，正确使用这些状态代码意味着客户端与服务器可以在一个具备较丰富语义的层次上进行沟通。&lt;/p&gt;&lt;p&gt;例如，201（&quot;Created&quot;）响应代码表明已经创建了一个新的资源，其URI在Location响应报头里。&lt;/p&gt;&lt;p&gt;假如你不利用HTTP状态代码丰富的应用语义，那么你将错失提高重用性、增强互操作性和提升松耦合性的机会。&lt;/p&gt;&lt;p&gt;如果这些所谓的RESTful应用必须通过响应实体才能给出错误信息，那么SOAP就是这样的了，它就能够满足了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n                                                                                        ',0,'2016-08-19 00:00:00','23',44),(120,1,'关于 缓存穿透、缓存击穿、缓存雪崩、热点数据失效问题的解决方案','','&lt;div&gt;在我们的平常的项目中多多少少都会使用到缓存，因为一些数据我们没有必要每次查询的时候都去查询到数据库。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;特别是高 QPS( QPS（Query Per Second），QPS 其实是衡量吞吐量（Throughput）的一个常用指标，就是说服务器在一秒的时间内处理了多少个请求) 的系统，每次都去查询数据库，对于你的数据库来说将是灾难。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;今天我们不牵涉多级缓存的知识，就把系统使用到的缓存方案，不管是一级还是多级的都统称为缓存，主要是为了讲述使用缓存的时候可能会遇到的一些问题以及一些解决办法。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;我们使用缓存时，我们的业务系统大概的调用流程如下图：&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190417/c55a395c33e063a60dae93cd949fe339.png&quot; data-filename=&quot;img&quot; style=&quot;width: 362px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;一、缓存穿透&lt;/b&gt;&lt;/div&gt;&lt;div&gt;1.1 什么是缓存穿透&lt;/div&gt;&lt;div&gt;正常情况下，我们去查询数据都是存在。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;那么请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这种查询不存在数据的现象我们称为缓存穿透。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1.2 穿透带来的问题&lt;/div&gt;&lt;div&gt;试想一下，如果有黑客会对你的系统进行攻击，拿一个不存在的id 去查询数据，会产生大量的请求到数据库去查询。可能会导致你的数据库由于压力过大而宕掉。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.1 解决办法&lt;/div&gt;&lt;div&gt;2.1.1 缓存空值&lt;/div&gt;&lt;div&gt;之所以会发生穿透，就是因为缓存中没有存储这些空数据的key。从而导致每次查询都到数据库去了。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;那么我们就可以为这些key对应的值设置为null 丢到缓存里面去。后面再出现查询这个key 的请求的时候，直接返回null 。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这样，就不用在到数据库中去走一圈了，但是别忘了设置过期时间。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.1.2 BloomFilter&lt;/div&gt;&lt;div&gt;BloomFilter 类似于一个hbase set 用来判断某个元素（key）是否存在于某个集合中（事先把数据库中存在的key保存在一个集合中，然后对请求的key基于该集合做判断）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这种方式在大数据场景应用比较多，比如 Hbase 中使用它去判断数据是否在磁盘上。还有在爬虫场景判断url 是否已经被爬取过。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这种方案可以加在第一种方案中，在缓存之前在加一层 BloomFilter ，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 -&amp;gt; 查 DB。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;流程图如下：&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190417/6ac32508a65a73094521f7b41efc54ec.png&quot; data-filename=&quot;img&quot; style=&quot;width: 316px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;2.2.1&lt;b&gt; 如何选择&lt;/b&gt;&lt;/div&gt;&lt;div&gt;针对于一些恶意攻击，攻击带过来的大量key 是不存在的，那么我们采用第一种方案就会缓存大量不存在key的数据。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;此时我们采用第一种方案就不合适了，我们完全可以先对使用第二种方案进行过滤掉这些key。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;针对这种key异常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用第二种方案直接过滤掉。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;而对于空数据的key有限的，重复率比较高的，我们则可以采用第一种方式进行缓存。&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;二、 缓存击穿&lt;/b&gt;&lt;/div&gt;&lt;div&gt;3.1 什么是击穿&lt;/div&gt;&lt;div&gt;缓存击穿是我们可能遇到的第二个使用缓存方案可能遇到的问题。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在平常高并发的系统中，大量的请求同时查询一个 key 时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们称为缓存击穿。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.2 会带来什么问题&lt;/div&gt;&lt;div&gt;会造成某一时刻数据库请求量过大，压力剧增。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.3 如何解决&lt;/div&gt;&lt;div&gt;上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;三、缓存雪崩&lt;/b&gt;&lt;/div&gt;&lt;div&gt;3.1 什么是缓存雪崩&lt;/div&gt;&lt;div&gt;缓存雪崩的情况是说，当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上面。结果就是DB 称不住，挂掉。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.2 解决办法&lt;/div&gt;&lt;div&gt;3.2.1 事前：&lt;/div&gt;&lt;div&gt;使用集群缓存，保证缓存服务的高可用&lt;/div&gt;&lt;div&gt;这种方案就是在发生雪崩前对缓存集群实现高可用，如果是使用 Redis，可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.2.2 事中：&lt;/div&gt;&lt;div&gt;ehcache本地缓存 + Hystrix限流&amp;amp;降级,避免MySQL被打死&lt;/div&gt;&lt;div&gt;使用 ehcache 本地缓存的目的也是考虑在 Redis Cluster 完全不可用的时候，ehcache 本地缓存还能够支撑一阵。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;使用 Hystrix进行限流 &amp;amp; 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;然后去调用我们自己开发的降级组件（降级），比如设置的一些默认值呀之类的。以此来保护最后的 MySQL 不会被大量的请求给打死。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.2.3 事后：&lt;/div&gt;&lt;div&gt;开启Redis持久化机制，尽快恢复缓存集群&lt;/div&gt;&lt;div&gt;一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;四、解决热点数据集中失效问题&lt;/b&gt;&lt;/div&gt;&lt;div&gt;我们在设置缓存的时候，一般会给缓存设置一个失效时间，过了这个时间，缓存就失效了。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;对于一些热点的数据来说，当缓存失效以后会存在大量的请求过来，然后打到数据库去，从而可能导致数据库崩溃的情况。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;4.1 解决办法&lt;/div&gt;&lt;div&gt;4.1.1 设置不同的失效时间&lt;/div&gt;&lt;div&gt;为了避免这些热点的数据集中失效，那么我们在设置缓存过期时间的时候，我们让他们失效的时间错开。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;比如在一个基础的时间上加上或者减去一个范围内的随机值。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;4.1.2 互斥锁&lt;/div&gt;&lt;div&gt;结合上面的击穿的情况，在第一个请求去查询数据库的时候对他加一个互斥锁，其余的查询请求都会被阻塞住，直到锁被释放，从而保护数据库。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;但是也是由于它会阻塞其他的线程，此时系统吞吐量会下降。需要结合实际的业务去考虑是否要这么做。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n                                                            ',0,'2017-08-17 00:00:00','16',55),(121,1,'java集合继承关系图汇总','','\n                                \n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在 Java中，有一套设计优良的接口和类组成了Java集合框架Collection，使程序员操作成批的数据或对象元素极为方便。这些接口和类有很多对抽象数据类型操作的API，而这是我们常用的且在数据结构中熟知的。例如Map，Set，List等。并且Java用面向对象的设计对这些数据结构和算法进行了封装，这就极大的减化了程序员编程时的负担。程序员也可以以这个集合框架为基础，定义更高级别的数据抽象，比如栈、队列和线程安全的集合等，从而满足自己的需要。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Java的集合框架，抽其核心，主要有三种：List、Set和Map。如下图所示：&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190417/39c753b5625bf59951e61a0071c93c78.png&quot; data-filename=&quot;img&quot; style=&quot;width: 656px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190418/2a2458de6418e4a79ae0203552e5fda4.gif&quot; data-filename=&quot;img&quot; style=&quot;width: 643px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;需要注意的是，这里的 Collection、List、Set和Map都是接口（Interface），不是具体的类实现。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;1、Iterator接口&lt;/b&gt;&lt;/div&gt;&lt;div&gt;　　Iterator接口，这是一个用于遍历集合中元素的接口，主要包含hashNext(),next(),remove()三种方法。它的一个子接口LinkedIterator在它的基础上又添加了三种方法，分别是add(),previous(),hasPrevious()。也就是说如果是先Iterator接口，那么在遍历集合中元素的时候，只能往后遍历，被遍历后的元素不会在遍历到，通常无序集合实现的都是这个接口，比如HashSet，HashMap；而那些元素有序的集合，实现的一般都是LinkedIterator接口，实现这个接口的集合可以双向遍历，既可以通过next()访问下一个元素，又可以通过previous()访问前一个元素，比如ArrayList。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　抽象类的使用。如果要自己实现一个集合类，去实现那些抽象的接口会非常麻烦，工作量很大。这个时候就可以使用抽象类，这些抽象类中给我们提供了许多现成的实现，我们只需要根据自己的需求重写一些方法或者添加一些方法就可以实现自己需要的集合类，工作流昂大大降低。&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;2、Collection （集合的最大接口）继承关系&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　——List　可以存放重复的内容&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　——Set　　不能存放重复的内容，所以的重复内容靠hashCode()和equals()两个方法区分&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　——Queue　　队列接口&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　——SortedSet　　可以对集合中的数据进行排序&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　Collection定义了集合框架的共性功能。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190417/0be403808e653bedc549d2eea1d8f0e8.png&quot; data-filename=&quot;img&quot; style=&quot;width: 832px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;注：&lt;/span&gt;add方法的参数类型是Object。以便于接收任意类型对象。&lt;/div&gt;&lt;div&gt;集合中存储的都是对象的引用(地址)。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;3、List的常用子类&lt;/span&gt;&lt;/div&gt;&lt;div&gt;　　特有方法。凡是可以操作角标的方法都是该体系特有的方法。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190417/900759de8deafaed747b277f48e9b07f.png&quot; data-filename=&quot;img&quot; style=&quot;width: 791px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;注：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;——ArrayList 　　线程不安全，查询速度快&lt;/div&gt;&lt;div&gt;——Vector　　线程安全，但速度慢，已被ArrayList替代&lt;/div&gt;&lt;div&gt;——LinkedList　　链表结果，增删速度快&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;4、Set接口&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　Set：元素是无序(存入和取出的顺序不一定一致)，元素不可以重复。&lt;/div&gt;&lt;div&gt;　　——HashSet:底层数据结构是哈希表。是线程不安全的。不同步。&lt;/div&gt;&lt;div&gt;　　　　HashSet是如何保证元素唯一性的呢？&lt;/div&gt;&lt;div&gt;　　　　是通过元素的两个方法，hashCode和equals来完成。&lt;/div&gt;&lt;div&gt;　　　　如果元素的HashCode值相同，才会判断equals是否为true。&lt;/div&gt;&lt;div&gt;　　　　如果元素的hashcode值不同，不会调用equals。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　　　注意,对于判断元素是否存在，以及删除等操作，依赖的方法是元素的hashcode和equals方法。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　——TreeSet：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　　　有序的存放：TreeSet　　线程不安全，可以对Set集合中的元素进行排序&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　　　通过compareTo或者compare方法来保证元素的唯一性，元素以二叉树的形式存放。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;5、Object类&lt;/span&gt;&lt;/div&gt;&lt;div&gt;　　在实际开发中经常会碰到区分同一对象的问题，一个完整的类最好覆写Object类的hashCode()、equals()、toString()三个方法。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;6、集合的输出&lt;/span&gt;&lt;/div&gt;&lt;div&gt;　　——4种常见的输出方式&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　——Iterator： 迭代输出，使用最多的输出方式&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　——ListIterator： Iterator的子接口，专门用于输出List中的内容&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　——Enumeration&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　——foreach&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　在迭代时，不可以通过集合对象的方法操作集合中的元素，因为会发生ConcurrentModificationException异常。所以，在迭代器时，只能用迭代器的放过操作元素，可是Iterator方法是有限的，只能对元素进行判断，取出，删除的操作，如果想要其他的操作如添加，修改等，就需要使用其子接口，ListIterator。该接口只能通过List集合的listIterator方法获取。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;7、Map接口&lt;/span&gt;&lt;/div&gt;&lt;div&gt;　　Correction、Set、List接口都属于单值的操作，而Map中的每个元素都使用key——&amp;gt;value的形式存储在集合中。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　Map集合：该集合存储键值对。一对一对往里存。而且要保证键的唯一性。&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190417/06110bd18d49b8e14638056ee8c98cba.png&quot; data-filename=&quot;img&quot; style=&quot;width: 936px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;8、Map接口的常用子类&lt;/span&gt;&lt;/div&gt;&lt;div&gt;　　Map&lt;/div&gt;&lt;div&gt;　　——HashMap：底层是哈希表数据结构，允许使用 null 值和 null 键，该集合是不同步的。将hashtable替代，jdk1.2.效率高。&lt;/div&gt;&lt;div&gt;　　——TreeMap：底层是二叉树数据结构。线程不同步。可以用于给map集合中的键进行排序。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;9、集合工具类&lt;/span&gt;&lt;/div&gt;&lt;div&gt;　　Collections:集合框架的工具类。里面定义的都是静态方法。&lt;/div&gt;&lt;div&gt;　　Collections和Collection有什么区别？&lt;/div&gt;&lt;div&gt;　　　　Collection是集合框架中的一个顶层接口，它里面定义了单列集合的共性方法。&lt;/div&gt;&lt;div&gt;　　　　　　它有两个常用的子接口，&lt;/div&gt;&lt;div&gt;　　　　　　——List：对元素都有定义索引。有序的。可以重复元素。&lt;/div&gt;&lt;div&gt;　　　　　　——Set：不可以重复元素。无序。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　　　Collections是集合框架中的一个工具类。该类中的方法都是静态的。&lt;/div&gt;&lt;div&gt;　　　　　　提供的方法中有可以对list集合进行排序，二分查找等方法。&lt;/div&gt;&lt;div&gt;　　　　　　通常常用的集合都是线程不安全的。因为要提高效率。&lt;/div&gt;&lt;div&gt;　　　　　　如果多线程操作这些集合时，可以通过该工具类中的同步方法，将线程不安全的集合，转换成安全的。&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;10.总结：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;　　List：add/remove/get/set。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　　　1，ArrayList：其实就是数组，容量一大，频繁增删就是噩梦，适合随机查找；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　　　2，LinkedList：增加了push/[pop|remove|pull]，其实都是removeFirst；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　　　3，Vector：历史遗留产物，同步版的ArrayList，代码和ArrayList太像；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　　　4，Stack：继承自Vector。Java里其实没有纯粹的Stack，可以自己实现，用组合的方式，封装一下LinkedList即可；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　　　5，Queue：本来是单独的一类，不过在SUN的JDK里就是用LinkedList来提供这个功能的，主要方法是offer/pull/peek，因此归到这里呢。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　Set：add/remove。可以用迭代器或者转换成list。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　　　1，HashSet：内部采用HashMap实现的；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　　　2，LinkedHashSet：采用LinkedHashMap实现；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　　　3，TreeSet：TreeMap。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　Map：put/get/remove。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　　　1，HashMap/HashTable：散列表，和ArrayList一样采用数组实现，超过初始容量会对性能有损耗；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　　　2，LinkedHashMap：继承自HashMap，但通过重写嵌套类HashMap.Entry实现了链表结构，同样有容量的问题；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　　　3，Properties：是继承的HashTable。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　　　顺便说一下Arrays.asList，这个方法的实现依赖一个嵌套类，这个嵌套类也叫ArrayList！&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n                                                                                                                    ',0,'2018-01-01 00:00:00','34',39),(122,1,'JavaScript在可编辑DOM中涉及到光标的一些应用场景','','\n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在几天在项目中涉及到一个需求，就是通过光标位置插入自定义内容，因此总结了一下在项目中经常会用到的一些场景&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;&amp;nbsp;&amp;lt;div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;button onclick=&quot;getSelectionText()&quot;&amp;gt;获取光标拖动选中的文本&amp;lt;/button&amp;gt;&amp;amp;nbsp;&amp;lt;button onclick=&quot;getSelectionCoords()&quot;&amp;gt;获取光标坐标&amp;lt;/button&amp;gt;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;amp;nbsp;&amp;lt;button onclick=&quot;insertCustomNodes()&quot;&amp;gt;光标位置插入节点&amp;lt;/button&amp;gt;&amp;nbsp;&lt;br&gt;&amp;lt;/div&amp;gt;&lt;br&gt;&amp;lt;div id=&quot;editable&quot; class=&quot;inputor&quot; contentEditable=&quot;true&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;1.获取鼠标拖动选中的文本&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;function getSelectionText() {&lt;br&gt;&amp;nbsp; &amp;nbsp; var range = window.getSelection().getRangeAt(0)&lt;br&gt;&amp;nbsp; &amp;nbsp; var txt&amp;nbsp; &amp;nbsp;=&amp;nbsp; range.toString() // 获取鼠标拖动选中的纯文本&lt;br&gt;&amp;nbsp; &amp;nbsp; console.log(txt)&amp;nbsp; // offsetTop&lt;br&gt;&amp;nbsp; &amp;nbsp; range.insertNode(span);&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;2.在光标处插入自定义内容&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;function insertCustomNodes() {&lt;br&gt;&amp;nbsp; &amp;nbsp; var range = window.getSelection().getRangeAt(0)&lt;br&gt;&amp;nbsp; &amp;nbsp; var span = document.createElement(&quot;span&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; span.innerText = &quot;插入自定义内容&quot;;&lt;br&gt;&amp;nbsp; &amp;nbsp; range.insertNode(span);&lt;br&gt;&amp;nbsp; &amp;nbsp; range.collapse(true); // 取消文本选中状态&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;3.获取光标的(x,y)坐标值（可以用于编辑时监听某个字符，然后光标处出现提示框）&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;function getSelectionCoords(win) {&lt;br&gt;&amp;nbsp; &amp;nbsp; win = win || window;&lt;br&gt;&amp;nbsp; &amp;nbsp; var doc = win.document;&lt;br&gt;&amp;nbsp; &amp;nbsp; var sel = doc.selection, range, rects, rect;&lt;br&gt;&amp;nbsp; &amp;nbsp; var x = 0, y = 0;&lt;br&gt;&amp;nbsp; &amp;nbsp; if (sel) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (sel.type != &quot;Control&quot;) {&amp;nbsp; // IE下&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; range = sel.createRange();&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; range.collapse(true);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; x = range.boundingLeft;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; y = range.boundingTop;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; } else if (win.getSelection) {&amp;nbsp; //谷歌以及其它浏览器&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; sel = win.getSelection();&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (sel.rangeCount) {&amp;nbsp; //判断是否有光标锚点&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; range = sel.getRangeAt(0);&amp;nbsp; // sel.getRangeAt(0) 获取当前选区内容的区域第一个对象。&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (range.getClientRects) { // 光标在行首时，rects.length == 0&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; range.collapse(true); // 方法可以收起当前选区到一个点&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //getClientRects获取一组描述该对象边框在可视窗口的只读属性——left、top、right和bottom，单位为像素&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; rects = range.getClientRects();&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (rects.length &amp;gt; 0) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; rect = rects[0];&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if(rect){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; x = rect.left;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; y = rect.top;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 当光标在行首时，通过以下方式获取坐标值。&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 原理：通过创建一个零时的元素，并给该元素插入一个占位为零宽度的字符,然后再把该元素insert到当前光标所在位置，&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 通过元素对象的方法 getClientRects() 获取到该元素对象的坐标即为光标的坐标&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if ((x == 0 &amp;amp;&amp;amp; y == 0) || rect === undefined) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var span = doc.createElement(&quot;span&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (span.getClientRects) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 确保跨度的尺寸和位置&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 添加零宽度空格字符 \\u200b&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // doc.createTextNode(&quot;\\u200b&quot;) 创建一个零宽度的节点并且插入到刚刚创建的span对象中，为了不影响光标的坐标值&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; span.appendChild( doc.createTextNode(&quot;wererwer&quot;) );&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; range.insertNode(span);&amp;nbsp; // 利用 insertNode 这个方法我们可以实现在光标处插入自定义内容&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; rect = span.getClientRects()[0];&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; x = rect.left;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; y = rect.top;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var spanParent = span.parentNode;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; spanParent.removeChild(span); // 为了不影响页面内容，所以需要把刚刚创建的span元素移除&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 将所有断开的文本节点重新粘在一起，比如在审查元素时，有时候我们会看到一个文本会出现多个用双引号引起来的单独字符串现象，&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //normalize 可以把多个文本字符串转换成一个用双引号引起来的字符串&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; spanParent.normalize();&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; return { left: x, top: y };&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.liuzaichun.cn/index/index/articledetail.html?article_id=114&quot;&gt;替换光标选中内容&lt;/a&gt;&amp;nbsp;&lt;br&gt;&lt;/p&gt;\n                                                                                        ',0,'2017-07-05 00:00:00','22',37),(123,1,'经典排序之冒泡排序详解','','\n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;冒泡排序 是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;算法描述：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;(1).i从0开始，i与i+1比较，如果i&amp;gt;i+1，那么就互换&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;(2).i不断增加，直到i&amp;lt;n-1（n是数组元素的个数，n-1是数组已经最后一个元素） ，一趟下来，可以让数组元素中最大值排在数组的最后面&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;思路：依次比较&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;相邻的两个数&lt;/span&gt;，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;第一趟比较完成后，最后一个数一定是数组中最大的一个数，所以第二趟比较的时候最后一个数不参与比较；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;第二趟比较完成后，倒数第二个数也一定是数组中第二大的数，所以第三趟比较的时候最后两个数不参与比较；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;依次类推，每一趟比较次数-1；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;……&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#808080;&quot;&gt;// 冒泡排序 描述：依次比较相邻的两个数，把最大的放在最右边&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;int&lt;/span&gt;[] inL = {&lt;span style=&quot;color:#6897bb;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;5&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;8&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;12&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;10&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;15&lt;/span&gt;}&lt;span style=&quot;color:#cc7832;&quot;&gt;;  &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//数组通过下标获取值 inL[0]&lt;br&gt;&lt;/span&gt;System.&lt;span style=&quot;color:#9876aa;font-style:italic;&quot;&gt;out&lt;/span&gt;.println(inL.&lt;span style=&quot;color:#9876aa;&quot;&gt;length&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;int  &lt;/span&gt;temp&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color:#cc7832;&quot;&gt;int &lt;/span&gt;i = &lt;span style=&quot;color:#6897bb;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;/span&gt;i &amp;lt; inL.&lt;span style=&quot;color:#9876aa;&quot;&gt;length &lt;/span&gt;- &lt;span style=&quot;color:#6897bb;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;/span&gt;i++) {  &lt;span style=&quot;color:#808080;&quot;&gt;// 比较n-1趟 （n是数组长度）&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;int &lt;/span&gt;isChange = &lt;span style=&quot;color:#6897bb;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;// 优化处理 ； 判断一趟下来是否发生变化，每趟都要重置&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;for &lt;/span&gt;(&lt;span style=&quot;color:#cc7832;&quot;&gt;int &lt;/span&gt;j = &lt;span style=&quot;color:#6897bb;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;j &amp;lt; inL.&lt;span style=&quot;color:#9876aa;&quot;&gt;length &lt;/span&gt;- &lt;span style=&quot;color:#6897bb;&quot;&gt;1 &lt;/span&gt;- i &lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;j++) {  &lt;span style=&quot;color:#808080;&quot;&gt;// 每趟下来都会确定一个最大的数，所以每趟会少比较一个数&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;if&lt;/span&gt;(inL[j] &amp;gt; inL[j+&lt;span style=&quot;color:#6897bb;&quot;&gt;1&lt;/span&gt;]) {&lt;br&gt;               temp = inL[j]&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;               &lt;/span&gt;inL[j] = inL[j+&lt;span style=&quot;color:#6897bb;&quot;&gt;1&lt;/span&gt;]&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;               &lt;/span&gt;inL[j+&lt;span style=&quot;color:#6897bb;&quot;&gt;1&lt;/span&gt;] = temp&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;               &lt;/span&gt;isChange = &lt;span style=&quot;color:#6897bb;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;// 到这里说明数据位置发生变化了&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;            &lt;/span&gt;}&lt;br&gt;    }&lt;br&gt;&lt;br&gt;    &lt;span style=&quot;color:#cc7832;&quot;&gt;if&lt;/span&gt;(isChange == &lt;span style=&quot;color:#6897bb;&quot;&gt;0&lt;/span&gt;) { &lt;span style=&quot;color:#808080;&quot;&gt;// 如果没有发生变化，说明已经是最终的排序结果了，没必要再继续&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;break;  &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//跳出循环&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;}&lt;br&gt;}&lt;br&gt;&lt;br&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color:#cc7832;&quot;&gt;int &lt;/span&gt;num:inL){&lt;br&gt;    System.&lt;span style=&quot;color:#9876aa;font-style:italic;&quot;&gt;out&lt;/span&gt;.print(num+&lt;span style=&quot;color:#6a8759;&quot;&gt;&quot; &quot;&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt; &lt;/span&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\n                                                                                        ',0,'2017-07-14 00:00:00','23,34',65),(124,1,'经典排序之选择排序详解','','\n                                \n                                &lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;选择排序&lt;/span&gt;(Selection sort)是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小(或最大)的一个元素，存放在序列的起始(末尾)位置，直到全部待排序的数据元素排完。选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;上面提到了选择排序是不稳定的排序方法，那我们的冒泡排序是不是稳定的排序方法呢？稳定的意思指的是什么呢？&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;判断某排序算法是否稳定，我们可以简单理解成：排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果相同，则是稳定的排序方法。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果不相同，则是不稳定的排序方法&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果排序前的数组是[3,3,1]，假定我们使用选择排序的话，那第一趟排序后结果就是[1,3,3]。这个数组有两个相同的值，它俩在array[0]和array[1]，结果经过排序，array[0]的跑到了array[2]上了。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;那么这就导致：2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序不相同，因此，我们就说它是不稳定的&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;再回到上面的问题，上一篇说讲的冒泡排序是稳定的，主要原因是：俩俩比较的时候，没有对相等的数据进行交换(因为没必要)。因此它不存在2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序不相同。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;那么稳定排序的好处是什么？&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;参考知乎回答@独行侠的回答：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 255);&quot;&gt;如果我们只对一串数字排序，那么稳定与否确实不重要，因为一串数字的属性是单一的，就是数字值的大小。但是排序的元素往往不只有一个属性，例如我们对一群人按年龄排序，但是人除了年龄属性还有身高体重属性，在年龄相同时如果不想破坏原先身高体重的次序，就必须用稳定排序算法.&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 255);&quot;&gt;很清晰的指出，只有当在“二次”排序时不想破坏原先次序，稳定性才有意义&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;描述：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;选择排序--它的工作原理是每一次从待排序的数据元素中选出最小(或最大)的一个元素，存放在序列的起始(末尾)位置，直到全部待排序的数据元素排完。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;算法思路&lt;/span&gt;：数组是需要n-1趟排序，每趟比较我们都是&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;假设选择角标为0&lt;/span&gt;的数为最大或最小值然后（数组中第一个数）开始与剩余待排序的数比较，由于每趟下来都会从待排序的数中确定一个最大或最小值，所以每趟都会减少比较一个数&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;选择排序与冒泡排序&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;区别&lt;/span&gt;：冒泡排序是两个相邻的数互相比较，比如冒泡排序中{3,3,2} 第一个数与第二个数相等，不交换位置，接着是第二个与第三个比较，不相等才交换位置。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;而选择排序中{3,3,2} 第一数与第二个数相等不交换位置，接着第一个数与第三个数比较，不相等才交换位置。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;相同点&lt;/span&gt;：两者每趟下来都可以找到最大或最小的数&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;int&lt;/span&gt;[] sL ={&lt;span style=&quot;color:#6897bb;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;5&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;8&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;112&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;10&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;15&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;13&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;20&lt;/span&gt;}&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;for &lt;/span&gt;(&lt;span style=&quot;color:#cc7832;&quot;&gt;int &lt;/span&gt;i = &lt;span style=&quot;color:#6897bb;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;i &amp;lt; sL.&lt;span style=&quot;color:#9876aa;&quot;&gt;length - 1 &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;i++) { &lt;span style=&quot;color:#808080;&quot;&gt;// 比较趟数&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;int &lt;/span&gt;pos = &lt;span style=&quot;color:#6897bb;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;// 每趟都选择假设下标为0即第一个数为最大或最小值&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;for &lt;/span&gt;(&lt;span style=&quot;color:#cc7832;&quot;&gt;int &lt;/span&gt;j = &lt;span style=&quot;color:#6897bb;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;j &amp;lt; sL.&lt;span style=&quot;color:#9876aa;&quot;&gt;length &lt;/span&gt;- i&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;j++) {&lt;br&gt;        &lt;span style=&quot;color:#cc7832;&quot;&gt;if&lt;/span&gt;(sL[j] &amp;gt; sL[pos]) {&lt;br&gt;             pos = j&lt;span style=&quot;color:#cc7832;&quot;&gt;;  &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;// 记录最大（或最小）的数的下标&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        &lt;/span&gt;}&lt;br&gt;    }&lt;br&gt;    &lt;br&gt;    &lt;span style=&quot;color:#808080;&quot;&gt;// 一趟下来已经确定了最大（或最小的下标），用下标对应的数与待排序中最后一位交换位置&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;int &lt;/span&gt;temp = sL[pos]&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;sL[pos] = sL[sL.&lt;span style=&quot;color:#9876aa;&quot;&gt;length &lt;/span&gt;- i - &lt;span style=&quot;color:#6897bb;&quot;&gt;1&lt;/span&gt;]&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;sL[sL.&lt;span style=&quot;color:#9876aa;&quot;&gt;length &lt;/span&gt;- i - &lt;span style=&quot;color:#6897bb;&quot;&gt;1&lt;/span&gt;] = temp&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;}&lt;br&gt;&lt;br&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;for &lt;/span&gt;(&lt;span style=&quot;color:#cc7832;&quot;&gt;int &lt;/span&gt;num : sL) {&lt;br&gt;    System.&lt;span style=&quot;color:#9876aa;font-style:italic;&quot;&gt;out&lt;/span&gt;.print(num + &lt;span style=&quot;color:#6a8759;&quot;&gt;&quot; &quot;&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 255, 255);&quot;&gt;阿萨德&lt;/span&gt;&lt;/div&gt;\n                                                                                                                    ',0,'2017-07-14 00:00:00','23,34',35),(125,1,'经典排序之插入排序详解','','\n                                \n                                &lt;p&gt;插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。&lt;/p&gt;&lt;p&gt;描述：将一个数据插入到已经排好序的有序数据中&lt;/p&gt;&lt;p&gt;（1）将要排序的是一个乱的数组int[] arrays = {3, 2, 1, 3, 3};&lt;/p&gt;&lt;p&gt;（2）在未知道数组元素的情况下，我们只能把数组的第一个元素作为已经排好序的有序数据，也就是说，把{3}看成是已经排好序的有序数据&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//临时变量&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;int &lt;/span&gt;temp&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//外层循环控制需要排序的趟数(从1开始因为将第0位看成了有序数据)&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;for &lt;/span&gt;(&lt;span style=&quot;color:#cc7832;&quot;&gt;int &lt;/span&gt;i = &lt;span style=&quot;color:#6897bb;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;i &amp;lt; iL.&lt;span style=&quot;color:#9876aa;&quot;&gt;length&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;i++) {&lt;br&gt;&lt;br&gt;    temp = iL[i]&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;// 把需要与排好序的数据比较的数提取出来&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    //已排好序的数据比当前数据要大，那么就进入循环依次与当前数据比较&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;while &lt;/span&gt;(i &amp;gt;= &lt;span style=&quot;color:#6897bb;&quot;&gt;1 &lt;/span&gt;&amp;amp;&amp;amp; iL[i - &lt;span style=&quot;color:#6897bb;&quot;&gt;1&lt;/span&gt;] &amp;gt; temp) {&lt;br&gt;&lt;br&gt;        &lt;span style=&quot;color:#808080;&quot;&gt;//往后退一个位置，让当前数据与之前前位进行比较&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        &lt;/span&gt;iL[i] = iL[i - &lt;span style=&quot;color:#6897bb;&quot;&gt;1&lt;/span&gt;]&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//不断往前，直到退出循环&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        &lt;/span&gt;i--&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;}&lt;br&gt;    &lt;span style=&quot;color:#808080;&quot;&gt;//退出了循环说明找到了合适的位置了，将当前数据插入合适的位置中&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;iL[i] = temp&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;}&lt;br&gt;&lt;br&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;for &lt;/span&gt;(&lt;span style=&quot;color:#cc7832;&quot;&gt;int &lt;/span&gt;num : iL) {&lt;br&gt;    System.&lt;span style=&quot;color:#9876aa;font-style:italic;&quot;&gt;out&lt;/span&gt;.print(num + &lt;span style=&quot;color:#6a8759;&quot;&gt;&quot; &quot;&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190419/d2cdabc0513eff20a40287931040980d.gif&quot; data-filename=&quot;img&quot; style=&quot;width: 300px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                                                        ',0,'2017-07-14 00:00:00','23,34',55),(126,1,'经典排序之快速排序详解','','&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;快速排序：它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;更简单的理解是这样的：在数组中找一个支点(任意),经过一趟排序后，支点左边的数都要比支点小，支点右边的数都要比支点大！&lt;/div&gt;&lt;div&gt;（在生活中，我们在排队的时候，常常也会用这种方式，比如：以某某为基准，快速的按身高又矮到高排列）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;现在我们有一个数组：int arr[]={1,4,5,67,2,7,8,6,9,44};&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;经过一趟排序之后，如果我选择数组中间的数作为支点：7(任意的)，那么第一趟排序后的结果是这样的：{1,4,5,6,2,7,8,67,9,44}&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;那么就实现了支点左边的数比支点小，支点右边的数比支点大&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;递归分析：”左边“的排好顺序，”右边“的排好序，跟我们第一趟排序的做法是一致的，只不过是参数不一样：第一趟排序是任选了一个支点，比支点小的在左边，比支点大的在右边。那么，我们想要”左边“的排好顺序，只要在”左边“部分找一个支点，比支点小的在左边，比支点大的在右边。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;在数组中使用递归往往定义两个变量：L和R，L指向支点左边的数组元素，R指向支点右边的数组元素&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;递归出口也很容易找到：如果数组只有一个元素时，那么就不用排序了&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;快速排序在序列中元素很少时，效率将比较低，不如插入排序，因此一般在序列中元素很少时使用插入排序，这样可以提高整体效率。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;public static void &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;main&lt;/span&gt;(String[] args) {&lt;br&gt;    &lt;span style=&quot;color:#cc7832;&quot;&gt;int&lt;/span&gt;[] qL ={&lt;span style=&quot;color:#6897bb;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;5&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;8&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;112&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;10&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;15&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;13&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;20&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;78&lt;/span&gt;}&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;font-style:italic;&quot;&gt;quickSort&lt;/span&gt;(qL&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;qL.&lt;span style=&quot;color:#9876aa;&quot;&gt;length&lt;/span&gt;-&lt;span style=&quot;color:#6897bb;&quot;&gt;1&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    for &lt;/span&gt;(&lt;span style=&quot;color:#cc7832;&quot;&gt;int &lt;/span&gt;num : qL) {&lt;br&gt;        System.&lt;span style=&quot;color:#9876aa;font-style:italic;&quot;&gt;out&lt;/span&gt;.print( num + &lt;span style=&quot;color:#6a8759;&quot;&gt;&quot; &quot;&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;}&lt;br&gt;}&lt;br&gt;&lt;br&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;/**&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * 快速排序&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; *&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@param &lt;/span&gt;&lt;span style=&quot;color:#8a653b;font-style:italic;&quot;&gt;arr&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#8a653b;font-style:italic;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@param &lt;/span&gt;&lt;span style=&quot;color:#8a653b;font-style:italic;&quot;&gt;L   &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;指向数组第一个元素&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * &lt;/span&gt;&lt;span style=&quot;color:#629755;font-weight:bold;font-style:italic;&quot;&gt;@param &lt;/span&gt;&lt;span style=&quot;color:#8a653b;font-style:italic;&quot;&gt;R   &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;指向数组最后一个元素&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; */&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;public static void &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;quickSort&lt;/span&gt;(&lt;span style=&quot;color:#cc7832;&quot;&gt;int&lt;/span&gt;[] arr&lt;span style=&quot;color:#cc7832;&quot;&gt;, int &lt;/span&gt;L&lt;span style=&quot;color:#cc7832;&quot;&gt;, int &lt;/span&gt;R) {&lt;br&gt;    &lt;span style=&quot;color:#cc7832;&quot;&gt;int &lt;/span&gt;i = L&lt;span style=&quot;color:#cc7832;&quot;&gt;;  &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;// 取名为哨兵i （负责找比支点大的数），站在数组左边向右开始找&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;int &lt;/span&gt;j = R&lt;span style=&quot;color:#cc7832;&quot;&gt;;  &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;// 取名为哨兵j （负责找比支点小的数），站在数组右边向左开始找&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    //任意支点作为一个基准点&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;int &lt;/span&gt;pivot = arr[(L + R) / &lt;span style=&quot;color:#6897bb;&quot;&gt;2&lt;/span&gt;]&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//左右两端进行扫描，只要两端还没有交替，就一直扫描&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;while &lt;/span&gt;(i &amp;lt;= j) {&lt;br&gt;&lt;br&gt;        &lt;span style=&quot;color:#808080;&quot;&gt;//寻找直到比支点大的数&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;while &lt;/span&gt;(pivot &amp;gt; arr[i])&lt;br&gt;            i++&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//寻找直到比支点小的数&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;while &lt;/span&gt;(pivot &amp;lt; arr[j])&lt;br&gt;            j--&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//此时已经分别找到了比支点小的数(右边)、比支点大的数(左边)，它们进行交换&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;if &lt;/span&gt;(i &amp;lt;= j) {&lt;br&gt;            &lt;span style=&quot;color:#cc7832;&quot;&gt;int &lt;/span&gt;temp = arr[i]&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;arr[i] = arr[j]&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;arr[j] = temp&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;i++&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;j--&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;}&lt;br&gt;    }&lt;br&gt;    &lt;span style=&quot;color:#808080;&quot;&gt;//上面一个while保证了第一趟排序支点的左边比支点小，支点的右边比支点大了。&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    //“左边”再做排序，直到左边剩下一个数(递归出口)&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;if &lt;/span&gt;(L &amp;lt; j)&lt;br&gt;        &lt;span style=&quot;font-style:italic;&quot;&gt;quickSort&lt;/span&gt;(arr&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;L&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;j)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//“右边”再做排序，直到右边剩下一个数(递归出口)&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;if &lt;/span&gt;(i &amp;lt; R)&lt;br&gt;        &lt;span style=&quot;font-style:italic;&quot;&gt;quickSort&lt;/span&gt;(arr&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;i&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;R)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;',0,'2017-07-14 00:00:00','23,34',53),(127,1,'http Request Entity Too Large问题的解决方法','','\n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;今日数据提交出现 http:413 错误&lt;/p&gt;&lt;p&gt;经查是上传文件大小被限制了，将服务器限制了上传文件的大小设置成20M，重启服务并没有解决问题。&lt;/p&gt;&lt;p&gt;nginx默认上传传文件的大小限制是1M，在nginx的配置中修改配置后可解决此问题。&lt;/p&gt;&lt;p&gt;解决方法如下：&amp;nbsp;&lt;/p&gt;&lt;pre&gt;server {&lt;br&gt;&amp;nbsp; &amp;nbsp; client_max_body_size 100M;&lt;br&gt;&amp;nbsp; &amp;nbsp; listen&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;80;&lt;br&gt;&amp;nbsp; &amp;nbsp; server_name&amp;nbsp; test.twsapp.com;&lt;br&gt;&amp;nbsp; &amp;nbsp; location /php {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; proxy_pass&amp;nbsp; http://127.0.0.1:81/xxx;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; location / {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return 404;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;更改完nginx&amp;nbsp; -s reload即可&lt;/p&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                            ',0,'2017-07-14 00:00:00','26',67),(133,1,'单点登录的原理解析','','\n                                &lt;p&gt;从巨石应用发展至今，我们有SOA，有微服务，其道理都是一样的，都是进行了业务拆分来分解为多个系统，多个系统完全解耦，可以分别部署在不同的服务器上，项目之间通过rpc或者restful来实现相互通信，举个栗子：&lt;/p&gt;&lt;p&gt;order.abc.com&amp;nbsp; cart.abc.com&amp;nbsp; service.abc.com&lt;/p&gt;&lt;p&gt;有这么3个系统，部署在不同的二级域名下，那么用户每次登陆不同的系统是不是都要登录呢？这样是不合理的，我们不能因为系统的复杂度使得用户也变得复杂，对于用户来说，一套产品就是一个完整的应用。登录一次即可，没有必要多次登录。&lt;/p&gt;&lt;p&gt;按照之前所说的session就不适用了，在这个地方我们就引入了单点登录，保持用户与服务端之间的无状态协议，生成token，使用token这个令牌穿梭在各个系统。&lt;/p&gt;&lt;p&gt;那么这个token放在浏览器cookie即可，失效时间需要和redis的expire一致，根据需求我们可以实现用户登录一次就可以在任何系统中使用，其次用户账户在别的地方登录后，上一个用户则被挤出。&lt;/p&gt;&lt;p&gt;（需要注意的是，这个cookie作为第一方cookie需要对二级域名进行设置，如果要跨域的话需要设置第三方cookie或者使用JWT来做，这个就不多说了)&lt;/p&gt;&lt;p&gt;在这里不讨论用JWT来做单点登入，而是用session数据共享的方式实现单点登入，一般我们把session数据存入redis中。&lt;/p&gt;&lt;p&gt;&lt;b&gt;实现的主要原理：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这里我们需要一个认证中心（SSO服务中心），我们把所有的子系统请求统统都转发到这里来进行验证，比如我们的认证中心服务器 login.abc.com 作为统一的登入入口，其中任何一台服务器进行登入都要把用户数据提交到login.abc.com进行验证，通过后，生成session（全局会发，并保存到redis）, 无论请求哪台服务器，客户端必须要携带一个相同的sessionID到子服务端，子服务端再把这个sessionID发送到认证中心进行认证，认证通过在返回给子系统，此时子系统可以进行业务处理操作&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;用一张图说明整过单点登入的过程：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190423/bcd98b3b131365295c9bd621e716aea4.png&quot; data-filename=&quot;img&quot; style=&quot;width: 652px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Microsoft Yahei&amp;quot;, sans-serif; font-size: 14px;&quot;&gt;如图所示，当用户访问系统1（简称：A）的时候，A发现用户没有登入，于是携带A的地址跳转到认证中心再次验证（这里所谓的跳转我理解应该是请求认证中心的验证接口吧！），发现真的是没有登入。所以跳转到登入页面（这个登入页面是认证中心的统一登入页面，可以参考京东、淘宝网、天猫他们的整个网站都是有很多的子域名的，代表不同的服务器，但是登入页面就只有一个）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: -apple-system, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Microsoft Yahei&amp;quot;, sans-serif; font-size: 14px;&quot;&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;以上所有的实现子系统都是在同一个一级域名的下二级域名，可以通过设置实现cookie共享，打到请求不同的服务器时，sessionID是一样的目的，&lt;/span&gt;&lt;span style=&quot;color: rgb(107, 165, 74);&quot;&gt;如果是完全跨域的系统&lt;/span&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;，需要通过URL来传递参数，实现cookie数据一致&lt;/span&gt;&lt;br&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                            ',0,'2016-06-14 00:00:00','23,34,16',52),(128,1,'集群和分布式实现session共享的关键点是什么？','','\n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这几天一直在看集群和分布式中解决sesstion共享的问题？所以总结了一下&lt;br&gt;&lt;/p&gt;&lt;p&gt;1.session共享现在比较流行的方案是，存储到redis中（key 对应sessionID 、value对应session的值），即集中式管理session数据，让所以的服务器都统一到一个地方去获取session数据。&lt;/p&gt;&lt;p&gt;2.根据redis存储session的方式，要获取对应的session数据，每个服务器必须享有相同的sessionID，怎么享有相同的sessionID呢，这里主要分为几种情况：&lt;/p&gt;&lt;p&gt;（1）、&lt;b&gt;集群&lt;/b&gt;：在集群系统中，我们一般是一个域名/IP对应多个服务器，通过NGINX实现负载均衡，由于只有一个域名，所以不管是哪台服务器设置sesstion，生成的sessionID都是保存在客户端同一个域名下的。因此，每次请求服务器的时候，cookie中sessionID都是一样的，这样的话就解决了，各个服务器接收到的sessionID是相同的。&lt;/p&gt;&lt;p&gt;（2）、&lt;b&gt;分布式&lt;/b&gt;：在分布式系统中存在一个跨域的问题，比如说：淘宝网，里面就有很多子模块系统（login.taobao.com、list.taobao.com等等）但是它们有个特点就是所有的域名都是在同一个顶级域名下的二级域名，要实现sessionID共享，只需要解决其它子域名可以访问同一域下的cookie。所以只需要对 COOKIE 的域（domain）进行特殊地设置即可，以php为例：&lt;/p&gt;&lt;p&gt;如：www.a.com 和 i.a.com 都属于域 .a.com，那么我们就可以设置 COOKIE 的域为 .a.com，这样 www.a.com、i.aaa.com 等等都可以访问此 COOKIE。PHP 代码中的设置方法如下：&lt;/p&gt;&lt;p&gt;ini_set(\'session.cookie_domain\', \'.a.com\');&lt;/p&gt;&lt;p&gt;这样各个系统共享同一客户端 SESSION ID 的目的就达到了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;还有一个跨域的情况就是完全跨域：&lt;/b&gt;（www.a.com www.b.com）&lt;/p&gt;&lt;p&gt;通过URL参数实现跨域信息传递&lt;/p&gt;&lt;p&gt;如果考虑到广泛的兼容性，可最直接的通过url参数传递的方式，重定向到b的url中，b域获取cookie信息，在该域中进行写入。这就只涉及到把a域的信息传递到b中，使用URL传参便可以实现。&lt;/p&gt;&lt;p&gt;浏览器通过访问www.a.com/tg?from=http://www.b.com/set_cookie 重定向到b域的set_cookie方法，传入token参数。这种方法最具有广泛性。&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                            ',0,'2017-07-14 00:00:00','23,34',40),(129,1,'集群中常见的Session问题及解决方案','','\n                                &lt;p&gt;1，session丢失问题。比如说用户一个用户登录了，然后这个用户登陆状态保存session中存放在一台服务器，但是突然这台机器挂了，这时候他的指向指向到另一台机器了，这个时候他的那个登录状态就会消失，就没有登录状态，用户在上一步操作，是登录了，下一步操作就需要重新登陆，这种这种就是session丢失的问题。&lt;/p&gt;&lt;p&gt;2，session管理。还有常见的，比如说像什么电子商务，一些网站吗？比如说增加购物车啊，你可能这次请求请留到这个服务器可能就挂了，你加购物车，你的session状态是不存在的，那这时候你就要重新登录，所以这个就是session丢失的问题，session管理是集群中的一个最大的一个难题。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一般有三种解决方案：&lt;/p&gt;&lt;p&gt;第一：session复制&lt;/p&gt;&lt;p&gt;第二：基于ip地址发起的负载均衡策略&lt;/p&gt;&lt;p&gt;第三：session单独集中管理放入缓存/数据库&lt;/p&gt;&lt;p&gt;第一种：Session复制，集群的服务器，同步session。session对象是每台服务器保存，比如说用户登陆这台服务器，session也保存在这台应用服务器中，那这个时候会把同步复制到另一台服务器.&lt;/p&gt;&lt;p&gt;这种方案存在两个问题：（1）全部重复复制耗内存，如果集群部署很大，那将将耗费系统的大量资源。（2）session同步会有延时，尤其不同服务器部署不同机房，网络传输。&lt;/p&gt;&lt;p&gt;第二种：基于ip地址发起的负载均衡策略，就是通过负载均衡的方式，比如说你一个ip地址，然后利用这个请求的IP，哈希算哈希算法实现，然后就是你同一个ip地址，计算出来一个哈希值，就只指向同一个服务器，也可以根据COOkie将同一个请求分发到同一个服务器上。&lt;/p&gt;&lt;p&gt;这样也会存在两个问题：（1）一台服务器宕机挂掉了，然后这个这个服务器上面所有的session全部都丢失了，这个时候，比如这个用户这数据访问，那么就请求就会转发到另一台服务器上，那这个时候，就用户状态就不不存在了。（2）当需要扩展的时候，比如说你现在两台吧，假如我再加入一台服务器，最后三台那个哈希算法就需要再做调整，这个所以导致哈希算法指向就不是之前一台服务器可能，造成session丢失。&lt;/p&gt;&lt;p&gt;第三种（最佳）：session单独集中管理放入缓存/数据库。这种方式目前来说，采用可能是最优的一种方案了，就专门搞一台服务器存放session，然后session集群，进行统一管理，管理也比较方便。即使你的应用服务器重启了或宕机，也不会造成session的丢失，而且它灵活性也比较高，即使应用服务器以后再扩展，对session影响不大，因为应用服务器跟那个session可存放不同的服务器&lt;/p&gt;&lt;p&gt;缺点就是可能，你要单独部署，需要添加新的机器，然后呢把这个当做缓存缓存，也有一定的网络应用网络延时，有几个注意事项，比如你放缓存（一般是redis里面）,你这个session里面对象要是可序列化的，另一个session失效时间是缓存的时间，而不是应用服务器配置的。&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                            ',0,'2017-07-14 00:00:00','23,34',42),(134,1,'Python操作FTP时，TimeoutError: [WinError 10060] 由于连接方在一段时间后没有正确答复或连接的主机没有反应，连接尝试失败。','','\n                                &lt;div&gt;利用python中ftplib模块自带的方法，用于FTP操作时获取信息的，但是总是报错：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;File &quot;D:\\Anaconda3\\lib\\ftplib.py&quot;, line 559, in nlst&lt;br&gt;&amp;nbsp; &amp;nbsp; self.retrlines(cmd, files.append)&lt;br&gt;&amp;nbsp; File &quot;D:\\Anaconda3\\lib\\ftplib.py&quot;, line 468, in retrlines&lt;br&gt;&amp;nbsp; &amp;nbsp; with self.transfercmd(cmd) as conn, \\&lt;br&gt;&amp;nbsp; File &quot;D:\\Anaconda3\\lib\\ftplib.py&quot;, line 399, in transfercmd&lt;br&gt;&amp;nbsp; &amp;nbsp; return self.ntransfercmd(cmd, rest)[0]&lt;br&gt;&amp;nbsp; File &quot;D:\\Anaconda3\\lib\\ftplib.py&quot;, line 361, in ntransfercmd&lt;br&gt;&amp;nbsp; &amp;nbsp; source_address=self.source_address)&lt;br&gt;&amp;nbsp; File &quot;D:\\Anaconda3\\lib\\socket.py&quot;, line 724, in create_connection&lt;br&gt;&amp;nbsp; &amp;nbsp; raise err&lt;br&gt;&amp;nbsp; File &quot;D:\\Anaconda3\\lib\\socket.py&quot;, line 713, in create_connection&lt;br&gt;&amp;nbsp; &amp;nbsp; sock.connect(sa)&lt;br&gt;TimeoutError: [WinError 10060] 由于连接方在一段时间后没有正确答复或连接的主机没有反应，连接尝试失败。&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;很可能是主动和被动模式之间的冲突。确保满足以下条件之一：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;首先确保服务器支持PASV模式，并且您的客户端正在设置PASV模式，如果服务器不支持被动模式，则防火墙必须支持主动模式FTP传输。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;文档中说到，在Python 2.1及更高版本中默认为被动模式。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在活动模式（非PASV）中，客户端发送PORT命令，告诉服务器在该端口上启动DATA连接，这需要您的防火墙知道PORT命令，以便它可以将传入的DATA连接转发给您 - 几乎没有防火墙支持这个。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在被动模式下，客户端打开DATA连接，服务器使用它（服务器在打开数据连接时是“被动”）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果没有使用被动模式，请执行ftp.set_pasv(True)并查看是否会产生影响。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在这里，我的需求是需要主动模式！&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;解决办法&lt;/div&gt;&lt;div&gt;在发送FTP登陆请求的代码中，加入：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;ftp.set_pasv(False) # 如果被动模式由于某种原因失败，请尝试使用活动模式。&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;客户端连接FTP服务端代码：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;host = \'47.***.**9.1**\'&amp;nbsp; #FTP主机&lt;br&gt;user = &quot;***&quot;&lt;br&gt;password = &quot;****&quot;&lt;br&gt;buffer_size = 8192&lt;br&gt;port = 21&lt;br&gt;def ftpconnect():&lt;br&gt;&amp;nbsp; &amp;nbsp; ftp_server = host&lt;br&gt;&amp;nbsp; &amp;nbsp; username = user&lt;br&gt;&amp;nbsp; &amp;nbsp; passwords = password&lt;br&gt;&amp;nbsp; &amp;nbsp; ftp = FTP()&lt;br&gt;&amp;nbsp; &amp;nbsp; ftp.set_debuglevel(2)&lt;br&gt;&amp;nbsp; &amp;nbsp; ftp.connect(ftp_server, port)&lt;br&gt;&amp;nbsp; &amp;nbsp; ftp.login(username, passwords)&lt;br&gt;&amp;nbsp; &amp;nbsp; ftp.set_pasv(False)&amp;nbsp; # 如果被动模式由于某种原因失败，请尝试使用活动模式。&lt;br&gt;&amp;nbsp; &amp;nbsp; return ftp&lt;/pre&gt;\n                                                                                        ',0,'2017-06-08 00:00:00','24',55),(130,1,'（集群）负载均衡中使用Redis实现共享Session','','\n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一、负载均衡：把众多的访问量分担到其他的服务器上，让每个服务器的压力减少。&lt;/p&gt;&lt;p&gt;通俗的解释就是：把一项任务交由一个开发人员处理总会有上限处理能力，这时可以考虑增加开发人员来共同处理这项任务，多人处理同一项任务时就会涉及到调度问题，即任务分配，这和多线程理念是一致的。nginx在这里的角色相当于任务分配者。&lt;/p&gt;&lt;p&gt;如我们第一次访问 www.baidu.com 这个域名，可能会对应这个IP 111.13.101.208的服务器，然后第二次访问，IP可能会变为111.13.101.209的服务器，这就是百度采用了负载均衡，一个域名对应多个服务器，将访问量分担到其他的服务器，这样很大程度的减轻了每个服务器上访问量。&lt;/p&gt;&lt;p&gt;但是，这里有一个问题，如果我们登录了百度的一个账号，如网页的百度网盘，但是每次有可能请求的是不同的服务器，我们知道每个服务器都会有自己的会话session，所以会导致用户每次刷新网页又要重新登录，这是非常糟糕的体验，因此，根据以上问题，希望session可以共享，这样就可以解决负载均衡中同一个域名不同服务器对应不同session的问题。&lt;/p&gt;&lt;p&gt;二、Redis介绍&lt;/p&gt;&lt;p&gt;目前多服务器的共享session，用的最多的是redis。&lt;/p&gt;&lt;p&gt;关于Redis的基础知识，可以看我之前的博文Redis开发学习。&lt;/p&gt;&lt;p&gt;再简单的梳理下：&lt;/p&gt;&lt;p&gt;redis是key-value的存储系统，属于非关系型数据库&lt;/p&gt;&lt;p&gt;特点：支持数据持久化，可以让数据在内存中保存到磁盘里（memcached：数据存在内存里，如果服务重启，数据会丢失）&lt;/p&gt;&lt;p&gt;支持5种数据类型：string，hash，list，set，zset&lt;/p&gt;&lt;p&gt;两种文件格式（即数据持久化）&lt;/p&gt;&lt;p&gt;（1）RDB（全量数据）：多长时间/频率，把内存中的数据刷到磁盘中，便于下次读取文件时进行加载。（2）AOF（增量请求）：类似mysql的二进制日志，不停地把对数据库的更改语句记录到日志中，下次重启服务，会根据二进制日志把数据重写一次，加载到内存里，实现数据持久化&lt;/p&gt;&lt;p&gt;存储&lt;/p&gt;&lt;p&gt;（1）内存存储 （2）磁盘存储（RDB） （3）log文件（AOF）&lt;/p&gt;&lt;p&gt;三、实现的核心思想&lt;/p&gt;&lt;p&gt;首先要明确session和cookie的区别。浏览器端存的是cookie每次浏览器发请求到服务端是http 报文头是会自动加上你的cookie信息的。服务端拿着用户的cookie作为key去存储里找对应的value(session).&lt;/p&gt;&lt;p&gt;同一域名下的网站的cookie都是一样的。所以无论几台服务器,无论请求分配到哪一台服务器上同一用户的cookie是不变的。也就是说cookie对应的session也是唯一的。&lt;/p&gt;&lt;p&gt;所以，这里只要保证多台业务服务器访问同一个redis服务器(或集群)就行了。&lt;/p&gt;&lt;p&gt;四、PHP会话session配置改为Redis&lt;/p&gt;&lt;p&gt;我们可以看到PHP默认的的session配置使用文件形式保存在服务器临时目录中，我们需要Redis作为保存session的驱动，所以，这里需要对配置文件进行修改，PHP的自定义会话机制改为Redis。&lt;/p&gt;&lt;p&gt;四、PHP会话session配置改为Redis&lt;/p&gt;&lt;p&gt;我们可以看到PHP默认的的session配置使用文件形式保存在服务器临时目录中，我们需要Redis作为保存session的驱动，所以，这里需要对配置文件进行修改，PHP的自定义会话机制改为Redis。&lt;/p&gt;&lt;p&gt;这里有两种修改方式：&lt;/p&gt;&lt;p&gt;1.修改配置文件php.ini&lt;/p&gt;&lt;p&gt;找到配置文件 php.ini，修改为下面内容，保存并重启服务&lt;/p&gt;&lt;pre&gt;session.save_handler = redis&lt;br&gt;session.save_path = &quot;tcp://127.0.0.1:6379&quot;&lt;/pre&gt;&lt;p&gt;2.代码中动态配置修改&lt;/p&gt;&lt;p&gt;直接在代码中加入以下内容：&lt;/p&gt;&lt;pre&gt;ini_set(&quot;session.save_handler&quot;, &quot;redis&quot;);ini_set(&quot;session.save_path&quot;, &quot;tcp://127.0.0.1:6379&quot;);&lt;/pre&gt;&lt;p&gt;注：如果配置文件redis.conf里设置了连接密码requirepass，save_path需要这样写tcp://127.0.0.1:6379?auth=authpwd ，否则保存session的时候会报错。&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                            ',0,'2017-07-14 00:00:00','23,34',53),(131,1,'javascript中的事件委托(或事件代理)详解','','\n                                &lt;p&gt;概述：&lt;/p&gt;&lt;p&gt;那什么叫事件委托呢？它还有一个名字叫事件代理，JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。&lt;/p&gt;&lt;p&gt;&lt;b&gt;为什么要用事件委托：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？&lt;/p&gt;&lt;p&gt;在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；&lt;/p&gt;&lt;p&gt;每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了（内存不够用，是硬伤），比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢，那只能说呵呵了，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好。&lt;/p&gt;&lt;p&gt;&lt;b&gt;事件委托的原理：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向它的父级节点传播事件，举个例子：页面上有这么一个节点树，&lt;/p&gt;&lt;p&gt;div&amp;gt;ul&amp;gt;li&amp;gt;a;比如给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。&lt;/p&gt;&lt;p&gt;所以用这个原理，我们可以批量给某个父级节点下的一批指定的子节点添加事件，通过委托，给父级节点绑定这个事件&lt;/p&gt;&lt;pre&gt;&amp;lt;ul id=&quot;ul1&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;lt;li&amp;gt;111&amp;lt;/li&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;lt;li&amp;gt;222&amp;lt;/li&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;lt;span&amp;gt;444&amp;lt;/span&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;lt;li&amp;gt;333&amp;lt;/li&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;lt;li&amp;gt;444&amp;lt;/li&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;lt;a&amp;gt;444&amp;lt;/a&amp;gt;&lt;br&gt;&amp;lt;/ul&amp;gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre&gt;window.onload = function(e){&lt;br&gt;&amp;nbsp; &amp;nbsp; var oUl = document.getElementById(&quot;ul1&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp;oUl.onclick = function(){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(&quot;触发了ul的click事件了&quot;)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 可以通过 e 对象来判断点击的dom节点标签名,处理业务&amp;nbsp; &amp;nbsp;在JQ中 $(&quot;#ul1&quot;).on(&quot;click&quot;,&quot;li&quot;,function(){...}) 用的就是这个原理&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(e.target.nodeName.toLowerCase())&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                            ',0,'2016-06-07 00:00:00','22',44),(132,1,'浅述Session的持久化的作用与原理','','\n                                &lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;为什么需要持久化&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;客户端访问了某个能开启会话功能的资源， web服务器就会创建一个与该客户端对应的HttpSession对象，每个HttpSession对象都要站用一定的内存空间。如果在某一时间段内访问站点的用户很多，web服务器内存中就会积累大量的HttpSession对象，消耗大量的服务器内存，即使用户已经离开或者关闭了浏览器，web服务器仍要保留与之对应的HttpSession对象，在他们超时之前，一直占用web服务器内存资源。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;web服务器通常将那些暂时不活动但未超时的HttpSession对象转移到文件系统或数据库中保存，服务器要使用他们时再将他们从文件系统或数据库中装载入内存，这种技术称为Session的持久化。&lt;/div&gt;&lt;div&gt;现在在公司用的最多最流行的做法就是 Session redis化，把session存储到redis中。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;Session的持久化的好处：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1.提高服务器内存的利用率，保证那些暂停活动的客户端在会话超时之前继续原来的会话&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.在多台web服务器协同对外提供服务的集群系统中，使用Session的持久化技术，可以达到session数据共享的作用，&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.在一个web应用程序重启时，服务器也会持久化该应用程序中所有HttpSession对象，保证客户端的会话活动仍可以继续。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;ps:&lt;/b&gt;把session保存在redis中，并不是说用redis来代替session存储数据，你要明白 session默认是存在服务器某个目录下的文件里面的，文件名是sessionID，当然这个是可以设置的，里面的内容是你存储的值，那么问题来了，你是怎么找到session的值呢？你请求服务器时，htpp请求会携带cookie信息，这个信息中就包含有sessionID，服务器拿到这个sessionID后去找对应的文件，因此，用redis存session中，redis在这里面扮演的角色就是那个服务器文件系统，以前去服务器找文件，而现在去redis中找key。key对应的就是session的值了。在这里，代码中设置session和获取session和原来的一样，只是需要更改一些配置文件，当在设置session的时候自动让它的数据保存到redis中去。&lt;/div&gt;\n                                                                                        ',0,'2015-07-15 00:00:00','23,34,16',60),(135,1,'MySQL主从复制读写分离详解','','\n                                &lt;div&gt;&lt;b&gt;主从复制&lt;/b&gt;：是用来建立一个和主数据库完全一样的数据库环境，称为从数据库；主数据库一般是实时的业务数据库，从数据库的作用和使用场合一般有几个：一是作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作,解决服务器单点问题；二是可在从数据库进行数据读取操作，这样不影响主数据库的性能；同时可以避免读写数据库都在同一个数据库服务器下进行，从而减轻数据库服务器的压力&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;u&gt;主从复制的原理&lt;/u&gt;：mysql支持单向、异步复制，复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。mysql复制是基于主服务器在二进制日志中记录的所有对数据库的更改操作语句(更新、删除等等)。因此，要进行复制，必须在主服务器上启用二进制日志。每个从服务器接收主服务器已经记录的二进制日志来保存更新。当一个从服务器连接主服务器时，它通知主服务器从日志中读取最后一次成功更新的位置。从服务器接收主服务器的二进制日志文件数据后，并在本机上执行一遍二进制日志中的操作语句达到复制的目的。然后封锁并等待主服务器通知新的更新。从服务器执行备份不会干扰主服务器，在备份过程中主服务器可以继续处理更新&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;读写分离&lt;/b&gt;：主从复制是实现读写分离的一种方式，目的是为了减轻单台服务器的压力，从而让写数据库只负责写操作，读数据库只负责读操作。通过主从复制的方式，把负责写数据的服务器中的数据复制到负责读数据的服务器中，实现数据的最终一致性（由于复制过程中会延迟，所以不能做到强一致性，对于要求数据强一致性的操作，我们可以直接读取写数据的服务器来避免错误。）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0); font-weight: bold;&quot;&gt;主从复制原理&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0); font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;概述：&lt;/b&gt;在实际的生产环境中，对数据库的读和写都在同一个数据库服务器中，是不能满足实际需求的。无论是在安全性、高可用性还是高并发等各个方面都是完全不能满足实际需求的。因此，通过主从复制的方式来同步数据，再通过读写分离来提升数据库的并发负载能力。mysql主从复制是对数据库中的数据、语句做备份。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;主从复制的过程解析&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、主库将变更写入到主库的binlog中&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;一些MySQL版本并不会开启二进制日志，所以一定要检查是否开启；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果刚开始没有开启，后面再进行开启的话，需要重启数据库才能生效，而且数据库的重启往往会对业务造成很大的影响；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;尽管二进制日志对性能有稍许的影响，所以还是建议大家无论是否使用复制功能，都要开启MySQL二进制日志，因为增量备份也需要二进制日志。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、从库的IO线程在指定位置读取主库binlog内容存储到本地的中继日志（Relay Log）中&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;要完成二进制日志的传输过程，MySQL会在从服务器上启动一个工作线程，称为IO线程，这个IO线程会跟主数据库建立一个普通的客户端连接，然后在主服务器上启动一个特殊的二进制转储线程称为binlogdown线程。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;从库上的IO线程通过这个二进制转储线程来读取主库上的二进制事件，如果该事件追赶上主库，则会进入sleep状态，直到主库发起信号通知有新事件产生时，才会被唤醒，relay log的格式和binlog格式是完全相同的，&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;可以使用mysqlbinlog来读取relay log中的内容。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3、从库的SQL线程读取Relay Log日志中的内容，并在从库中重放&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;SQL线程所执行的事件，我们可以通过配置选项来决定是否要写入到从服务器的二进制日志中。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;目前MySQL支持两种复制类型：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;基于二进制日志点的复制&lt;/li&gt;&lt;li&gt;基于GTID的复制（MySQL&amp;gt;=5.7推荐使用）&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190425/509fd89e0e1433625be03b4a5e7d546b.png&quot; data-filename=&quot;img&quot; style=&quot;width: 461px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190425/570a23cef99af264d7676f952ea9eab2.png&quot; data-filename=&quot;img&quot; style=&quot;width: 596px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190425/83c4f4fa44f941c838c2ed87258274d2.png&quot; data-filename=&quot;img&quot; style=&quot;width: 500px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.92px; color: rgb(255, 0, 0); font-weight: bold;&quot;&gt;mysql读写分离原理&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.92px; color: rgb(255, 0, 0); font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.92px;&quot;&gt;读写分离就是在主服务器上修改，数据会同步到从服务器，从服务器只能提供读取数据，不能写入，实现备份的同时也实现了数据库性能的优化，以及提升了服务器安全。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190425/dcf31caa2b4783bafef10d7ffed2c00a.png&quot; data-filename=&quot;img&quot; style=&quot;width: 500px;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.92px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.92px;&quot;&gt;目前较为常见的Mysql读写分离分实现分为以下两种：&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.92px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.92px;&quot;&gt;&amp;nbsp;1）基于程序代码内部实现&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.92px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.92px;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 在代码中根据select 、insert进行路由分类，这类方法也是目前生产环境下应用最广泛的。优点是性能较好，因为程序在代码中实现，不需要增加额外的硬件开支，缺点是需要开发人员来实现，运维人员无从下手。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.92px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.92px;&quot;&gt;&amp;nbsp;2） 基于中间代理层实现&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.92px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.92px;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 代理一般介于应用服务器和数据库服务器之间，代理数据库服务器接收到应用服务器的请求后根据判断后转发到，后端数据库，有以下代表性的程序。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.92px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.92px;&quot;&gt;（1）mysql_proxy。mysql_proxy是Mysql的一个开源项目，通过其自带的lua脚本进行sql判断。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.92px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.92px;&quot;&gt;（2）Atlas。是由 Qihoo 360, Web平台部基础架构团队开发维护的一个基于MySQL协议的数据中间层项目。它是在mysql-proxy 0.8.2版本的基础上，对其进行了优化，增加了一些新的功能特性。360内部使用Atlas运行的mysql业务，每天承载的读写请求数达几十亿条。支持事物以及存储过程。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.92px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13.92px;&quot;&gt;（3）Amoeba。由阿里巴巴集团在职员工使用序java语言进行开发，阿里巴巴集团将其用户生产环境下，但是他并不支持事物以及存数过程。&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;MySQLProxy 实现原理&lt;/span&gt;&lt;/div&gt;&lt;div&gt;下面使用MySQL官方提供的数据库代理层产品MySQLProxy搭建读写分离。&lt;/div&gt;&lt;div&gt;MySQLProxy实际上是在客户端请求与MySQLServer之间建立了一个连接池。所有客户端请求都是发向MySQLProxy，然后经由MySQLProxy进行相应的分析，判断出是读操作还是写操作，分发至对应的MySQLServer上。对于多节点Slave集群，也可以起做到负载均衡的效果。&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190425/013a878647495953512290b0939870fa.png&quot; data-filename=&quot;img&quot; style=&quot;width: 424px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;参考：&lt;/div&gt;&lt;div&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgba(0, 0, 0, 0.5); font-family: 微软雅黑; font-size: 15px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;作者：听风&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgba(0, 0, 0, 0.5); font-family: 微软雅黑; font-size: 15px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 14px; overflow-wrap: break-word !important;&quot;&gt;来源：https://www.cnblogs.com/huchong/p/10253522.html&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;\n                                                                                        ',0,'2016-07-16 00:00:00','11',28),(136,1,'Redis的数据结构和相关常用命令讲解','','&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;概述&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;Redis是一个开源的，基于内存的结构化数据存储媒介，可以作为数据库、缓存服务或消息服务使用。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis支持多种数据结构，包括字符串、哈希表、链表、集合、有序集合、位图、Hyperloglogs等。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis具备LRU淘汰、事务实现、以及不同级别的硬盘持久化等能力，并且支持副本集和通过Redis Sentinel实现的高可用方案，同时还支持通过Redis Cluster实现的数据自动分片能力。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis的主要功能都基于单线程模型实现，也就是说Redis使用一个线程来服务所有的客户端请求，同时Redis采用了非阻塞式IO，并精细地优化各种命令的算法时间复杂度，这些信息意味着：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;Redis是线程安全的（因为只有一个线程），其所有操作都是原子的，不会因并发产生数据异常&lt;/li&gt;&lt;li&gt;Redis的速度非常快（因为使用非阻塞式IO，且大部分命令的算法时间复杂度都是O(1))&lt;/li&gt;&lt;li&gt;使用高耗时的Redis命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢。（例如时间复杂度为O(N)的KEYS命令，严格禁止在生产环境中使用）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;Redis的数据结构和相关常用命令&lt;/b&gt;&lt;/p&gt;&lt;p&gt;本节中将介绍Redis支持的主要数据结构，以及相关的常用Redis命令。本节只对Redis命令进行扼要的介绍，且只列出了较常用的命令。如果想要了解完整的Redis命令集，或了解某个命令的详细使用方法，请参考官方文档：&lt;/p&gt;&lt;p&gt;https://redis.io/commands&lt;/p&gt;&lt;p&gt;Key&lt;/p&gt;&lt;p&gt;Redis采用Key-Value型的基本数据结构，任何二进制序列都可以作为Redis的Key使用（例如普通的字符串或一张JPEG图片）&lt;/p&gt;&lt;p&gt;关于Key的一些注意事项：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;不要使用过长的Key。例如使用一个1024字节的key就不是一个好主意，不仅会消耗更多的内存，还会导致查找的效率降低&lt;/li&gt;&lt;li&gt;Key短到缺失了可读性也是不好的，例如”u1000flw”比起”user:1000:followers”来说，节省了寥寥的存储空间，却引发了可读性和可维护性上的麻烦&lt;/li&gt;&lt;li&gt;最好使用统一的规范来设计Key，比如”object-type:id:attr”，以这一规范设计出的Key可能是”user:1000″或”comment:1234:reply-to”&lt;/li&gt;&lt;li&gt;Redis允许的最大Key长度是512MB（对Value的长度限制也是512MB）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;String&lt;/b&gt;&lt;/p&gt;&lt;p&gt;String是Redis的基础数据类型，Redis没有Int、Float、Boolean等数据类型的概念，所有的基本类型在Redis中都以String体现。&lt;/p&gt;&lt;p&gt;与String相关的常用命令：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;SET：为一个key设置value，可以配合EX/PX参数指定key的有效期，通过NX/XX参数针对key是否存在的情况进行区别操作，时间复杂度O(1)&lt;/li&gt;&lt;li&gt;GET：获取某个key对应的value，时间复杂度O(1)&lt;/li&gt;&lt;li&gt;GETSET：为一个key设置value，并返回该key的原value，时间复杂度O(1)&lt;/li&gt;&lt;li&gt;MSET：为多个key设置value，时间复杂度O(N)&lt;/li&gt;&lt;li&gt;MSETNX：同MSET，如果指定的key中有任意一个已存在，则不进行任何操作，时间复杂度O(N)&lt;/li&gt;&lt;li&gt;MGET：获取多个key对应的value，时间复杂度O(N)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上文提到过，Redis的基本数据类型只有String，但Redis可以把String作为整型或浮点型数字来使用，主要体现在INCR、DECR类的命令上：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;INCR：将key对应的value值自增1，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1)&lt;/li&gt;&lt;li&gt;INCRBY：将key对应的value值自增指定的整型数值，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1)&lt;/li&gt;&lt;li&gt;DECR/DECRBY：同INCR/INCRBY，自增改为自减。&lt;/li&gt;&lt;li&gt;INCR/DECR系列命令要求操作的value类型为String，并可以转换为64位带符号的整型数字，否则会返回错误。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;也就是说，进行INCR/DECR系列命令的value，必须在[-2^63 ~ 2^63 – 1]范围内。&lt;/p&gt;&lt;p&gt;前文提到过，Redis采用单线程模型，天然是线程安全的，这使得INCR/DECR命令可以非常便利的实现高并发场景下的精确控制。&lt;/p&gt;&lt;p&gt;例1：库存控制&lt;/p&gt;&lt;p&gt;在高并发场景下实现库存余量的精准校验，确保不出现超卖的情况。&lt;/p&gt;&lt;p&gt;设置库存总量：&lt;/p&gt;&lt;p&gt;SET inv:remain &quot;100&quot;&lt;/p&gt;&lt;p&gt;库存扣减+余量校验：&lt;/p&gt;&lt;p&gt;DECR inv:remain&lt;/p&gt;&lt;p&gt;当DECR命令返回值大于等于0时，说明库存余量校验通过，如果返回小于0的值，则说明库存已耗尽。&lt;/p&gt;&lt;p&gt;假设同时有300个并发请求进行库存扣减，Redis能够确保这300个请求分别得到99到-200的返回值，每个请求得到的返回值都是唯一的，绝对不会找出现两个请求得到一样的返回值的情况。&lt;/p&gt;&lt;p&gt;例2：自增序列生成&lt;/p&gt;&lt;p&gt;实现类似于RDBMS的Sequence功能，生成一系列唯一的序列号&lt;/p&gt;&lt;p&gt;设置序列起始值：&lt;/p&gt;&lt;p&gt;SET sequence &quot;10000&quot;&lt;/p&gt;&lt;p&gt;获取一个序列值：&lt;/p&gt;&lt;p&gt;INCR sequence&lt;/p&gt;&lt;p&gt;直接将返回值作为序列使用即可。&lt;/p&gt;&lt;p&gt;获取一批（如100个）序列值：&lt;/p&gt;&lt;p&gt;INCRBY sequence 100&lt;/p&gt;&lt;p&gt;假设返回值为N，那么[N – 99 ~ N]的数值都是可用的序列值。&lt;/p&gt;&lt;p&gt;当多个客户端同时向Redis申请自增序列时，Redis能够确保每个客户端得到的序列值或序列范围都是全局唯一的，绝对不会出现不同客户端得到了重复的序列值的情况。&lt;/p&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;List&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis的List是链表型的数据结构，可以使用LPUSH/RPUSH/LPOP/RPOP等命令在List的两端执行插入元素和弹出元素的操作。虽然List也支持在特定index上插入和读取元素的功能，但其时间复杂度较高（O(N)），应小心使用。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;与List相关的常用命令：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;LPUSH：向指定List的左侧（即头部）插入1个或多个元素，返回插入后的List长度。时间复杂度O(N)，N为插入元素的数量&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;RPUSH：同LPUSH，向指定List的右侧（即尾部）插入1或多个元素&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;LPOP：从指定List的左侧（即头部）移除一个元素并返回，时间复杂度O(1)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;RPOP：同LPOP，从指定List的右侧（即尾部）移除1个元素并返回&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;LPUSHX/RPUSHX：与LPUSH/RPUSH类似，区别在于，LPUSHX/RPUSHX操作的key如果不存在，则不会进行任何操作&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;LLEN：返回指定List的长度，时间复杂度O(1)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;LRANGE：返回指定List中指定范围的元素（双端包含，即LRANGE key 0 10会返回11个元素），时间复杂度O(N)。应尽可能控制一次获取的元素数量，一次获取过大范围的List元素会导致延迟，同时对长度不可预知的List，避免使用LRANGE key 0 -1这样的完整遍历操作。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;应谨慎使用的List相关命令：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;LINDEX：返回指定List指定index上的元素，如果index越界，返回nil。index数值是回环的，即-1代表List最后一个位置，-2代表List倒数第二个位置。时间复杂度O(N)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;LSET：将指定List指定index上的元素设置为value，如果index越界则返回错误，时间复杂度O(N)，如果操作的是头/尾部的元素，则时间复杂度为O(1)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;LINSERT：向指定List中指定元素之前/之后插入一个新元素，并返回操作后的List长度。如果指定的元素不存在，返回-1。如果指定key不存在，不会进行任何操作，时间复杂度O(N)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;由于Redis的List是链表结构的，上述的三个命令的算法效率较低，需要对List进行遍历，命令的耗时无法预估，在List长度大的情况下耗时会明显增加，应谨慎使用。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;换句话说，Redis的List实际是设计来用于实现队列，而不是用于实现类似ArrayList这样的列表的。如果你不是想要实现一个双端出入的队列，那么请尽量不要使用Redis的List数据结构。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;为了更好支持队列的特性，Redis还提供了一系列阻塞式的操作命令，如BLPOP/BRPOP等，能够实现类似于BlockingQueue的能力，即在List为空时，阻塞该连接，直到List中有对象可以出队时再返回。针对阻塞类的命令，此处不做详细探讨，请参考官方文档（https://redis.io/topics/data-types-intro） 中”Blocking operations on lists”一节。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;Hash&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Hash即哈希表，Redis的Hash和传统的哈希表一样，是一种field-value型的数据结构，可以理解成将HashMap搬入Redis。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Hash非常适合用于表现对象类型的数据，用Hash中的field对应对象的field即可。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Hash的优点包括：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;可以实现二元查找，如”查找ID为1000的用户的年龄”&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;比起将整个对象序列化后作为String存储的方法，Hash能够有效地减少网络传输的消耗&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;当使用Hash维护一个集合时，提供了比List效率高得多的随机访问命令&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;与Hash相关的常用命令：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;HSET：将key对应的Hash中的field设置为value。如果该Hash不存在，会自动创建一个。时间复杂度O(1)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;HGET：返回指定Hash中field字段的值，时间复杂度O(1)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;HMSET/HMGET：同HSET和HGET，可以批量操作同一个key下的多个field，时间复杂度：O(N)，N为一次操作的field数量&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;HSETNX：同HSET，但如field已经存在，HSETNX不会进行任何操作，时间复杂度O(1)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;HEXISTS：判断指定Hash中field是否存在，存在返回1，不存在返回0，时间复杂度O(1)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;HDEL：删除指定Hash中的field（1个或多个），时间复杂度：O(N)，N为操作的field数量&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;HINCRBY：同INCRBY命令，对指定Hash中的一个field进行INCRBY，时间复杂度O(1)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;应谨慎使用的Hash相关命令：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;HGETALL：返回指定Hash中所有的field-value对。返回结果为数组，数组中field和value交替出现。时间复杂度O(N)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;HKEYS/HVALS：返回指定Hash中所有的field/value，时间复杂度O(N)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;上述三个命令都会对Hash进行完整遍历，Hash中的field数量与命令的耗时线性相关，对于尺寸不可预知的Hash，应严格避免使用上面三个命令，而改为使用HSCAN命令进行游标式的遍历，具体请见&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;a href=&quot;https://redis.io/commands/scan&quot;&gt;https://redis.io/commands/scan&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;Set&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis Set是无序的，不可重复的String集合。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;与Set相关的常用命令：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;SADD：向指定Set中添加1个或多个member，如果指定Set不存在，会自动创建一个。时间复杂度O(N)，N为添加的member个数&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;SREM：从指定Set中移除1个或多个member，时间复杂度O(N)，N为移除的member个数&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;SRANDMEMBER：从指定Set中随机返回1个或多个member，时间复杂度O(N)，N为返回的member个数&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;SPOP：从指定Set中随机移除并返回count个member，时间复杂度O(N)，N为移除的member个数&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;SCARD：返回指定Set中的member个数，时间复杂度O(1)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;SISMEMBER：判断指定的value是否存在于指定Set中，时间复杂度O(1)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;SMOVE：将指定member从一个Set移至另一个Set&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;慎用的Set相关命令：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;SMEMBERS：返回指定Hash中所有的member，时间复杂度O(N)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;SUNION/SUNIONSTORE：计算多个Set的并集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;SINTER/SINTERSTORE：计算多个Set的交集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;SDIFF/SDIFFSTORE：计算1个Set与1或多个Set的差集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;上述几个命令涉及的计算量大，应谨慎使用，特别是在参与计算的Set尺寸不可知的情况下，应严格避免使用。可以考虑通过SSCAN命令遍历获取相关Set的全部member（具体请见 https://redis.io/commands/scan ），如果需要做并集/交集/差集计算，可以在客户端进行，或在不服务实时查询请求的Slave上进行。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;Sorted Set&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis Sorted Set是有序的、不可重复的String集合。Sorted Set中的每个元素都需要指派一个分数(score)，Sorted Set会根据score对元素进行升序排序。如果多个member拥有相同的score，则以字典序进行升序排序。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Sorted Set非常适合用于实现排名。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Sorted Set的主要命令：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;ZADD：向指定Sorted Set中添加1个或多个member，时间复杂度O(Mlog(N))，M为添加的member数量，N为Sorted Set中的member数量&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;ZREM：从指定Sorted Set中删除1个或多个member，时间复杂度O(Mlog(N))，M为删除的member数量，N为Sorted Set中的member数量&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;ZCOUNT：返回指定Sorted Set中指定score范围内的member数量，时间复杂度：O(log(N))&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;ZCARD：返回指定Sorted Set中的member数量，时间复杂度O(1)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;ZSCORE：返回指定Sorted Set中指定member的score，时间复杂度O(1)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;ZRANK/ZREVRANK：返回指定member在Sorted Set中的排名，ZRANK返回按升序排序的排名，ZREVRANK则返回按降序排序的排名。时间复杂度O(log(N))&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;ZINCRBY：同INCRBY，对指定Sorted Set中的指定member的score进行自增，时间复杂度O(log(N))&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;慎用的Sorted Set相关命令：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;ZRANGE/ZREVRANGE：返回指定Sorted Set中指定排名范围内的所有member，ZRANGE为按score升序排序，ZREVRANGE为按score降序排序，时间复杂度O(log(N)+M)，M为本次返回的member数&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;ZRANGEBYSCORE/ZREVRANGEBYSCORE：返回指定Sorted Set中指定score范围内的所有member，返回结果以升序/降序排序，min和max可以指定为-inf和+inf，代表返回所有的member。时间复杂度O(log(N)+M)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;ZREMRANGEBYRANK/ZREMRANGEBYSCORE：移除Sorted Set中指定排名范围/指定score范围内的所有member。时间复杂度O(log(N)+M)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;上述几个命令，应尽量避免传递[0 -1]或[-inf +inf]这样的参数，来对Sorted Set做一次性的完整遍历，特别是在Sorted Set的尺寸不可预知的情况下。可以通过ZSCAN命令来进行游标式的遍历（具体请见 https://redis.io/commands/scan ），或通过LIMIT参数来限制返回member的数量（适用于ZRANGEBYSCORE和ZREVRANGEBYSCORE命令），以实现游标式的遍历。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\r\n                                                            ',0,'2016-07-28 00:00:00','16',30),(137,1,'Redis数据持久化和数据淘汰机制','','&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis提供了将数据定期自动持久化至硬盘的能力，包括RDB和AOF两种方案，两种方案分别有其长处和短板，可以配合起来同时运行，确保数据的稳定性。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;必须使用数据持久化吗？&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis的数据持久化机制是可以关闭的。如果你只把Redis作为缓存服务使用，Redis中存储的所有数据都不是该数据的主体而仅仅是同步过来的备份，那么可以关闭Redis的数据持久化机制。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;但通常来说，仍然建议至少开启RDB方式的数据持久化，因为：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;RDB方式的持久化几乎不损耗Redis本身的性能，在进行RDB持久化时，Redis主进程唯一需要做的事情就是fork出一个子进程，所有持久化工作都由子进程完成&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis无论因为什么原因crash掉之后，重启时能够自动恢复到上一次RDB快照中记录的数据。这省去了手工从其他数据源（如DB）同步数据的过程，而且要比其他任何的数据恢复方式都要快&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;现在硬盘那么大，真的不缺那一点地方&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;RDB&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;采用RDB持久方式，Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。可以在配置文件中配置Redis进行快照保存的时机：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;save [seconds] [changes]&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;意为在[seconds]秒内如果发生了[changes]次数据修改，则进行一次RDB快照保存，例如&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;save 60 100&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;会让Redis每60秒检查一次数据变更情况，如果发生了100次或以上的数据变更，则进行RDB快照保存。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;可以配置多条save指令，让Redis执行多级的快照保存策略。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis默认开启RDB快照，默认的RDB策略如下：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;save 900 1&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;save 300 10&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;save 60 10000&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;也可以通过BGSAVE命令手工触发RDB快照保存。&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;RDB的优点：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;对性能影响最小。如前文所述，Redis在保存RDB快照时会fork出子进程进行，几乎不影响Redis处理客户端请求的效率。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;每次快照会生成一个完整的数据快照文件，所以可以辅以其他手段保存多个时间点的快照（例如把每天0点的快照备份至其他存储媒介中），作为非常可靠的灾难恢复手段。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;使用RDB文件进行数据恢复比使用AOF要快很多。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;RDB的缺点：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;快照是定期生成的，所以在Redis crash时或多或少会丢失一部分数据。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果数据集非常大且CPU不够强（比如单核CPU），Redis在fork子进程时可能会消耗相对较长的时间（长至1秒），影响这期间的客户端请求。&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;AOF&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;AOF默认是关闭的，如要开启，进行如下配置：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;appendonly yes&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;AOF提供了三种fsync配置，always/everysec/no，通过配置项[appendfsync]指定：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;appendfsync no：不进行fsync，将flush文件的时机交给OS决定，速度最快&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;appendfsync always：每写入一条日志就进行一次fsync操作，数据安全性最高，但速度最慢&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;appendfsync everysec：折中的做法，交由后台线程每秒fsync一次&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;随着AOF不断地记录写操作日志，必定会出现一些无用的日志，例如某个时间点执行了命令SET key1 “abc”，在之后某个时间点又执行了SET key1 “bcd”，那么第一条命令很显然是没有用的。大量的无用日志会让AOF文件过大，也会让数据恢复的时间过长。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;所以Redis提供了AOF rewrite功能，可以重写AOF文件，只保留能够把数据恢复到最新状态的最小写操作集。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;AOF rewrite可以通过BGREWRITEAOF命令触发，也可以配置Redis定期自动进行：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;auto-aof-rewrite-percentage 100&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;auto-aof-rewrite-min-size 64mb&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;上面两行配置的含义是，Redis在每次AOF rewrite时，会记录完成rewrite后的AOF日志大小，当AOF日志大小在该基础上增长了100%后，自动进行AOF rewrite。同时如果增长的大小没有达到64mb，则不会进行rewrite。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;AOF的优点：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;最安全，在启用appendfsync always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失1秒的数据。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;AOF的缺点：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;AOF文件通常比RDB文件更大&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;性能消耗比RDB高&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;数据恢复速度比RDB慢&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;内存管理&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;最大内存设置&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;默认情况下，在32位OS中，Redis最大使用3GB的内存，在64位OS中则没有限制。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在使用Redis时，应该对数据占用的最大空间有一个基本准确的预估，并为Redis设定最大使用的内存。否则在64位OS中Redis会无限制地占用内存（当物理内存被占满后会使用swap空间），容易引发各种各样的问题。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;通过如下配置控制Redis使用的最大内存：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;maxmemory 100mb&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在内存占用达到了maxmemory后，再向Redis写入数据时，Redis会：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;根据配置的数据淘汰策略尝试淘汰数据，释放空间&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果没有数据可以淘汰，或者没有配置数据淘汰策略，那么Redis会对所有写请求返回错误，但读请求仍然可以正常执行&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在为Redis设置maxmemory时，需要注意：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果采用了Redis的主从同步，主节点向从节点同步数据时，会占用掉一部分内存空间，如果maxmemory过于接近主机的可用内存，导致数据同步时内存不足。所以设置的maxmemory不要过于接近主机可用的内存，留出一部分预留用作主从同步。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;数据淘汰机制\r\n&lt;/b&gt;&lt;br class=&quot;Apple-interchange-newline&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis提供了5种数据淘汰策略：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;volatile-lru：使用LRU算法进行数据淘汰（淘汰上次使用时间最早的，且使用次数最少的key），只淘汰设定了有效期的key&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;allkeys-lru：使用LRU算法进行数据淘汰，所有的key都可以被淘汰&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;volatile-random：随机淘汰数据，只淘汰设定了有效期的key&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;allkeys-random：随机淘汰数据，所有的key都可以被淘汰&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;volatile-ttl：淘汰剩余有效期最短的key&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;最好为Redis指定一种有效的数据淘汰策略以配合maxmemory设置，避免在内存使用满后发生写入失败的情况。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;一般来说，推荐使用的策略是volatile-lru，并辨识Redis中保存的数据的重要性。对于那些重要的，绝对不能丢弃的数据（如配置类数据等），应不设置有效期，这样Redis就永远不会淘汰这些数据。对于那些相对不是那么重要的，并且能够热加载的数据（比如缓存最近登录的用户信息，当在Redis中找不到时，程序会去DB中读取），可以设置上有效期，这样在内存不够时Redis就会淘汰这部分数据。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;配置方法：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;maxmemory-policy volatile-lru&amp;nbsp; &amp;nbsp;#默认是noeviction，即不进行数据淘汰&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;Pipelining&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Pipelining&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis提供许多批量操作的命令，如MSET/MGET/HMSET/HMGET等等，这些命令存在的意义是减少维护网络连接和传输数据所消耗的资源和时间。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;例如连续使用5次SET命令设置5个不同的key，比起使用一次MSET命令设置5个不同的key，效果是一样的，但前者会消耗更多的RTT(Round Trip Time)时长，永远应优先使用后者。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;然而，如果客户端要连续执行的多次操作无法通过Redis命令组合在一起，例如：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;SET a &quot;abc&quot;&lt;br&gt;INCR b&lt;br&gt;HSET c name &quot;hi&quot;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;此时便可以使用Redis提供的pipelining功能来实现在一次交互中执行多条命令。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;使用pipelining时，只需要从客户端一次向Redis发送多条命令（以rn）分隔，Redis就会依次执行这些命令，并且把每个命令的返回按顺序组装在一起一次返回，比如：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;$ (printf &quot;PINGrnPINGrnPINGrn&quot;; sleep 1) | nc localhost 6379&lt;br&gt;+PONG&lt;br&gt;+PONG&lt;br&gt;+PONG&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;大部分的Redis客户端都对Pipelining提供支持，所以开发者通常并不需要自己手工拼装命令列表。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Pipelining的局限性&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Pipelining只能用于执行连续且无相关性的命令，当某个命令的生成需要依赖于前一个命令的返回时，就无法使用Pipelining了。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;通过Scripting功能，可以规避这一局限性&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;事务与Scripting&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Pipelining能够让Redis在一次交互中处理多条命令，然而在一些场景下，我们可能需要在此基础上确保这一组命令是连续执行的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;比如获取当前累计的PV数并将其清0&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;&amp;gt; GET vCount&lt;br&gt;12384&lt;br&gt;&amp;gt; SET vCount 0&lt;br&gt;OK&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果在GET和SET命令之间插进来一个INCR vCount，就会使客户端拿到的vCount不准确。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis的事务可以确保复数命令执行时的原子性。也就是说Redis能够保证：一个事务中的一组命令是绝对连续执行的，在这些命令执行完成之前，绝对不会有来自于其他连接的其他命令插进去执行。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;通过MULTI和EXEC命令来把这两个命令加入一个事务中：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;&amp;gt; MULTI&lt;br&gt;OK&lt;br&gt;&amp;gt; GET vCount&lt;br&gt;QUEUED&lt;br&gt;&amp;gt; SET vCount 0&lt;br&gt;QUEUED&lt;br&gt;&amp;gt; EXEC&lt;br&gt;1) 12384&lt;br&gt;2) OK&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis在接收到MULTI命令后便会开启一个事务，这之后的所有读写命令都会保存在队列中但并不执行，直到接收到EXEC命令后，Redis会把队列中的所有命令连续顺序执行，并以数组形式返回每个命令的返回结果。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;可以使用DISCARD命令放弃当前的事务，将保存的命令队列清空。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;需要注意的是，Redis事务不支持回滚：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果一个事务中的命令出现了语法错误，大部分客户端驱动会返回错误，2.6.5版本以上的Redis也会在执行EXEC时检查队列中的命令是否存在语法错误，如果存在，则会自动放弃事务并返回错误。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;但如果一个事务中的命令有非语法类的错误（比如对String执行HSET操作），无论客户端驱动还是Redis都无法在真正执行这条命令之前发现，所以事务中的所有命令仍然会被依次执行。在这种情况下，会出现一个事务中部分命令成功部分命令失败的情况，然而与RDBMS不同，Redis不提供事务回滚的功能，所以只能通过其他方法进行数据的回滚。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;通过事务实现CAS&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis提供了WATCH命令与事务搭配使用，实现CAS乐观锁的机制。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;假设要实现将某个商品的状态改为已售：&lt;/div&gt;&lt;pre&gt;if(exec(HGET stock:1001 state) == &quot;in stock&quot;)&lt;br&gt;&amp;nbsp; &amp;nbsp; exec(HSET stock:1001 state &quot;sold&quot;);&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这一伪代码执行时，无法确保并发安全性，有可能多个客户端都获取到了”in stock”的状态，导致一个库存被售卖多次。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;使用WATCH命令和事务可以解决这一问题：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;exec(WATCH stock:1001);&lt;br&gt;if(exec(HGET stock:1001 state) == &quot;in stock&quot;) {&lt;br&gt;&amp;nbsp; &amp;nbsp; exec(MULTI);&lt;br&gt;&amp;nbsp; &amp;nbsp; exec(HSET stock:1001 state &quot;sold&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; exec(EXEC);&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;WATCH的机制是：在事务EXEC命令执行时，Redis会检查被WATCH的key，只有被WATCH的key从WATCH起始时至今没有发生过变更，EXEC才会被执行。如果WATCH的key在WATCH命令到EXEC命令之间发生过变化，则EXEC命令会返回失败。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;Scripting\r\n&lt;/b&gt;&lt;br class=&quot;Apple-interchange-newline&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;通过EVAL与EVALSHA命令，可以让Redis执行LUA脚本。这就类似于RDBMS的存储过程一样，可以把客户端与Redis之间密集的读/写交互放在服务端进行，避免过多的数据交互，提升性能。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Scripting功能是作为事务功能的替代者诞生的，事务提供的所有能力Scripting都可以做到。Redis官方推荐使用LUA Script来代替事务，前者的效率和便利性都超过了事务。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;关于Scripting的具体使用，本文不做详细介绍，请参考官方文档&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;https://redis.io/commands/eval&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\r\n                                                            ',0,'2016-07-14 00:00:00','16',51),(138,1,' 分布式锁的实现方式','','\n                                &lt;p&gt;&lt;b&gt;什么是分布式锁&lt;/b&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;要介绍分布式锁，首先要提到与分布式锁相对应的是线程锁、进程锁。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.线程锁&lt;/b&gt;&lt;/p&gt;&lt;p&gt;主要用来给方法、代码块加锁。当某个方法或代码使用锁，在同一时刻仅有一个线程执行该方法或该代码段。线程锁只在同一JVM中有效果，因为线程锁的实现在根本上是依靠线程之间共享内存实现的，比如Synchronized、Lock等。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.进程锁&lt;/b&gt;&lt;/p&gt;&lt;p&gt;为了控制同一操作系统中多个进程访问某个共享资源，因为进程具有独立性，各个进程无法访问其他进程的资源，因此无法通过synchronized等线程锁实现进程锁。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.分布式锁&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当多个进程不在同一个系统中，用分布式锁控制多个进程对资源的访问。&lt;/p&gt;&lt;p&gt;&lt;b&gt;分布式锁的由来&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在传统单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLcok或synchronized)进行互斥控制。&lt;/p&gt;&lt;p&gt;但是在分布式系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机并发控制锁策略失效，为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁的由来。&lt;/p&gt;&lt;p&gt;当多个进程不在同一个系统中，就需要用分布式锁控制多个进程对资源的访问。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190430/371747bbb96970c72ec99ddf5d4ec2b4.png&quot; data-filename=&quot;img&quot; style=&quot;width: 495px;&quot;&gt;&lt;/p&gt;&lt;p&gt;上图可以看到，变量A存在JVM1、JVM2、JVM3三个JVM内存中（这个变量A主要体现是在一个类中的一个成员变量，是一个有状态的对象，例如：UserController控制器中的一个整形类型的成员变量），如果不加任何控制的话，变量A同时都会在JVM分配一块内存，三个请求发过来同时对这个变量操作，显然结果是不对的！即使不是同时发过来，三个请求分别操作三个不同JVM内存区域的数据，变量A之间不存在共享，也不具有可见性，处理的结果也是不对的！&lt;/p&gt;&lt;p&gt;如果我们业务中确实存在这个场景的话，我们就需要一种方法解决这个问题！&lt;/p&gt;&lt;p&gt;为了保证一个方法或属性在高并发情况下的同一时间只能被同一个线程执行，在传统单体应用单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLock或Synchronized)进行互斥控制。在单机环境中，Java中提供了很多并发处理相关的API。但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！&lt;/p&gt;&lt;p&gt;&lt;b&gt;分布式锁的特点&lt;/b&gt;&lt;/p&gt;&lt;p&gt;首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：&lt;/p&gt;&lt;p&gt;1、互斥性：任意时刻，只能有一个客户端获取锁，不能同时有两个客户端获取到锁。&lt;/p&gt;&lt;p&gt;2、安全性：锁只能被持有该锁的客户端删除，不能由其它客户端删除。&lt;/p&gt;&lt;p&gt;3、死锁：获取锁的客户端因为某些原因（如down机等）而未能释放锁，其它客户端再也无法获取到该锁。&lt;/p&gt;&lt;p&gt;4、容错：当部分节点（redis节点等）down机时，客户端仍然能够获取锁和释放锁。&lt;/p&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;分布式锁一般有三种实现方式：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1. 数据库乐观锁；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2. 基于ZooKeeper的分布式锁;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.基于Redis的分布式锁；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;基于数据库排他锁&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。&lt;/div&gt;&lt;div&gt;当我们要锁住某个方法或资源时，可以开启事务加锁，我们就在该表中增加一条记录，完成业务逻辑后我们在就删除这条记录。然后commit提交事务释放锁&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;创建这样一张数据库表：&lt;/div&gt;&lt;div&gt;&lt;pre&gt;CREATE TABLE `methodLock` (&lt;br&gt;&amp;nbsp;`id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',&lt;br&gt;&amp;nbsp;`method_name` varchar(64) NOT NULL DEFAULT \'\' COMMENT \'锁定的方法名\',&lt;br&gt;&amp;nbsp;`desc` varchar(1024) NOT NULL DEFAULT \'备注信息\',&lt;br&gt;&amp;nbsp;`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \'保存数据时间，自动生成\',&lt;br&gt;&amp;nbsp;PRIMARY KEY (`id`),&lt;br&gt;&amp;nbsp;UNIQUE KEY `uidx_method_name` (`method_name `) USING BTREE&lt;br&gt;) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=\'锁定中的方法\';&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;可以通过数据库的&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;事务&lt;/span&gt;加&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;排他锁&lt;/span&gt;来实现分布式锁。基于MySql的InnoDB引擎，查询语句后面增加for update，数据库会在查询过程中给数据库表增加排他锁。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。&lt;/div&gt;&lt;div&gt;还有一个问题，就是我们要使用排他锁来进行分布式锁的lock，那么一个排他锁长时间不提交，就会占用数据库连接。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b style=&quot;color: rgb(255, 0, 0);&quot;&gt;基于Redis的实现方式&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b style=&quot;color: rgb(255, 0, 0);&quot;&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;基于Redis命令：SET key value NX EX max-lock-time&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这里补充下： 从2.6.12版本后, 就可以使用set来获取锁代替了setnx, Lua 脚本来释放锁。set命令nx,xx等参数, 是为了实现 setnx 的功能。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这个set()方法一共有五个形参：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;第一个为key，我们使用key来当锁，因为key是唯一的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;第五个为time，与第四个参数相呼应，代表key的过期时间。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;总的来说，执行上面的set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。&lt;/div&gt;&lt;pre&gt;/**&lt;br&gt;&amp;nbsp;* 加单据锁&lt;br&gt;&amp;nbsp;* @param int $intOrderId 单据ID&lt;br&gt;&amp;nbsp;* @param int $intExpireTime 锁过期时间（秒）&lt;br&gt;&amp;nbsp;* @return bool|int 加锁成功返回唯一锁ID，加锁失败返回false&lt;br&gt;&amp;nbsp;*/&lt;br&gt;public static function addLock($intOrderId, $intExpireTime = self::REDIS_LOCK_DEFAULT_EXPIRE_TIME)&lt;br&gt;{&lt;br&gt;&amp;nbsp;//参数校验&lt;br&gt;&amp;nbsp;if (empty($intOrderId) || $intExpireTime &amp;lt;= 0) {&lt;br&gt;&amp;nbsp; return false;&lt;br&gt;&amp;nbsp;}&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp;//获取Redis连接&lt;br&gt;&amp;nbsp;$objRedisConn = self::getRedisConn();&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp;//生成唯一锁ID，解锁需持有此ID&lt;br&gt;&amp;nbsp;$intUniqueLockId = self::generateUniqueLockId();&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp;//根据模板，结合单据ID，生成唯一Redis key（一般来说，单据ID在业务中系统中唯一的）&lt;br&gt;&amp;nbsp;$strKey = sprintf(self::REDIS_LOCK_KEY_TEMPLATE, $intOrderId);&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp;//加锁（通过Redis setnx指令实现，从Redis 2.6.12开始，通过set指令可选参数也可以实现setnx，同时可原子化地设置超时时间）&lt;br&gt;&amp;nbsp;$bolRes = $objRedisConn-&amp;gt;set($strKey, $intUniqueLockId, [\'nx\', \'ex\'=&amp;gt;$intExpireTime]);&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp;//加锁成功返回锁ID，加锁失败返回false&lt;br&gt;&amp;nbsp;return $bolRes ? $intUniqueLockId : $bolRes;&lt;br&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;redis解锁机制：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;解锁即比对加锁时的唯一lock id，如果比对成功，则删除key；需要注意的是，解锁整个过程中同样需要保证原子性，这里依赖redis的watch与事务实现；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;WATCH命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行。监控一直持续到EXEC命令（事务中的命令是在EXEC之后才执行的，所以在MULTI命令后可以修改WATCH监控的键值）&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;/**&lt;br&gt;&amp;nbsp; * 解锁&lt;br&gt;&amp;nbsp; * @param int $intOrderId 单据ID&lt;br&gt;&amp;nbsp; * @param int $intLockId 锁唯一ID&lt;br&gt;&amp;nbsp; * @return bool&lt;br&gt;&amp;nbsp; */&lt;br&gt;&amp;nbsp;public static function releaseLock($intOrderId, $intLockId)&lt;br&gt;&amp;nbsp;{&lt;br&gt;&amp;nbsp; //参数校验&lt;br&gt;&amp;nbsp; if (empty($intOrderId) || empty($intLockId)) {&lt;br&gt;&amp;nbsp; &amp;nbsp;return false;&lt;br&gt;&amp;nbsp; }&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp; //获取Redis连接&lt;br&gt;&amp;nbsp; $objRedisConn = self::getRedisConn();&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp; //生成Redis key&lt;br&gt;&amp;nbsp; $strKey = sprintf(self::REDIS_LOCK_KEY_TEMPLATE, $intOrderId);&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp; //监听Redis key防止在【比对lock id】与【解锁事务执行过程中】被修改或删除，提交事务后会自动取消监控，其他情况需手动解除监控&lt;br&gt;&amp;nbsp; $objRedisConn-&amp;gt;watch($strKey);&lt;br&gt;&amp;nbsp; if ($intLockId == $objRedisConn-&amp;gt;get($strKey)) {&lt;br&gt;&amp;nbsp; &amp;nbsp;$objRedisConn-&amp;gt;multi()-&amp;gt;del($strKey)-&amp;gt;exec();&lt;br&gt;&amp;nbsp; &amp;nbsp;return true;&lt;br&gt;&amp;nbsp; }&lt;br&gt;&amp;nbsp; $objRedisConn-&amp;gt;unwatch();&lt;br&gt;&amp;nbsp; return false;&lt;br&gt;&amp;nbsp;}&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 14px; color: rgb(255, 0, 0);&quot;&gt;zookeeper实现分布式锁（略...）&lt;/span&gt;&lt;br&gt;&lt;/div&gt;                            ',0,'2017-06-13 00:00:00','11,16',67),(143,1,'mysql中set autocommit=0与start transaction区别','','\n                                &lt;div&gt;set autocommit=0指事务非自动提交，自此句执行以后，每个SQL语句或者语句块所在的事务都需要显示&quot;commit&quot;才能提交事务，从而释放锁。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、不管autocommit 是1还是0&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;START TRANSACTION 开启事务后，只有当commit数据才会生效，ROLLBACK后就会回滚。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、当autocommit 为 0 时&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 不管有没有START TRANSACTION。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 只有当commit数据才会生效，ROLLBACK后就会回滚。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3、如果autocommit 为1 ，并且没有START TRANSACTION 。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; mysql写入操作（基于innodb的表），会自动加锁，操作完成后会自动commit提交事务，并释放锁&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;（mysql默认是开启的autocommit 为1）&lt;/div&gt;\n                                                                                        ',0,'2016-06-15 00:00:00','11',58),(139,1,'从哪几个方面解决Redis性能调优','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;尽管Redis是一个非常快速的内存数据存储媒介，也并不代表Redis不会产生性能问题。&lt;br&gt;&lt;/p&gt;&lt;p&gt;前文中提到过，Redis采用单线程模型，所有的命令都是由一个线程串行执行的，所以当某个命令执行耗时较长时，会拖慢其后的所有命令，这使得Redis对每个任务的执行效率更加敏感。&lt;/p&gt;&lt;p&gt;针对Redis的性能优化，主要从下面几个层面入手：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;最初的也是最重要的，确保没有让Redis执行耗时长的命令&lt;/li&gt;&lt;li&gt;使用pipelining将连续执行的命令组合执行&lt;/li&gt;&lt;li&gt;操作系统的Transparent huge pages功能必须关闭：&amp;nbsp; &amp;nbsp;echo never &amp;gt; /sys/kernel/mm/transparent_hugepage/enabled&lt;/li&gt;&lt;li&gt;如果在虚拟机中运行Redis，可能天然就有虚拟机环境带来的固有延迟。可以通过./redis-cli –intrinsic-latency 100命令查看固有延迟。同时如果对Redis的性能有较高要求的话，应尽可能在物理机上直接部署Redis。&lt;/li&gt;&lt;li&gt;检查数据持久化策略&lt;/li&gt;&lt;li&gt;考虑引入读写分离机制&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;长耗时命令&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Redis绝大多数读写命令的时间复杂度都在O(1)到O(N)之间，在文本和官方文档中均对每个命令的时间复杂度有说明。&lt;/p&gt;&lt;p&gt;通常来说，O(1)的命令是安全的，O(N)命令在使用时需要注意，如果N的数量级不可预知，则应避免使用。例如对一个field数未知的Hash数据执行HGETALL/HKEYS/HVALS命令，通常来说这些命令执行的很快，但如果这个Hash中的field数量极多，耗时就会成倍增长。&lt;/p&gt;&lt;p&gt;又如使用SUNION对两个Set执行Union操作，或使用SORT对List/Set执行排序操作等时，都应该严加注意。&lt;/p&gt;&lt;p&gt;避免在使用这些O(N)命令时发生问题主要有几个办法：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;不要把List当做列表使用，仅当做队列来使用&lt;/li&gt;&lt;li&gt;通过机制严格控制Hash、Set、Sorted Set的大小&lt;/li&gt;&lt;li&gt;可能的话，将排序、并集、交集等操作放在客户端执行&lt;/li&gt;&lt;li&gt;绝对禁止使用KEYS命令&lt;/li&gt;&lt;li&gt;避免一次性遍历集合类型的所有成员，而应使用SCAN类的命令进行分批的，游标式的遍历&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Redis提供了SCAN命令，可以对Redis中存储的所有key进行游标式的遍历，避免使用KEYS命令带来的性能问题。同时还有SSCAN/HSCAN/ZSCAN等命令，分别用于对Set/Hash/Sorted Set中的元素进行游标式遍历。SCAN类命令的使用请参考官方文档：&lt;/p&gt;&lt;p&gt;https://redis.io/commands/scan&lt;/p&gt;&lt;p&gt;Redis提供了Slow Log功能，可以自动记录耗时较长的命令。相关的配置参数有两个：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;slowlog-log-slower-than xxxms&amp;nbsp; #执行时间慢于xxx毫秒的命令计入Slow Log&lt;/li&gt;&lt;li&gt;slowlog-max-len xxx&amp;nbsp; #Slow Log的长度，即最大纪录多少条Slow Log&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;使用SLOWLOG GET [number]命令，可以输出最近进入Slow Log的number条命令。&lt;/p&gt;&lt;p&gt;使用SLOWLOG RESET命令，可以重置Slow Log&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;网络引发的延迟&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;尽可能使用长连接或连接池，避免频繁创建销毁连接&lt;/li&gt;&lt;li&gt;客户端进行的批量数据操作，应使用Pipeline特性在一次交互中完成。具体请参照本文的Pipelining章节&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;数据持久化引发的延迟&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Redis的数据持久化工作本身就会带来延迟，需要根据数据的安全级别和性能要求制定合理的持久化策略：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;AOF + fsync always的设置虽然能够绝对确保数据安全，但每个操作都会触发一次fsync，会对Redis的性能有比较明显的影响&lt;/li&gt;&lt;li&gt;AOF + fsync every second是比较好的折中方案，每秒fsync一次&lt;/li&gt;&lt;li&gt;AOF + fsync never会提供AOF持久化方案下的最优性能&lt;/li&gt;&lt;li&gt;使用RDB持久化通常会提供比使用AOF更高的性能，但需要注意RDB的策略配置&lt;/li&gt;&lt;li&gt;每一次RDB快照和AOF Rewrite都需要Redis主进程进行fork操作。fork操作本身可能会产生较高的耗时，与CPU和Redis占用的内存大小有关。根据具体的情况合理配置RDB快照和AOF Rewrite时机，避免过于频繁的fork带来的延迟&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Redis在fork子进程时需要将内存分页表拷贝至子进程，以占用了24GB内存的Redis实例为例，共需要拷贝24GB / 4kB * 8 = 48MB的数据。在使用单Xeon 2.27Ghz的物理机上，这一fork操作耗时216ms。&lt;/p&gt;&lt;p&gt;可以通过INFO命令返回的latest_fork_usec字段查看上一次fork操作的耗时（微秒）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Swap引发的延迟&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当Linux将Redis所用的内存分页移至swap空间时，将会阻塞Redis进程，导致Redis出现不正常的延迟。Swap通常在物理内存不足或一些进程在进行大量I/O操作时发生，应尽可能避免上述两种情况的出现。&lt;/p&gt;&lt;p&gt;/proc/&amp;lt;pid&amp;gt;/smaps文件中会保存进程的swap记录，通过查看这个文件，能够判断Redis的延迟是否由Swap产生。如果这个文件中记录了较大的Swap size，则说明延迟很有可能是Swap造成的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;数据淘汰引发的延迟&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当同一秒内有大量key过期时，也会引发Redis的延迟。在使用时应尽量将key的失效时间错开。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;引入读写分离机制&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Redis的主从复制能力可以实现一主多从的多节点架构，在这一架构下，主节点接收所有写请求，并将数据同步给多个从节点。&lt;/p&gt;&lt;p&gt;在这一基础上，我们可以让从节点提供对实时性要求不高的读请求服务，以减小主节点的压力。&lt;/p&gt;&lt;p&gt;尤其是针对一些使用了长耗时命令的统计类任务，完全可以指定在一个或多个从节点上执行，避免这些长耗时命令影响其他请求的响应。&lt;/p&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;参考：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&amp;amp;mid=2247488684&amp;amp;idx=1&amp;amp;sn=ac37fe0c64eef9c2a2ad0b862ad49f14&amp;amp;chksm=e91b71b0de6cf8a6962b17435418f4179269c6387afd823f50757bcb1acf9c5a31a32d0f230a&amp;amp;mpshare=1&amp;amp;scene=23&amp;amp;srcid=0424xUXgkWWU92LODPyXGGTH#rd&quot; target=&quot;_blank&quot;&gt;参考自&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;',0,'2016-07-20 00:00:00','16',49),(140,1,'企业内部系统与钉钉对接的流程','','\n                                \n                                &lt;div&gt;&lt;b&gt;概述&lt;/b&gt;：企业内部系统与钉钉对接，以实现企业系统与钉钉客户端通信，主要是通过钉钉的微应用实现的。首先需要创建钉钉的组织帐号，且该帐号做为该组织的管理员，后续创建组织对应的微应用以及登入到组织后台管理等管理操作都需要该帐号。创建组织对应的微应用后，可以根据官方开发文档进行开发微应用，根据企业需要开发出需要的功能模块。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;创建微应用入口 ：&lt;a href=&quot;https://open-dev.dingtalk.com/#/index&quot; target=&quot;_blank&quot;&gt;https://open-dev.dingtalk.com/#/index&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;组织后台管理入口：&lt;a href=&quot;https://oa.dingtalk.com/contacts.htm&quot; target=&quot;_blank&quot;&gt;https://oa.dingtalk.com/contacts.htm&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;企业开发文档：&lt;a href=&quot;https://open-doc.dingtalk.com/microapp/bgb96b/ig8bih&quot; target=&quot;_blank&quot;&gt;https://open-doc.dingtalk.com/microapp/bgb96b/ig8bih&lt;/a&gt;&amp;nbsp; （一般选用H5微应用开发）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;何为微应用：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在钉钉工作台我们可以看到，下面这些应用，它们都属于钉钉的微应用，而且钉钉也提供了自建企业内部使用的微应用，这个微应用可以理解为挂载在钉钉上的一个小的网站（或应用），主要用于与企业内部系统对接。实现企业系统与钉钉的通信&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190428/82cf852b07b18de6779a71eecb280a2c.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 598px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;创建企业帐号后，登入钉钉客户端可以看到（只有企业内部员工可见）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190428/adc2aaa11ec64d79894b80dc810d4092.png&quot; data-filename=&quot;img&quot; style=&quot;width: 398px;&quot;&gt;&lt;img src=&quot;/upload/article/20190428/dcc82c9ba41b72aaa6b6ee20c09f6054.png&quot; data-filename=&quot;img&quot; style=&quot;width: 930px;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;\n                                                                                                                    ',0,'2018-06-13 00:00:00','23',58),(141,1,'分库分表操作，如何做到永不迁移数据和避免热点？','','&lt;div&gt;中大型项目中，一旦遇到数据量比较大，我们会采用对数据进行拆分的办法来解决数据库压力问题。拆分有垂直和水平两种。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;垂直拆分&lt;/span&gt;比较简单，也就是本来一个数据库，数据量大之后，从业务角度进行拆分多个库。如下图，独立的拆分出订单库和用户库。&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190430/144bc30c5ee8c29bdeda8f377f3953b2.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 746.624px; height: 215px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;水平拆分&lt;/span&gt;的概念，是同一个业务数据量大之后，进行水平拆分&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190430/4b0ec6b321e08a43537ed4d950808061.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 640px;&quot;&gt;&lt;/div&gt;&lt;div&gt;上图中订单数据达到了4000万，我们也知道mysql单表存储量推荐是百万级，如果不进行处理，mysql单表数据太大，会导致性能变慢。&lt;/div&gt;&lt;div&gt;使用方案可以参考数据进行水平拆分。把4000万数据拆分4张表或者更多。当然也可以分库，再分表；把压力从数据库层级分开。&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;分库分表方案&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;在分库分表中我们需要一种方案来解决数据存储在哪个库或者是哪个表的问题，常用的方案有hash取模和range范围方案；&lt;/div&gt;&lt;div&gt;分库分表方案最主要就是路由算法，把路由的key按照指定的算法进行路由存放。下边来介绍一下两个方案的特点。&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;1、hash取模方案&lt;/span&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190430/10d32c46894d7d3fb0ca3b45e63d93b5.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 640px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;在我们设计系统之前，可以先预估一下大概这几年的订单量，如：4000万。每张表我们可以容纳1000万，也我们可以设计4张表进行存储。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 255);&quot;&gt;那具体如何路由存储的呢？hash的方案就是对指定的路由key（如：id）对分表总数进行取模，上图中，id=12的订单，&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 255);&quot;&gt;对4进行取模，也就是会得到0，那此订单会放到0表中。id=13的订单，取模得到为1，就会放到1表中。为什么对4取模，是因为分表总数是4。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;优点：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;订单数据可以均匀的放到那4张表中，这样此订单进行操作时，就不会有热点问题。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 255);&quot;&gt;热点的含义：热点的意思就是对订单进行操作集中到1个表中，其他表的操作很少。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;订单有个特点就是时间属性，一般用户操作订单数据，都会集中到这段时间产生的订单。如果这段时间产生的订单 都在同一张订单表中，那就会形成热点，那张表的压力会比较大。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;缺点：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;将来的数据迁移和扩容，会很难。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;如：业务发展很好，订单量很大，超出了4000万的量，那我们就需要增加分表数。如果我们增加4个表&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190430/13a29f607b9fc53d1165b96e05646b2e.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 640px;&quot;&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; text-align: justify; color: rgb(255, 0, 255); overflow-wrap: break-word !important; background-color: rgb(255, 255, 255);&quot;&gt;一旦我们增加了分表的总数，取模的基数就会变成8，以前id=12的订单按照此方案就会到4表中查询，但之前的此订单时在0表的，&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 255); background-color: rgb(255, 255, 255);&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;这样就导致了数据查不到。&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;就是因为取模的基数产生了变化。&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 255); background-color: rgb(255, 255, 255);&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; text-align: justify;&quot;&gt;那有没有不需要做数据迁移的方案呢，我们看下面的方案&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; text-align: justify;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;text-align: justify;&quot;&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; color: rgb(255, 0, 0);&quot;&gt;2、range范围方案&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px;&quot;&gt;range方案也就是以范围进行拆分数据&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;img src=&quot;/upload/article/20190430/6092c07da8df49674ee7f755cb0e0ddd.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 607.752px; height: 245px;&quot;&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;div&gt;range方案比较简单，就是把一定范围内的订单，存放到一个表中；如上图id=12放到0表中，id=1300万的放到1表中。设计这个方案时就是前期把表的范围设计好。通过id进行路由存放。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;优点&lt;/span&gt;&lt;/div&gt;&lt;div&gt;我们小伙伴们想一下，此方案是不是有利于将来的扩容，不需要做数据迁移。即时再增加4张表，之前的4张表的范围不需要改变，id=12的还是在0表，id=1300万的还是在1表，&lt;/div&gt;&lt;div&gt;新增的4张表他们的范围肯定是 大于 4000万之后的范围划分的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;缺点&lt;/span&gt;&lt;/div&gt;&lt;div&gt;有热点问题，我们想一下，因为id的值会一直递增变大，那这段时间的订单是不是会一直在某一张表中，如id=1000万 ～ id=2000万之间，这段时间产生的订单是不是都会集中到此张表中，&lt;/div&gt;&lt;div&gt;这个就导致1表过热，压力过大，而其他的表没有什么压力。&lt;/div&gt;&lt;/div&gt;&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; background-color: rgb(255, 255, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); font-weight: bold;&quot;&gt;3、总结：&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; background-color: rgb(255, 255, 255);&quot;&gt;hash取模方案：没有热点问题，但扩容迁移数据痛苦&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; background-color: rgb(255, 255, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; background-color: rgb(255, 255, 255);&quot;&gt;range方案：不需要迁移数据，但有热点问题。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; background-color: rgb(255, 255, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; background-color: rgb(255, 255, 255);&quot;&gt;那有什么方案可以做到两者的优点结合呢？，即不需要迁移数据，又能解决数据热点的问题呢？&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; background-color: rgb(255, 255, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;background-color: rgb(255, 255, 255);&quot;&gt;&lt;div style=&quot;font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px;&quot;&gt;&lt;span style=&quot;color: rgb(255, 0, 0); font-weight: bold;&quot;&gt;综合方案：&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px;&quot;&gt;&lt;span style=&quot;color: rgb(255, 0, 0); font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px;&quot;&gt;hash是可以解决数据均匀的问题，range可以解决数据迁移问题，那我们可以利用这两者的特性，把两者相结合起来设计&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px;&quot;&gt;我们先定义一个group组概念，这组里面包含了一些分库以及分表，如下图&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;img src=&quot;/upload/article/20190430/e1b5d7207fdb9a1707d800502745c396.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 640px;&quot;&gt;&lt;span style=&quot;font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;p class=&quot;&quot; style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;上图有几个关键点：&lt;/span&gt;&lt;br style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;/p&gt;&lt;blockquote style=&quot;margin-top: 1em; margin-bottom: 1em; padding: 4px 0px 0px 10px; border-left-width: 3px; border-left-color: rgb(219, 219, 219); color: rgba(0, 0, 0, 0.5); font-size: 15px; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;1）id=0～4000万肯定落到group01组中&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;2）group01组有3个DB，那一个id如何路由到哪个DB？&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;3）根据hash取模定位DB，那模数为多少？&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;模数要为所有此group组DB中的表数，上图总表数为10。&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;为什么要去表的总数？&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;而不是DB总数3呢？&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;4）如id=12，id%10=2；&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;那值为2，落到哪个DB库呢？&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;这是设计是前期设定好的，那怎么设定的呢？&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;5）一旦设计定位哪个DB后，就需要确定落到DB中的哪张表呢？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;路由的核心流程：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190430/da044f607485c8343cc0ed9060735747.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 640px;&quot;&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;按照上面的流程，我们就可以根据此规则，定位一个id，我们看看有没有避免热点问题。&lt;/span&gt;&lt;br style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;我们看一下，id在【0，1000万】范围内的，根据上面的流程设计，1000万以内的id都均匀的分配到DB_0,DB_1,DB_2三个数据库中的Table_0表中，&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;为什么可以均匀，因为我们用了hash的方案，对10进行取模。&lt;/span&gt;&lt;/p&gt;&lt;blockquote style=&quot;margin-top: 1em; margin-bottom: 1em; padding: 4px 0px 0px 10px; border-left-width: 3px; border-left-color: rgb(219, 219, 219); color: rgba(0, 0, 0, 0.5); font-size: 15px; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;上面我们也提了疑问，为什么对表的总数10取模，而不是DB的总数3进行取模？&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;我们看一下为什么DB_0是4张表，其他两个DB_1是3张表？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;在我们安排服务器时，有些服务器的性能高，存储高，就可以安排多存放些数据，有些性能低的就少放点数据。&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;如果我们取模是按照DB总数3，进行取模，&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;那就代表着【0，4000万】的数据是平均分配到3个DB中的，那就不能够实现按照服务器能力适当分配了。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;按照Table总数10就能够达到，看如何达到&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;img src=&quot;/upload/article/20190430/c39ec4f4351b8f7b8c70fb20434d6ba6.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 640px;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; letter-spacing: 0.544px; overflow-wrap: break-word !important;&quot;&gt;上图中我们对10进行取模，如果值为【0，1，2，3】就路由到DB_0，【4，5，6】路由到DB_1，【7，8，9】路由到DB_2。&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; letter-spacing: 0.544px; overflow-wrap: break-word !important;&quot;&gt;现在小伙伴们有没有理解，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; letter-spacing: 0.544px; overflow-wrap: break-word !important;&quot;&gt;这样的设计就可以把多一点的数据放到DB_0中，其他2个DB数据量就可以少一点。&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; letter-spacing: 0.544px; overflow-wrap: break-word !important;&quot;&gt;DB_0承担了4/10的数据量，DB_1承担了3/10的数据量，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; letter-spacing: 0.544px; overflow-wrap: break-word !important;&quot;&gt;DB_2也承担了3/10的数据量。&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; letter-spacing: 0.544px; overflow-wrap: break-word !important;&quot;&gt;整个Group01承担了【0，4000万】的数据量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; letter-spacing: 0.544px; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;综合方案如何扩容呢？&lt;/span&gt;&lt;br&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; font-size: 16px; max-width: 100%; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; text-align: justify; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;其实上面设计思路理解了，扩容就已经出来了；&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;那就是扩容的时候再设计一个group02组，定义好此group的数据范围就ok了。&lt;/span&gt;&lt;/h1&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190430/fc6e496279078526c920fa39d63f067b.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 640px;&quot;&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; text-align: justify;&quot;&gt;因为是新增的一个group01组，所以就没有什么数据迁移概念，完全是新增的group组，而且这个group组照样就防止了热点，&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; text-align: justify;&quot;&gt;也就是【4000万，5500万】的数据，都均匀分配到三个DB的table_0表中，【5500万～7000万】数据均匀分配到table_1表中。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; text-align: justify;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; text-align: justify;&quot;&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;整个方案的设计：&lt;/span&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; text-align: justify;&quot;&gt;思路确定了，设计是比较简单的，就3张表，把group，DB，table之间建立好关联关系就行了。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190430/9aa24279a6816011c08e20804fb0c5bf.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 640px;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; text-align: justify;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190430/ce8a0c127e3c27f8a5073b2c5541a666.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 640px;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; text-align: justify;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; text-align: justify; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;上面的表关联其实是比较简单的，只要原理思路理顺了，就ok了。&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; text-align: justify; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;小伙伴们在开发的时候不要每次都去查询三张关联表，&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; text-align: justify; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;可以保存到缓存中（本地jvm缓存），这样不会影响性能。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; text-align: justify; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;这边隐含了一个关键点，那就是路由key（如：&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;id）的值是非常关键的，要求一定是有序的，自增的，这个就涉及到分布式唯一id的方案，&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: rgb(255, 255, 255);&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;摘要：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;amp;mid=2247488833&amp;amp;idx=1&amp;amp;sn=4f5fe577521431ea7f34a2a62be10382&amp;amp;chksm=e9c5ecf0deb265e6828bc92b698ef6454e365ce5efbab45b0fecfae6b733d3bd4ee2814d3ed6&amp;amp;mpshare=1&amp;amp;scene=23&amp;amp;srcid=0425X6o5NEBmm4O0ONERlUsL#rd&quot; target=&quot;_blank&quot;&gt;参考&lt;/a&gt;&lt;br&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n                                                            ',0,'2018-06-11 00:00:00','11',42),(142,1,'分布式中ID唯一的生成方案','','\n                                &lt;p&gt;&lt;/p&gt;&lt;div&gt;在我们的业务需求中通常有需要一些唯一的ID，来记录我们某个数据的标识:&lt;/div&gt;&lt;ul&gt;&lt;li&gt;某个用户的ID&lt;/li&gt;&lt;li&gt;某个订单的单号&lt;/li&gt;&lt;li&gt;某个信息的ID&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;分布式系统中我们会对一些数据量大的业务进行分拆，如：用户表，订单表。因为数据量巨大一张表无法承接，就会对其进行分库分表。&lt;/div&gt;&lt;div&gt;但一旦涉及到分库分表，就会引申出分布式系统中唯一主键ID的生成问题，永不迁移数据和避免热点的文章中要求需要唯一ID的特性：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;整个系统ID唯一&lt;/li&gt;&lt;li&gt;ID是数字类型，而且是趋势递增的&lt;/li&gt;&lt;li&gt;ID简短，查询效率快&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;分布式ID的几种生成方案&lt;/p&gt;&lt;p&gt;&lt;b style=&quot;color: rgb(255, 0, 0);&quot;&gt;1、UUID&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这个方案是小伙伴们第一个能过考虑到的方案&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;优点：&lt;/span&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;代码实现简单。&lt;/li&gt;&lt;li&gt;本机生成，没有性能问题&lt;/li&gt;&lt;li&gt;因为是全球唯一的ID，所以迁移数据容易&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;缺点：&lt;/span&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;每次生成的ID是无序的，无法保证趋势递增&lt;/li&gt;&lt;li&gt;UUID的字符串存储，查询效率慢&lt;/li&gt;&lt;li&gt;存储空间大&lt;/li&gt;&lt;li&gt;ID本事无业务含义，不可读&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;应用场景：&lt;/span&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;类似生成token令牌的场景&lt;/li&gt;&lt;li&gt;不适用一些要求有趋势递增的ID场景&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold; color: rgb(255, 0, 0);&quot;&gt;2、MySQL主键自增&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这个方案就是利用了MySQL的主键自增auto_increment，默认每次ID加1。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;优点：&lt;/span&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;数字化，id递增&lt;/li&gt;&lt;li&gt;查询效率高&lt;/li&gt;&lt;li&gt;具有一定的业务可读&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;缺点：&lt;/span&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;存在单点问题，如果mysql挂了，就没法生成iD了&lt;/li&gt;&lt;li&gt;数据库压力大，高并发抗不住&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold; color: rgb(255, 0, 0);&quot;&gt;3、MySQL多实例主键自增&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这个方案就是解决mysql的单点问题，在auto_increment基本上面，设置step步长&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190430/ec24ff9240fc0058008786693aafe89f.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 640px;&quot;&gt;&lt;/p&gt;&lt;p&gt;每台的初始值分别为1,2,3...N，步长为N（这个案例步长为4）&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;优点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;解决了单点问题&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;缺点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;一旦把步长定好后，就无法扩容；而且单个数据库的压力大，数据库自身性能无法满足高并发&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;应用场景：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;数据不需要扩容的场景&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold; color: rgb(255, 0, 0);&quot;&gt;4、雪花snowflake算法&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这个算法网上介绍了很多，老顾这里就不详细介绍。雪花算法生成64位的二进制正整数，&lt;/p&gt;&lt;p&gt;然后转换成10进制的数。64位二进制数由如下部分组成：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190430/3aad0e6632c53444d239ed888897ce7f.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 690.044px; height: 147px;&quot;&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;1位标识符：始终是0&lt;/li&gt;&lt;li&gt;41位时间戳：41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截 )得到的值，这里的的开始时间截，&lt;/li&gt;&lt;li&gt;一般是我们的id生成器开始使用的时间，由我们程序来指定的&lt;/li&gt;&lt;li&gt;10位机器标识码：可以部署在1024个节点，如果机器分机房（IDC）部署，这10位可以由 5位机房ID + 5位机器ID 组成&lt;/li&gt;&lt;li&gt;12位序列：毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;优点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;此方案每秒能够产生409.6万个ID，性能快&lt;/p&gt;&lt;p&gt;时间戳在高位，自增序列在低位，整个ID是趋势递增的，按照时间有序递增&lt;/p&gt;&lt;p&gt;灵活度高，可以根据业务需求，调整bit位的划分，满足不同的需求&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;缺点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;依赖机器的时钟，如果服务器时钟回拨，会导致重复ID生成&lt;/p&gt;&lt;p&gt;在分布式场景中，服务器时钟回拨会经常遇到，一般存在10ms之间的回拨；小伙伴们就说这点10ms，很短可以不考虑吧。&lt;/p&gt;&lt;p&gt;但此算法就是建立在毫秒级别的生成方案，一旦回拨，就很有可能存在重复ID。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold; color: rgb(255, 0, 0);&quot;&gt;5、Redis生成方案&lt;/span&gt;&lt;/p&gt;&lt;p&gt;利用redis的incr原子性操作自增，一般算法为：&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;优点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;有序递增，可读性强&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;缺点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;占用带宽，每次要向redis进行请求&lt;/p&gt;&lt;p&gt;整体测试了这个性能如下：&lt;/p&gt;&lt;p&gt;需求：同时10万个请求获取ID&lt;/p&gt;&lt;p&gt;1、并发执行完耗时：9s左右&lt;/p&gt;&lt;p&gt;2、单任务平均耗时：74ms&lt;/p&gt;&lt;p&gt;3、单线程最小耗时：不到1ms&lt;/p&gt;&lt;p&gt;4、单线程最大耗时：4.1s&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;小结&lt;/span&gt;&lt;/p&gt;&lt;p&gt;以上介绍了常见的几种分布式ID生成方案。一线大厂的分布式ID方案绝没有这个简单，他们对高并发，高可用的要求很高。&lt;/p&gt;&lt;p&gt;如Redis方案中，每次都要去Redis去请求，有网络请求耗时，并发强依赖了Redis。这个设计是有风险的，一旦Redis挂了，整个系统不可用。&lt;/p&gt;&lt;p&gt;而且一线大厂也会考虑到ID安全性的问题，如：Redis方案中，用户是可以预测下一个ID号是多少，因为算法是递增的。&lt;/p&gt;&lt;p&gt;这样的话竞争对手第一天中午12点下个订单，就可以看到平台的订单ID是多少，第二天中午12点再下一单，又平台订单ID到多少。&lt;/p&gt;&lt;p&gt;这样就可以猜到平台1天能产生多少订单了，这个是绝对不允许的，公司绝密啊。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(255, 0, 0); font-weight: bold;&quot;&gt;一线大厂是如何设计的呢?&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我们提到的分库分表数据存储的问题，都是由ID通过一些算法来决定存储在哪个表里，&lt;/p&gt;&lt;p&gt;所以我们首先需要解决的问题是，即将插入的这条数据它的ID是多少，所以我们需要一个专门生成ID的接口，&lt;/p&gt;&lt;p&gt;并且该接口能可以实现ID的全局唯一性。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(255, 0, 0); font-weight: bold;&quot;&gt;1.模拟数据库主键自增&lt;/span&gt;&lt;/p&gt;&lt;p&gt;要是我们单纯的使用数据库主键自增，我们每次获取ID的时候，都要去数据库请求一次（获取当前最大ID然后加1）。&lt;/p&gt;&lt;p&gt;这样会造成数据库压力山大，那我们可以不可以不要每次去取？&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;设计思路：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我们可以请求数据库得到ID的时候，可设计成获得的ID是一个ID区间段。然后把该区间段数值保存在本地服务器缓存中，&lt;/p&gt;&lt;p&gt;每次请求时，先从缓存中去取，判断该区间值是否用完，然后才决定访问数据库，再次获取ID区间段&lt;/p&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190430/593cf76078ec093adfb9629c136203ac.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 550.466px; height: 498px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;p class=&quot;&quot; style=&quot;margin-bottom: 0px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; text-align: left; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;我们看上图，有张ID规则表：&lt;/span&gt;&lt;br style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;/p&gt;&lt;blockquote style=&quot;margin-top: 1em; margin-bottom: 1em; padding: 4px 0px 0px 10px; border-left-width: 3px; border-left-color: rgb(219, 219, 219); color: rgba(0, 0, 0, 0.5); font-size: 15px; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;1、id表示为主键，无业务含义。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;2、biz_tag为了表示业务，因为整体系统中会有很多业务需要生成ID，这样可以共用一张表维护&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;3、max_id表示现在整体系统中已经分配的最大ID&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;4、desc描述&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;5、update_time表示每次取的ID时间&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;div&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;我们再来看看整体流程：&lt;/span&gt;&lt;/p&gt;&lt;blockquote style=&quot;margin-top: 1em; margin-bottom: 1em; padding: 4px 0px 0px 10px; border-left-width: 3px; border-left-color: rgb(219, 219, 219); color: rgba(0, 0, 0, 0.5); font-size: 15px; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;1、【用户服务】在注册一个用户时，需要一个用户ID；&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;会请求【生成ID服务(是独立的应用)】的接口&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;2、【生成ID服务】会去查询数据库，找到user_tag的id，现在的max_id为0，step=1000&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;3、【生成ID服务】把max_id和step返回给【用户服务】；&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;并且把max_id更新为max_id = max_id + step，即更新为1000&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;4、【用户服务】获得max_id=0，step=1000；&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;5、 这个用户服务可以用ID=【max_id + 1，max_id+step】区间的ID，即为【1，1000】&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;6、【用户服务】会把这个区间保存到jvm中&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;7、【用户服务】需要用到ID的时候，在区间【1，1000】中依次获取id，可采用AtomicLong中的getAndIncrement方法。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;8、如果把区间的值用完了，再去请求【生产ID服务】接口，获取到max_id为1000，即可以用【max_id + 1，max_id+step】区间的ID，即为【1001，2000】&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;br&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个方案就非常完美的解决了数据库自增的问题，而且可以自行定义max_id的起点，和step步长，非常方便扩容。&lt;/p&gt;&lt;p&gt;而且也解决了数据库压力的问题，因为在一段区间内，是在jvm内存中获取的，而不需要每次请求数据库。&lt;/p&gt;&lt;p&gt;即使数据库宕机了，系统也不受影响，ID还能维持一段时间。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;2、竞争问题&lt;/span&gt;&lt;/p&gt;&lt;p&gt;以上方案中，如果是集群系统有多个用户服务器，同时获取ID，同时去请求【ID服务】，在获取max_id的时候会存在并发问题。&lt;/p&gt;&lt;blockquote style=&quot;margin-top: 1em; margin-bottom: 1em; padding: 4px 0px 0px 10px; border-left-width: 3px; border-left-color: rgb(219, 219, 219); color: rgba(0, 0, 0, 0.5); font-size: 15px; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;如用户服务A，取到的max_id=1000 ;用户服务B取到的也是max_id=1000，那就出现了问题，Id重复了。&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;那怎么解决？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;其实方案很多，加分布式锁，保证同一时刻只有一个用户服务获取max_id。&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;当然也可以用数据库自身的锁去解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190430/676f8d5216c7f74321b30b4663e7b47e.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 713.333px; height: 107px;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px;&quot;&gt;利用事务方式加行锁，上面的语句，在没有执行完之前，是不允许第二个用户服务请求过来的，第二个请求只能阻塞。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; font-weight: bold;&quot;&gt;3、突发阻塞问题&lt;/span&gt;&lt;br&gt;&lt;img src=&quot;/upload/article/20190430/48e087676cb8c113fefab9d8b035e7a1.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 640px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px;&quot;&gt;上图中，多个用户服务获取到了各自的ID区间，在高并发场景下，ID用的很快，如果3个用户服务在某一时刻都用完了，同时去请求【ID服务】。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px;&quot;&gt;因为上面提到的竞争问题，所有只有一个用户服务去操作数据库，其他二个会被阻塞&lt;/span&gt;&lt;/p&gt;&lt;blockquote style=&quot;margin-top: 1em; margin-bottom: 1em; padding: 4px 0px 0px 10px; border-left-width: 3px; border-left-color: rgb(219, 219, 219); color: rgba(0, 0, 0, 0.5); font-size: 15px; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;小伙伴就会问，有这么巧吗？&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;同时ID用完。&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;我们这里举的是3个用户服务，感觉概率不大；&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;如果是100个用户服务呢？&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;概率是不是一下子大了。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;出现的现象就是一会儿突然系统耗时变长，一会儿好了，就是这个原因导致的，怎么去解决？&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px; font-weight: bold;&quot;&gt;4、双buffer方案&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px;&quot;&gt;在一般的系统设计中，双buffer会经常看到，怎么去解决上面的问题也可以采用双buffer方案。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;img src=&quot;/upload/article/20190430/407df4f341e9209afd537c52ba30654f.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 640px;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px; letter-spacing: 0.544px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;在设计的时候，采用双buffer方案，上图的流程：&lt;/span&gt;&lt;br style=&quot;margin: 0px; padding: 0px; max-width: 100%; overflow-wrap: break-word !important;&quot;&gt;&lt;/p&gt;&lt;blockquote style=&quot;margin-top: 1em; margin-bottom: 1em; padding: 4px 0px 0px 10px; border-left-width: 3px; border-left-color: rgb(219, 219, 219); color: rgba(0, 0, 0, 0.5); font-size: 15px; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; text-align: justify; overflow-wrap: break-word !important;&quot;&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;1、当前获取ID在buffer1中，每次获取ID在buffer1中获取&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;2、当buffer1中的Id已经使用到了100，也就是达到区间的10%&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;3、达到了10%，先判断buffer2中有没有去获取过，如果没有就立即发起请求获取ID线程，此线程把获取到的ID，设置到buffer2中。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;4、如果buffer1用完了，会自动切换到buffer2&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;5、buffer2用到10%了，也会启动线程再次获取，设置到buffer1中&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; line-height: 2em; text-align: left; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;6、依次往返&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;双buffer的方案，小伙伴们有没有感觉很酷，这样就达到了业务场景用的ID，都是在jvm内存中获得的，从此不需要到数据库中获取了。&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;允许数据库宕机时间更长了。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 17px; letter-spacing: 0.544px; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;因为会有一个线程，会观察什么时候去自动获取。&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;两个buffer之间自行切换使用。&lt;/span&gt;&lt;span style=&quot;margin: 0px; padding: 0px; max-width: 100%; font-size: 15px; overflow-wrap: break-word !important;&quot;&gt;就解决了突发阻塞的问题。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 15px; margin-bottom: 15px; padding: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(51, 51, 51); font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; line-height: 2em; overflow-wrap: break-word !important;&quot;&gt;&lt;span style=&quot;font-size: 15px;&quot;&gt;摘要自：&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;amp;mid=2247488851&amp;amp;idx=1&amp;amp;sn=d7045daec9fffba77ae89e7f49e49704&amp;amp;chksm=e9c5ece2deb265f455d887b36855c0b4d8c1d943573d2dbfbd3b24ca548b5da500eb79bbdb69&amp;amp;mpshare=1&amp;amp;scene=23&amp;amp;srcid=#rd&quot; target=&quot;_blank&quot;&gt;https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;amp;mid=2247488851&amp;amp;idx=1&amp;amp;sn=d7045daec9fffba77ae89e7f49e49704&amp;amp;chksm=e9c5ece2deb265f455d887b36855c0b4d8c1d943573d2dbfbd3b24ca548b5da500eb79bbdb69&amp;amp;mpshare=1&amp;amp;scene=23&amp;amp;srcid=#rd&lt;/a&gt;&lt;/p&gt;                            ',0,'2017-07-13 00:00:00','11',53),(144,1,'如何保证缓存和数据库双写一致性？','','\r\n                                &lt;p&gt;&lt;span style=&quot;color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;在项目中缓存是经常用到的，为了减少和数据库的交互，小伙伴们利用缓存的思路如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190430/78d600cf250a2a4f2375fbd413720218.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 640px;&quot;&gt;&lt;span style=&quot;color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;以上场景需要考虑的是缓存数据更新与数据库一致的问题，主要分为以下几个场景：&lt;/p&gt;&lt;p&gt;&lt;b&gt;先更新数据库，再更新缓存&lt;/b&gt;&lt;/p&gt;&lt;p&gt;存在的问题场景：请求A更新值为99，请求B更新值为98&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190430/76a6ab3c6f1fee32e4eb15fb91899e28.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 640px;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 16px; margin-bottom: 16px; padding: 0px; color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;上图流程：&lt;/p&gt;&lt;pre style=&quot;-webkit-tap-highlight-color: transparent; font-family: Consolas, Menlo, Courier, monospace; font-size: 16px; position: relative; line-height: 1.5; color: rgb(153, 153, 153); margin-top: 1em; margin-bottom: 1em; padding: 12px 10px; background: rgb(244, 245, 246); border-color: rgb(232, 232, 232);&quot;&gt;1）请求A先发起，更新数据库为99，但还没有来得及更新缓存&lt;br style=&quot;-webkit-tap-highlight-color: transparent;&quot;&gt;2）请求B发起，更新数据库为98，又更新了缓存值为98&lt;br style=&quot;-webkit-tap-highlight-color: transparent;&quot;&gt;3）请求A这时才更新缓存的值为99&lt;/pre&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;这样数据库的值为98，但缓存的值为99，数值不一致。（不推荐）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;先更新缓存，再更新数据库&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这个流程跟上面很类似，出现的问题也很类似&lt;/p&gt;&lt;pre style=&quot;-webkit-tap-highlight-color: transparent; font-family: Consolas, Menlo, Courier, monospace; font-size: 16px; position: relative; line-height: 1.5; color: rgb(153, 153, 153); margin-top: 1em; margin-bottom: 1em; padding: 12px 10px; background: rgb(244, 245, 246); border-color: rgb(232, 232, 232);&quot;&gt;1）请求A先更新缓存为99，但还没有来得及更新数据库&lt;br style=&quot;-webkit-tap-highlight-color: transparent;&quot;&gt;2）请求B更新缓存为98，又更新了数据库为98&lt;br style=&quot;-webkit-tap-highlight-color: transparent;&quot;&gt;3）请求A这时更新数据库为99&lt;/pre&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;这样就缓存的值为98，数据库为99导致不一致。（不推荐）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;#222222&quot; face=&quot;PingFang SC, Hiragino Sans GB, Microsoft YaHei, WenQuanYi Micro Hei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;&lt;b&gt;先删除缓存，再更新数据库&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;#222222&quot; face=&quot;PingFang SC, Hiragino Sans GB, Microsoft YaHei, WenQuanYi Micro Hei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;存在的问题场景：请求A更新值为99，请求B获取值&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190430/fc227ec87490080b6deb5d10964fa4d3.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 640px;&quot;&gt;&lt;span style=&quot;color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 16px; margin-bottom: 16px; padding: 0px; color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;上图中请求流程：&lt;/p&gt;&lt;pre style=&quot;-webkit-tap-highlight-color: transparent; font-family: Consolas, Menlo, Courier, monospace; font-size: 16px; position: relative; line-height: 1.5; color: rgb(153, 153, 153); margin-top: 1em; margin-bottom: 1em; padding: 12px 10px; background: rgb(244, 245, 246); border-color: rgb(232, 232, 232);&quot;&gt;1）请求A更新值，先把缓存中的值删除，但还没有来得及更新数据库&lt;br style=&quot;-webkit-tap-highlight-color: transparent;&quot;&gt;2）此时请求B过来查询此值，发现缓存中不存在，就到数据库中查询&lt;br style=&quot;-webkit-tap-highlight-color: transparent;&quot;&gt;3）请求B在数据库中获取到值，在把值设置到缓存中。&lt;br style=&quot;-webkit-tap-highlight-color: transparent;&quot;&gt;4）请求A这时才更新数据库里面的值为99&lt;/pre&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;这样就导致了缓存和数据库的不一致问题，缓存中的值一直是旧数据。（不推荐）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;#222222&quot; face=&quot;PingFang SC, Hiragino Sans GB, Microsoft YaHei, WenQuanYi Micro Hei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;&lt;b&gt;先更新数据库，再删除缓存&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;#222222&quot; face=&quot;PingFang SC, Hiragino Sans GB, Microsoft YaHei, WenQuanYi Micro Hei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;这个方案也是老外提出的《Cache-Aside pattern》更新缓存的策略。这种策略先保证了源头的数据一定是正确的。这种策略是不是万无一失呢，有一种非常特殊的场景&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190430/528f63a376b44c9f68a5a64f15855828.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 640px;&quot;&gt;&lt;font color=&quot;#222222&quot; face=&quot;PingFang SC, Hiragino Sans GB, Microsoft YaHei, WenQuanYi Micro Hei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 16px; margin-bottom: 16px; padding: 0px; color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;上图流程：建立中缓存突然失效了&lt;/p&gt;&lt;pre style=&quot;-webkit-tap-highlight-color: transparent; font-family: Consolas, Menlo, Courier, monospace; font-size: 16px; position: relative; line-height: 1.5; color: rgb(153, 153, 153); margin-top: 1em; margin-bottom: 1em; padding: 12px 10px; background: rgb(244, 245, 246); border-color: rgb(232, 232, 232);&quot;&gt;1）请求A发起查询请求，直接到数据库查询到100，但还没有来得及去设置缓存&lt;br style=&quot;-webkit-tap-highlight-color: transparent;&quot;&gt;2）请求B更新值，先更新数据库，在删除缓存&lt;br style=&quot;-webkit-tap-highlight-color: transparent;&quot;&gt;3）请求A这时才设置缓存为100&lt;br style=&quot;-webkit-tap-highlight-color: transparent;&quot;&gt;&lt;/pre&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 16px; margin-bottom: 16px; padding: 0px; color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;这种情况发生的不一致，是因为缓存突然失效了。而且还要保证请求B更新操作 比 请求A的查询操作还要快；才会导致不一致。&lt;span style=&quot;-webkit-tap-highlight-color: transparent; font-weight: 700;&quot;&gt;这种情况概率会很少。一般要求不高的项目可以采用此方式（推荐）。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 16px; margin-bottom: 16px; padding: 0px;&quot;&gt;&lt;font color=&quot;#222222&quot; face=&quot;PingFang SC, Hiragino Sans GB, Microsoft YaHei, WenQuanYi Micro Hei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;&lt;b&gt;缓存删除失败，导致不一致&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 16px; margin-bottom: 16px; padding: 0px;&quot;&gt;&lt;font color=&quot;#222222&quot; face=&quot;PingFang SC, Hiragino Sans GB, Microsoft YaHei, WenQuanYi Micro Hei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;b&gt;&lt;span style=&quot;-webkit-tap-highlight-color: transparent; font-size: 16px;&quot;&gt;&lt;/span&gt;&lt;/b&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 16px; margin-bottom: 16px; padding: 0px;&quot;&gt;&lt;font color=&quot;#222222&quot; face=&quot;PingFang SC, Hiragino Sans GB, Microsoft YaHei, WenQuanYi Micro Hei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;这种先更新数据库，再删除缓存的策略中，因为要删除缓存，但如果缓存删除失败，就会导致数据库与缓存不一致。这个问题怎么办？我们正常想到的是利用我们MQ中间件去实现。&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190430/5ee025fb0878dae265243b52ef9d41c5.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 640px;&quot;&gt;&lt;span style=&quot;color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;#222222&quot; face=&quot;PingFang SC, Hiragino Sans GB, Microsoft YaHei, WenQuanYi Micro Hei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;上图的流程，如果删除缓存失败，发送消息投递到消息中间件中，进入消息队列。也许有小伙伴就会问，如果消息投递失败怎么办？我们可以利用消息中间件那边的保证100%消息投递的机制。这样就保证了即使删除消息失败，我们也会重试。&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;摘要：&lt;a href=&quot;https://www.toutiao.com/i6669945231242166791/&quot; target=&quot;_blank&quot;&gt;https://www.toutiao.com/i6669945231242166791/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;                            ',0,'2017-10-17 00:00:00','11,16',40),(145,1,'DB读写分离，主从数据不一致问题的解决方案','','\n                                \n                                &lt;p&gt;&lt;b&gt;概述：&lt;/b&gt;在中大型项目中，为了解决大流量请求时，提高系统的吞吐量。因为在整个业务中基本都是读多写少，大部分都是读请求，很小部分是写请求。为了解决这个问题多数的解决方案是采用读写分离，主从复制的方案设计。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190502/ccb8e35a32816eb2544ccd7ac0be8609.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 509px; height: 463.667px;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 16px; margin-bottom: 16px; padding: 0px; color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;上图：&lt;/p&gt;&lt;blockquote style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 1em; margin-bottom: 1em; padding: 12px 10px; position: relative; font-size: 16px; line-height: 1.5; color: rgb(153, 153, 153); background: rgb(244, 245, 246); border-width: 1px; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-color: rgb(232, 232, 232); border-image: initial; font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif;&quot;&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-bottom: 0px; padding: 0px;&quot;&gt;1）一个主库负责写请求，更新数据&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-bottom: 0px; padding: 0px;&quot;&gt;2）两个从库负责读请求，可以提高系统吞吐量&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; padding: 0px;&quot;&gt;3）主库和从库之间同步数据&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;根据mysql主从复制的原理，主从同步会出现延迟现象，读写分离时可能会造成主库和从库数据不一致的情况&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190502/acc9510db943217a02aded0d602055a5.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 575.719px; height: 525.344px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 16px; margin-bottom: 16px; padding: 0px; color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;上图中业务流程&lt;/p&gt;&lt;blockquote style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 1em; margin-bottom: 1em; padding: 12px 10px; position: relative; font-size: 16px; line-height: 1.5; color: rgb(153, 153, 153); background: rgb(244, 245, 246); border-width: 1px; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-color: rgb(232, 232, 232); border-image: initial; font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif;&quot;&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-bottom: 0px; padding: 0px;&quot;&gt;1）写请求A进行数据更新，但写库还没有来得及把更新的数据更新到读库&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-bottom: 0px; padding: 0px;&quot;&gt;2）读请求B进行数据查询，请求B是访问的读库，获取的是旧值&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; padding: 0px;&quot;&gt;3）因为写库和读库之间存在同步延迟，导致数据在不同库中不一致&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;对于这种情况如果是对数据一致性要求不是很高的情况，可以采取“数据最终一致”的方案，即允许数据出现延迟，但是最终还是保持一致性。但是对于一些要求数据实时一致性的业务来说，我们可以尝试一下几种方案：&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.缓存标记法\n&lt;/b&gt;&lt;br class=&quot;Apple-interchange-newline&quot;&gt;&lt;/p&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190502/20ec785d8a001ef79e04c7cf896d77db.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 574.938px; height: 433px;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 16px; margin-bottom: 16px; padding: 0px; color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;上图流程：&lt;/p&gt;&lt;blockquote style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 1em; margin-bottom: 1em; padding: 12px 10px; position: relative; font-size: 16px; line-height: 1.5; color: rgb(153, 153, 153); background: rgb(244, 245, 246); border-width: 1px; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-color: rgb(232, 232, 232); border-image: initial; font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif;&quot;&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-bottom: 0px; padding: 0px;&quot;&gt;1）A发起写请求，更新了主库，但在缓存中设置一个标记，代表此数据已经更新，标记格式（业务代号：数据库：表：主键ID）根据自己业务场景。&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-bottom: 0px; padding: 0px;&quot;&gt;2）设置此标记，要加上过期时间，可以为预估的主库和从库同步延迟的时间&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-bottom: 0px; padding: 0px;&quot;&gt;3）B发起读请求的时候，先判断此请求的业务在缓存中有没有更新标记&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; padding: 0px;&quot;&gt;4）如果存在标记，走主库；如果没有走从库。&lt;/p&gt;&lt;/blockquote&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 16px; margin-bottom: 16px; padding: 0px; color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;这个方案就有效了解决了数据不一致的问题。&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 16px; margin-bottom: 16px; padding: 0px;&quot;&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;&lt;font face=&quot;PingFang SC, Hiragino Sans GB, Microsoft YaHei, WenQuanYi Micro Hei, Helvetica Neue, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;但这个方案会有个严重的问题，也就是每次的读请求都要到缓存中去判断是否存在缓存标记，如果是单机部署用的是jvm缓存，对性能还好；但如果是集群部署缓存肯定用redis，每次读都要和redis进行交互，这样肯定会影响系统吞吐量。&lt;/span&gt;&lt;/font&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;2.本地缓存标记&lt;/span&gt;&lt;/p&gt;&lt;p&gt;与上述方案类似，只是把缓存标记保存到了客户端&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190502/8ef4d75da872dcf87bb1476731efb64b.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 541.538px; height: 407px;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 16px; margin-bottom: 16px; padding: 0px; color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;上图流程：&lt;/p&gt;&lt;blockquote style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 1em; margin-bottom: 1em; padding: 12px 10px; position: relative; font-size: 16px; line-height: 1.5; color: rgb(153, 153, 153); background: rgb(244, 245, 246); border-width: 1px; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-color: rgb(232, 232, 232); border-image: initial; font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif;&quot;&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-bottom: 0px; padding: 0px;&quot;&gt;1）用户A发起写请求，更新了主库，并在客户端设置标记，过期时间，如：cookies&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-bottom: 0px; padding: 0px;&quot;&gt;2）用户A再发起读请求时，带上这个本地标记在后端&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-bottom: 0px; padding: 0px;&quot;&gt;3）后端在处理请求时，获取请求传过来的数据，看有没有这个标记（如：cookies）&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; padding: 0px;&quot;&gt;4）有这个业务标记，走主库；没有走从库。&lt;/p&gt;&lt;/blockquote&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 16px; margin-bottom: 16px; padding: 0px; color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;这个方案就保证了用户A的读请求肯定是数据一致的，而且没有性能问题，因为标记是本地客户端传过去的。&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 16px; margin-bottom: 16px; padding: 0px;&quot;&gt;&lt;span style=&quot;font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px; color: rgb(255, 0, 0);&quot;&gt;这种方案有一个问题就是其它客户端访问不到这个缓存标记，导致其它的用户访问的数据不一致，但不一致的时间很短，过个1～10秒就能够看到。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 16px; margin-bottom: 16px; padding: 0px;&quot;&gt;&lt;span style=&quot;font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px; color: rgb(255, 0, 0);&quot;&gt;但这个方案解决了当前用户的数据一致性的问题，所以可以推荐使用&lt;/span&gt;&lt;/p&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;扩展问题：读写分离情况下，如何解决缓存和数据库不一致性问题&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190502/7512204944b0a5a544e5d812fb1e1af6.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 640px;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 16px; margin-bottom: 16px; padding: 0px; color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;上图流程：&lt;/p&gt;&lt;blockquote style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 1em; margin-bottom: 1em; padding: 12px 10px; position: relative; font-size: 16px; line-height: 1.5; color: rgb(153, 153, 153); background: rgb(244, 245, 246); border-width: 1px; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-color: rgb(232, 232, 232); border-image: initial; font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif;&quot;&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-bottom: 0px; padding: 0px;&quot;&gt;1）应用服务（商品服务）请求A更新库存为99，原值为100&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-bottom: 0px; padding: 0px;&quot;&gt;2）但主库同步到从库需要时间，还没有同步完成时，请求B发起读请求&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-bottom: 0px; padding: 0px;&quot;&gt;3）读请求B走的是从库，取出来从库里面的旧值100&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-bottom: 0px; padding: 0px;&quot;&gt;4）读请求B会把取出来的值，再设置到缓存中，值为100&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; padding: 0px;&quot;&gt;5）但当从库同步数据完成，从库的数据值为99，这就导致数据库和缓存数据不一致&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;更新用户再次发起读请求&lt;/b&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 16px; margin-bottom: 16px; padding: 0px; color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;在方案二中，其他用户的读请求会有暂时间读取到的是旧值，如何缩短时间？其实是有一个方案，就是让更新用户再次发起读请求，也就是在方案二最后提到的&lt;/p&gt;&lt;blockquote style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 1em; margin-bottom: 1em; padding: 12px 10px; position: relative; font-size: 16px; line-height: 1.5; color: rgb(153, 153, 153); background: rgb(244, 245, 246); border-width: 1px; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-color: rgb(232, 232, 232); border-image: initial; font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif;&quot;&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-bottom: 0px; padding: 0px;&quot;&gt;1）更新用户再次发起读请求，根据本地缓存标记，直接走主数据库，读取的肯定是新值，&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-bottom: 0px; padding: 0px;&quot;&gt;2）再把这个新值设置到缓存中。这样就保证了缓存中的是新值，虽然从库还没有不同完成，但缓存中已经是新值了。&lt;/p&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; padding: 0px;&quot;&gt;3）最后从库同步数据完成，值就达到了一致性&lt;/p&gt;&lt;/blockquote&gt;&lt;p style=&quot;-webkit-tap-highlight-color: transparent; margin-top: 16px; margin-bottom: 16px; padding: 0px; color: rgb(34, 34, 34); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; font-size: 16px;&quot;&gt;&lt;span style=&quot;-webkit-tap-highlight-color: transparent;&quot;&gt;此方案的问题：就是更新操作后，多了一步读请求。&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;参考：&lt;a href=&quot;https://www.toutiao.com/i6670699080143864327/&quot; target=&quot;_blank&quot;&gt;https://www.toutiao.com/i6670699080143864327/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                                                        ',0,'2017-11-23 00:00:00','11',38),(146,1,'java的进程和线程的概念','','\n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;一、进程与线程&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，即进程空间或（虚空间）。进程不依赖于线程而独立存在，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。&lt;/p&gt;&lt;p&gt;线程是指进程中的一个执行流程，一个进程中可以运行多个线程。比如java.exe进程中可以运行很多线程。线程总是属于某个进程，线程没有自己的虚拟地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;“同时”执行是人的感觉，在线程之间实际上轮换执行。&lt;/p&gt;&lt;p&gt;进程在执行过程中拥有独立的内存单元，进程有独立的地址空间，而多个线程共享内存，从而极大地提高了程序的运行效率。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。&lt;/p&gt;&lt;p&gt;进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器,一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。&lt;/p&gt;&lt;p&gt;线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程包含以下内容：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&amp;nbsp;一个指向当前被执行指令的指令指针；&lt;/li&gt;&lt;li&gt;一个栈；&lt;/li&gt;&lt;li&gt;一个寄存器值的集合，定义了一部分描述正在执行线程的处理器状态的值&lt;/li&gt;&lt;li&gt;一个私有的数据区。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190503/158f0ebc2d0fab21dbefee57b54c6516.png&quot; data-filename=&quot;img&quot; style=&quot;width: 643px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;简而言之：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一个程序至少有一个进程，一个进程至少有一个线程。&lt;/li&gt;&lt;li&gt;线程的划分尺度小于进程，使得多进程程序的并发性高。&lt;/li&gt;&lt;li&gt;另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。&lt;/li&gt;&lt;li&gt;线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。&lt;/li&gt;&lt;li&gt;从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;在Java中，每次程序运行至少启动2个线程：一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际上就是在操作系统中启动了一个进程。&lt;/p&gt;&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;/** Thread类实现的多线程例子，Thread是一个实现了Runnable这个接口的一个类**/&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;public static void &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;main&lt;/span&gt;(String[] args) {&lt;br&gt;   &lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;/**java多线程**/&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;    &lt;/span&gt;Thread t1 = &lt;span style=&quot;color:#cc7832;&quot;&gt;new &lt;/span&gt;javaThread(&lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;线程1&quot;&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;Thread t2 = &lt;span style=&quot;color:#cc7832;&quot;&gt;new &lt;/span&gt;javaThread(&lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;线程2&quot;&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;t1.start()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;t2.start()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;}&lt;br&gt;&lt;br&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;public &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;javaThread&lt;/span&gt;(String name) { &lt;span style=&quot;color:#808080;&quot;&gt;//带参数的构造方法 给线程命名&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;super&lt;/span&gt;(name)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;}&lt;br&gt;&lt;br&gt;&lt;span style=&quot;color:#bbb529;&quot;&gt;@Override&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;public void &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;run&lt;/span&gt;() {  &lt;span style=&quot;color:#808080;&quot;&gt;// 重写Thread类的run方法，执行当前运行线程的业务代码&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;for&lt;/span&gt;(&lt;span style=&quot;color:#cc7832;&quot;&gt;int &lt;/span&gt;i = &lt;span style=&quot;color:#6897bb;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;/span&gt;i&amp;lt;&lt;span style=&quot;color:#6897bb;&quot;&gt;5&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;/span&gt;i++){&lt;br&gt;        &lt;span style=&quot;color:#cc7832;&quot;&gt;try &lt;/span&gt;{&lt;br&gt;            System.&lt;span style=&quot;color:#9876aa;font-style:italic;&quot;&gt;out&lt;/span&gt;.println(&lt;span style=&quot;color:#cc7832;&quot;&gt;this&lt;/span&gt;.getName()+&lt;span style=&quot;color:#6a8759;&quot;&gt;&quot; :&quot;&lt;/span&gt;+i)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;Thread.&lt;span style=&quot;font-style:italic;&quot;&gt;sleep&lt;/span&gt;(&lt;span style=&quot;color:#6897bb;&quot;&gt;2000&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;  &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//延迟执行&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        &lt;/span&gt;} &lt;span style=&quot;color:#cc7832;&quot;&gt;catch&lt;/span&gt;(InterruptedException ie) {}&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;结果：&lt;/p&gt;&lt;p&gt;线程2 :0&lt;/p&gt;&lt;p&gt;线程1 :0&lt;/p&gt;&lt;p&gt;线程1 :1&lt;/p&gt;&lt;p&gt;线程2 :1&lt;/p&gt;&lt;p&gt;线程1 :2&lt;/p&gt;&lt;p&gt;线程2 :2&lt;/p&gt;&lt;p&gt;线程1 :3&lt;/p&gt;&lt;p&gt;线程2 :3&lt;/p&gt;&lt;p&gt;线程1 :4&lt;/p&gt;&lt;p&gt;线程2 :4&lt;/p&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;一些常见问题&lt;/b&gt;&lt;/p&gt;&lt;p&gt;1、线程的名字，一个运行中的线程总是有名字的，名字有两个来源，一个是虚拟机自己给的名字，一个是你自己的定的名字。在没有指定线程名字的情况下，虚拟机总会为线程指定名字，并且主线程的名字总是mian，非主线程的名字不确定。&lt;/p&gt;&lt;p&gt;2、线程都可以设置名字，也可以获取线程的名字，连主线程也不例外。&lt;/p&gt;&lt;p&gt;3、在上面的代码中，只能保证：每个线程都将启动，每个线程都将运行直到完成。一系列线程以某种顺序启动并不意味着将按该顺序执行。对于任何一组启动的线程来说，调度程序不能保证其执行次序，持续时间也无法保证。&lt;/p&gt;&lt;p&gt;4、当线程目标run()方法结束时该线程完成。&lt;/p&gt;&lt;p&gt;5、一旦线程启动，它就永远不能再重新启动。只有一个新的线程可以被启动，并且只能一次。一个可运行的线程或死线程可以被重新启动。&lt;/p&gt;&lt;p&gt;6、线程的调度是JVM的一部分，在一个CPU的机器上上，实际上一次只能运行一个线程。一次只有一个线程栈执行。JVM线程调度程序决定实际运行哪个处于可运行状态的线程。众多可运行线程中的某一个会被选中做为当前线程。可运行线程被选择运行的顺序是没有保障的。&lt;/p&gt;&lt;p&gt;7、尽管通常采用队列形式，但这是没有保障的。队列形式是指当一个线程完成“一轮”时，它移到可运行队列的尾部等待，直到它最终排队到该队列的前端为止，它才能被再次选中。事实上，我们把它称为可运行池而不是一个可运行队列，目的是帮助认识线程并不都是以某种有保障的顺序排列唱呢个一个队列的事实。&lt;/p&gt;&lt;p&gt;9、尽管我们没有无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                            ',0,'2017-06-14 00:00:00','34',25),(147,1,'java线程栈模型&线程状态的转换','','\n                                \n                                &lt;div&gt;要理解线程调度的原理，以及线程执行过程，必须理解线程栈模型。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;线程栈是指某时刻时内存中线程调度的栈信息，当前调用的方法总是位于栈顶。线程栈的内容是随着程序的运行动态变化的，因此研究线程栈必须选择一个运行的时刻（实际上指代码运行到什么地方)。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;下面通过一个示例性的代码说明线程（调用）栈的变化过程。&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190503/95a4c8a02c0308874d2b720fd83da113.png&quot; data-filename=&quot;img&quot; style=&quot;width: 663px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;这幅图描述在代码执行到两个不同时刻1、2时候，虚拟机线程调用栈示意图。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;当程序执行到t.start();时候，程序多出一个分支（增加了一个调用栈B），这样，栈A、栈B并行执行。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;线程状态的转换&lt;/b&gt;&lt;/div&gt;&lt;div&gt;线程的状态转换是线程控制的基础。线程状态总的可分为五大状态：分别是生、死、可运行、运行、等待/阻塞。用一个图来描述如下：&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190503/d5af91cfd137f497a3212db8815f571b.png&quot; data-filename=&quot;img&quot; style=&quot;width: 636px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;1、新状态：线程对象已经创建，还没有在其上调用start()方法。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、可运行状态：当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，线程首先进入可运行状态。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可运行状态。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3、运行状态：线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;4、等待/阻塞/睡眠状态：这是线程有资格运行时它所处的状态。实际上这个三状态组合为一种，其共同点是：线程仍旧是活的，但是当前没有条件运行。换句话说，它是可运行的，但是如果某件事件出现，他可能返回到可运行状态。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;5、死亡态：当线程的run()方法完成时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;1.阻止线程执行&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;对于线程的阻止，考虑一下三个方面，不考虑IO阻塞的情况：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;睡眠；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;等待；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;因为需要一个对象的锁定而被阻塞。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、睡眠&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Thread.sleep静态方法强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。当线程睡眠时，它入睡在某个地方，在苏醒之前不会返回到可运行状态。当睡眠时间到期，则返回到可运行状态。&lt;/div&gt;&lt;div&gt;&lt;div&gt;线程睡眠的原因：线程执行太快，或者需要强制进入下一轮，因为Java规范不保证合理的轮换。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;睡眠的实现：调用静态方法。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;try {&lt;br&gt;&amp;nbsp; &amp;nbsp; Thread.sleep(123);&lt;br&gt;} catch (InterruptedException e) {&lt;br&gt;&amp;nbsp; &amp;nbsp; e.printStackTrace();&amp;nbsp;&amp;nbsp;&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;睡眠的位置：为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程中会睡眠。&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;注意：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、线程睡眠是帮助所有线程获得运行机会的最好方法。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、线程睡眠到期自动苏醒，并返回到可运行状态，不是运行状态。sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始执行。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3、sleep()是静态方法，只能控制当前正在运行的线程。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;2、线程的优先级和线程让步yield()&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;线程的让步是通过Thread.yield()来实现的。yield()方法的作用是：暂停当前正在执行的线程对象，并执行其他线程。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;要理解yield()，必须了解线程的优先级的概念。线程总是存在优先级，优先级范围在1~10之间。JVM线程调度程序是基于优先级的抢先调度机制。在大多数情况下，当前运行的线程优先级将大于或等于线程池中任何线程的优先级。但这仅仅是大多数情况。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;注意：当设计多线程应用程序的时候，一定不要依赖于线程的优先级。因为线程调度优先级操作是没有保障的，只能把线程优先级作用作为一种提高程序效率的方法，但是要保证程序不依赖这种操作。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;当线程池中线程都具有相同的优先级，调度程序的JVM实现自由选择它喜欢的线程。这时候调度程序的操作有两种可能：一是选择一个线程运行，直到它阻塞或者运行完成为止。二是时间分片，为池内的每个线程提供均等的运行机会。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;设置线程的优先级：线程默认的优先级是创建它的执行线程的优先级。可以通过setPriority(int newPriority)更改线程的优先级。例如：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;Thread t = new MyThread();&lt;br&gt;t.setPriority(8);&lt;br&gt;t.start();&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;线程优先级为1~10之间的正整数，JVM从不会改变一个线程的优先级。然而，1~10之间的值是没有保证的。一些JVM可能不能识别10个不同的值，而将这些优先级进行每两个或多个合并，变成少于10个的优先级，则两个或多个优先级的线程可能被映射为一个优先级。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;线程默认优先级是5，Thread类中有三个常量，定义线程优先级范围：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;static int MAX_PRIORITY&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 线程可以具有的最高优先级。&lt;/div&gt;&lt;div&gt;static int MIN_PRIORITY&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 线程可以具有的最低优先级。&lt;/div&gt;&lt;div&gt;static int NORM_PRIORITY&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 分配给线程的默认优先级。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;3、Thread.yield()方法&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;4、join()方法&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，B不能工作。例如：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;Thread t = new MyThread();&lt;br&gt;t.start();&lt;br&gt;t.join();&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;另外，join()方法还有带超时限制的重载版本。例如t.join(5000);则让线程等待5000毫秒，如果超过这个时间，则停止等待，变为可运行状态。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;线程的加入join()对线程栈导致的结果是线程栈发生了变化，当然这些变化都是瞬时的。下面给示意图：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;小结&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;到目前位置，介绍了线程离开运行状态的3种方法：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、调用Thread.sleep()：使当前线程睡眠至少多少毫秒（尽管它可能在指定的时间之前被中断）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、调用Thread.yield()：不能保障太多事情，尽管通常它会让当前运行线程回到可运行性状态，使得有相同优先级的线程有机会执行。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3、调用join()方法：保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;除了以上三种方式外，还有下面几种特殊情况可能使线程离开运行状态：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、线程的run()方法完成。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、在对象上调用wait()方法（不是在线程上调用）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3、线程不能在对象上获得锁定，它正试图运行该对象的方法代码。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;4、线程调度程序可以决定将当前运行状态移动到可运行状态，以便让另一个线程获得运行机会，而不需要任何理由。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/riskyer/p/3263032.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/riskyer/p/3263032.html&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n                                                                                                                    ',0,'2017-06-16 00:00:00','34',49),(148,1,'java多线程的调度策略','','\n                                &lt;div&gt;两种线程的调度模式：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;抢占式调度：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;协同式调度：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190504/bb87a393eee368f8c962981315aa62cb.png&quot; data-filename=&quot;img&quot; style=&quot;width: 533px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;JVM的实现：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;JVM规范中规定每个线程都有优先级，且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;java使用的线程调度式抢占式调度&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Java中线程会按优先级分配CPU时间片运行&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;线程让出cpu的情况：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;当前运行线程主动放弃CPU，JVM暂时放弃CPU操作（基于时间片轮转调度的JVM操作系统不会让线程永久放弃CPU，或者说放弃本次时间片的执行权），例如调用yield()方法。&lt;/div&gt;&lt;div&gt;当前运行线程因为某些原因进入阻塞状态，例如阻塞在I/O上。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;当前运行线程结束，即运行完run()方法里面的任务。&lt;/div&gt;&lt;/div&gt;\n                                                                                        ',0,'2017-06-16 00:00:00','34',32),(149,1,'多线程 ---并发与并行概念总结','','\n                                &lt;div&gt;&lt;b&gt;多线程&lt;/b&gt;：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1.在了解线程之前，要先知道进程这个概念。进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。简单点说，进程就是执行中的程序活动，是一个活动的实体。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.多进程，就好比同时打开了Word，Excel和Visio，他们都是不同的程序运行活动，即多个进程同时启动而已，这个概念比较好理解。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.线程，是一个执行中的程序活动（即进程）的多个执行路径，执行调度的单位。线程依托于进程存在，在进程之下，可以共享进程的内存，而且还拥有一个属于自己的内存空间，这段内存空间也叫做线程栈，是在建立线程时由系统分配的，主要用来保存线程内部所使用的数据。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;4.多线程，指在一个进程下有多个线程。各个线程执行自己的任务，这些线程可以”同时进行“（这里加了双引号，下面会讲述到加双引号的原因）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;5.那多线程有什么好处？多线程应用在生活中随处可见，Word文档就是一个很好的例子。Word有“后台打印”的功能，用户点击打印按钮后，如果发现可以对当前文本进行修改，可以在打印过程中回到主界面进行修改、保存等操作。 如果没有应用多线程，不妨假设用户要打印的文本很长很长，那么用户要等打印操作执行完后，才可以对文本进行修改编辑保存等，这样用户体验就不如多线程的好。还有迅雷，有没有发现迅雷是可以同时下载东西的？例如同时下载A，B，A下载进度到53.4%，B下载进度到47.1%，有时A速度快些，有时B速度快些，反正能确定的是A，B都在下载内容，而不是一定要等A下载完后，B才可以开始下载，这也是多线程的作用。因此，多线程强调”同时，一起进行“，而不是单一的顺下操作。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;outline: 0px; margin: 0px; padding: 0px; overflow-wrap: break-word; color: rgb(79, 79, 79); font-family: &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, Roboto, Noto, Arial, &amp;quot;PingFang SC&amp;quot;, sans-serif; font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;并发：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190505/4c3e799f37617172a612f25e386759c5.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 295px;&quot;&gt;&lt;span style=&quot;outline: 0px; margin: 0px; padding: 0px; font-weight: 700; overflow-wrap: break-word; color: rgb(79, 79, 79); font-family: &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, Roboto, Noto, Arial, &amp;quot;PingFang SC&amp;quot;, sans-serif; font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;outline: 0px; margin: 0px; padding: 0px; font-weight: 700; overflow-wrap: break-word; color: rgb(79, 79, 79); font-family: &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, Roboto, Noto, Arial, &amp;quot;PingFang SC&amp;quot;, sans-serif; font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;outline: 0px; margin: 0px; padding: 0px; overflow-wrap: break-word;&quot;&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#4f4f4f&quot; face=&quot;Microsoft YaHei, SF Pro Display, Roboto, Noto, Arial, PingFang SC, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;1.Concurrency，是并发的意思。并发的实质是一个物理CPU(也可以多个物理CPU) 在若干道程序（或线程）之间多路复用，并发性是对有限物理资源强制行使多用户共享以提高效率。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#4f4f4f&quot; face=&quot;Microsoft YaHei, SF Pro Display, Roboto, Noto, Arial, PingFang SC, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#4f4f4f&quot; face=&quot;Microsoft YaHei, SF Pro Display, Roboto, Noto, Arial, PingFang SC, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;2.微观角度：所有的并发处理都有排队等候，唤醒，执行等这样的步骤，在微观上他们都是序列被处理的，如果是同一时刻到达的请求（或线程）也会根据优先级的不同，而先后进入队列排队等候执行。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#4f4f4f&quot; face=&quot;Microsoft YaHei, SF Pro Display, Roboto, Noto, Arial, PingFang SC, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#4f4f4f&quot; face=&quot;Microsoft YaHei, SF Pro Display, Roboto, Noto, Arial, PingFang SC, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;3.宏观角度：多个几乎同时到达的请求（或线程）在宏观上看就像是同时在被处理。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#4f4f4f&quot; face=&quot;Microsoft YaHei, SF Pro Display, Roboto, Noto, Arial, PingFang SC, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#4f4f4f&quot; face=&quot;Microsoft YaHei, SF Pro Display, Roboto, Noto, Arial, PingFang SC, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;4.通俗点讲，并发就是只有一个CPU资源，程序（或线程）之间要竞争得到执行机会。图中的第一个阶段，在A执行的过程中B，C不会执行，因为这段时间内这个CPU资源被A竞争到了，同理，第二个阶段只有B在执行，第三个阶段只有C在执行。其实，并发过程中，A，B，C并不是同时在进行的（微观角度）。但又是同时进行的（宏观角度）。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#4f4f4f&quot; face=&quot;Microsoft YaHei, SF Pro Display, Roboto, Noto, Arial, PingFang SC, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#4f4f4f&quot; face=&quot;Microsoft YaHei, SF Pro Display, Roboto, Noto, Arial, PingFang SC, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;&lt;b&gt;并行：&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;img src=&quot;/upload/article/20190505/db453f3f1949c6ada898bef3a8485da8.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 313px;&quot;&gt;&lt;font color=&quot;#4f4f4f&quot; face=&quot;Microsoft YaHei, SF Pro Display, Roboto, Noto, Arial, PingFang SC, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#4f4f4f&quot; face=&quot;Microsoft YaHei, SF Pro Display, Roboto, Noto, Arial, PingFang SC, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font face=&quot;Microsoft YaHei, SF Pro Display, Roboto, Noto, Arial, PingFang SC, sans-serif&quot;&gt;&lt;div style=&quot;color: rgb(79, 79, 79);&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;1.Parallelism，即并行，指两个或两个以上事件（或线程）在同一时刻发生，是真正意义上的不同事件或线程在同一时刻，在不同CPU资源呢上（多核），同时执行。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;color: rgb(79, 79, 79);&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;2.并行，不存在像并发那样竞争，等待的概念。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;color: rgb(79, 79, 79);&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;3.图中，A，B，C都在同时运行（微观，宏观）。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;color: rgb(79, 79, 79);&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;div style=&quot;color: rgb(79, 79, 79);&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;&lt;b&gt;通过多线程实现并发，并行：&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;color: rgb(79, 79, 79);&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;color: rgb(79, 79, 79);&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;1.java中的Thread类定义了多线程，通过多线程可以实现并发或并行。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;color: rgb(79, 79, 79);&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;color: rgb(79, 79, 79);&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;2.在CPU比较繁忙，资源不足的时候（开启了很多进程），操作系统只为一个含有多线程的进程分配仅有的CPU资源，这些线程就会为自己尽量多抢时间片，这就是通过多线程实现并发，线程之间会竞争CPU资源争取执行机会。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;color: rgb(79, 79, 79);&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;color: rgb(79, 79, 79);&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;3.在CPU资源比较充足的时候，一个进程内的多线程，可以被分配到不同的CPU资源，这就是通过多线程实现并行。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;color: rgb(79, 79, 79);&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;&lt;span style=&quot;color: rgb(79, 79, 79);&quot;&gt;4.&lt;/span&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;至于多线程实现的是并发还是并行？取决于系统的CPU是单核还是多核&lt;/span&gt;&lt;span style=&quot;color: rgb(79, 79, 79);&quot;&gt;；上面所说，所写多线程可能被分配到单核CPU中执行，也可能被分配到多核CPU执行。&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;color: rgb(79, 79, 79);&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;color: rgb(79, 79, 79);&quot;&gt;&lt;span style=&quot;font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;5.不管并发还是并行，都提高了程序对CPU资源的利用率，最大限度地利用CPU资源。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;color: rgb(79, 79, 79); font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;参考资料：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;http://www.zhihu.com/question/19901763&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;http://blog.csdn.net/ochangwen/article/details/51115993&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;http://blog.csdn.net/suxinpingtao51/article/details/8113509&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;http://www.cnblogs.com/DreamSea/archive/2012/01/11/JavaThread.html#navigation&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;http://bbs.csdn.net/topics/390651960&lt;/div&gt;&lt;/font&gt;&lt;/div&gt;&lt;/span&gt;&lt;br&gt;&lt;/div&gt;                            ',0,'2016-03-02 00:00:00','34,33',54),(150,1,'Java并发编程：线程池的实现原理以及使用实例','','\n                                \n                                \n                                &lt;p&gt;我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：&lt;/p&gt;&lt;p&gt;　　如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。&lt;/p&gt;&lt;p&gt;　　那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？&lt;/p&gt;&lt;p&gt;在Java中可以通过线程池来达到这样的效果。&lt;/p&gt;&lt;p&gt;线程池原理：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190506/2923c0e9c4d0c8073460654ed508053c.png&quot; data-filename=&quot;img&quot; style=&quot;width: 693px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;线程池:JDK1.5之后提供的&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; java.util.concurrent.Executors:线程池的工厂类,用来生成线程池&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; Executors类中的静态方法:&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; static ExecutorService newFixedThreadPool(int nThreads) 创建一个可重用固定线程数的线程池&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 参数:&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int nThreads:创建线程池中包含的线程数量&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 返回值:&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ExecutorService接口,返回的是ExecutorService接口的实现类对象,我们可以使用ExecutorService接口接收(面向接口编程)&lt;/p&gt;&lt;p&gt;java.util.concurrent.ExecutorService:线程池接口&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 用来从线程池中获取线程,调用start方法,执行线程任务&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; submit(Runnable task) 提交一个 Runnable 任务用于执行&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 关闭/销毁线程池的方法&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; void shutdown()&lt;/p&gt;&lt;p&gt;线程池的使用步骤:&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 1.使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 2.创建一个类,实现Runnable接口,重写run方法,设置线程任务&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 3.调用ExecutorService中的方法submit,传递线程任务(实现类),开启线程,执行run方法&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 4.调用ExecutorService中的方法shutdown销毁线程池(不建议执行)&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3932921.html&quot;&gt;https://www.cnblogs.com/dolphin0520/p/3932921.html&lt;/a&gt;\n                                                            &lt;/p&gt;                                                                                    ',0,'2017-06-17 00:00:00','34',45),(151,1,'java多线程-线程安全问题的解决方案','','\n                                \n                                \n                                \n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;什么是线程安全和线程不安全&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。&lt;/li&gt;&lt;li&gt;线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;产生线程安全的原因：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;学习java多线程的时候，经常碰到以 i++为例的说明多线程是不安全的，说i++分三步操作完成的，如果执行到中间步骤，其余的线程也同时操作了该变量，就会出现线程不安全的问题；但是要理解这个问题，其实是需要一些计算机方面的理论作为铺垫的，否则无法真正理解这个解释；下面我们来说明下，这些前置知识；&lt;/p&gt;&lt;p&gt;工作内存和主内存？&lt;/p&gt;&lt;p&gt;工作内存：每个多线程都有自己的工作内存；是线程私有的；&lt;/p&gt;&lt;p&gt;主内存：是所有线程共享的内存；&lt;/p&gt;&lt;p&gt;计算机的cpu在运算的时候，并不总是从内存读取数据，他的数据读取顺序是：寄存器&amp;gt;高速缓存&amp;gt;内存（寄存器和高速缓存就是工作内存）；线程耗费的是CPU，线程运算的原始数据来自于主内存，但在运算的过程中，有些数据需要频繁的别读取，这些数据被存储在寄存器中和高速缓存中，当线程运算完成后，这些缓存的数据在适当的时候在写会到主内存中；因此，只要有多于一个的线程访问同一个变量，而且其中某个线程会写入该变量，此时必须使用同步来协调线程对该变量的访问；JVM是一个虚拟的计算机，也面临多线程并发的问题，java程序运行在java虚拟机平台上，java程序员不可能会直接去操作控制底层线程对寄存器，高速缓存和主内存之间的同步问题；因此java从语法层面给程序员提供了一写解决方案，即volatile(可见性)、synchronize（独占锁），锁机制等等；&lt;/p&gt;&lt;p&gt;volatile是通过要求对变量的每一次修改都需要同步到主内存来保证线程安全性；&lt;/p&gt;&lt;p&gt;synchronize是通过独占锁，synchronize修饰的代码只有获得锁的线程才可以执行，其余想要执行该代码，都需要等到获得锁的线程释放锁之后，才可以获得，当然，可能有多个线程都在等待，下一个是哪个线程获得锁也是不定的，所以synchronize使用时，粒度应该尽量小，以减少获取锁的时长；&lt;/p&gt;&lt;p&gt;&lt;b&gt;多线程安全问题例子：（以售票为例）&lt;/b&gt;&lt;/p&gt;&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;public class &lt;/span&gt;duoxiancheng {&lt;br&gt;    &lt;span style=&quot;color:#cc7832;&quot;&gt;public static void &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;main&lt;/span&gt;(String[] args) {&lt;br&gt;        SellTicketRunnable runnable = &lt;span style=&quot;color:#cc7832;&quot;&gt;new &lt;/span&gt;SellTicketRunnable()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//线程1.模拟窗口1&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        &lt;/span&gt;Thread thread1 = &lt;span style=&quot;color:#cc7832;&quot;&gt;new &lt;/span&gt;Thread(runnable)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//线程2.模拟窗口2&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        &lt;/span&gt;Thread thread2 = &lt;span style=&quot;color:#cc7832;&quot;&gt;new &lt;/span&gt;Thread(runnable)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;thread1.setName(&lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;窗口1&quot;&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;thread2.setName(&lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;窗口2&quot;&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//开启线程&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        &lt;/span&gt;thread1.start()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;thread2.start()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;}&lt;br&gt;}&lt;br&gt;&lt;br&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;class &lt;/span&gt;SellTicketRunnable &lt;span style=&quot;color:#cc7832;&quot;&gt;implements &lt;/span&gt;Runnable{&lt;br&gt;    &lt;span style=&quot;color:#808080;&quot;&gt;//公共资源。代售票&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;private int &lt;/span&gt;&lt;span style=&quot;color:#9876aa;&quot;&gt;ticketCount &lt;/span&gt;= &lt;span style=&quot;color:#6897bb;&quot;&gt;100&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#bbb529;&quot;&gt;@Override&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#bbb529;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;public void &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;run&lt;/span&gt;() {&lt;br&gt;        &lt;span style=&quot;color:#cc7832;&quot;&gt;while &lt;/span&gt;(&lt;span style=&quot;color:#cc7832;&quot;&gt;true&lt;/span&gt;) {&lt;br&gt;            &lt;span style=&quot;color:#cc7832;&quot;&gt;if&lt;/span&gt;(&lt;span style=&quot;color:#9876aa;&quot;&gt;ticketCount &lt;/span&gt;&amp;gt; &lt;span style=&quot;color:#6897bb;&quot;&gt;0&lt;/span&gt;){&lt;br&gt;                &lt;span style=&quot;color:#808080;&quot;&gt;// 模拟多线程对共享数据造成污染的概率&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;                &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;try &lt;/span&gt;{&lt;br&gt;                    Thread.&lt;span style=&quot;font-style:italic;&quot;&gt;sleep&lt;/span&gt;(&lt;span style=&quot;color:#6897bb;&quot;&gt;100&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;                &lt;/span&gt;} &lt;span style=&quot;color:#cc7832;&quot;&gt;catch &lt;/span&gt;(InterruptedException e) {&lt;br&gt;                    &lt;span style=&quot;color:#808080;&quot;&gt;// &lt;/span&gt;&lt;span style=&quot;color:#a8c023;font-style:italic;&quot;&gt;TODO Auto-generated catch block&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#a8c023;font-style:italic;&quot;&gt;                    &lt;/span&gt;e.printStackTrace()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;                &lt;/span&gt;}&lt;br&gt;                &lt;span style=&quot;color:#808080;&quot;&gt;//模拟售票过程&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;                &lt;/span&gt;System.&lt;span style=&quot;color:#9876aa;font-style:italic;&quot;&gt;out&lt;/span&gt;.println(Thread.&lt;span style=&quot;font-style:italic;&quot;&gt;currentThread&lt;/span&gt;().getName()&lt;br&gt;                        + &lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;正在卖第：&quot; &lt;/span&gt;+ &lt;span style=&quot;color:#9876aa;&quot;&gt;ticketCount&lt;/span&gt;-- + &lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;张票&quot;&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;}&lt;span style=&quot;color:#cc7832;&quot;&gt;else&lt;/span&gt;{&lt;br&gt;                &lt;span style=&quot;color:#808080;&quot;&gt;//终止线程&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;                &lt;/span&gt;Thread.&lt;span style=&quot;font-style:italic;&quot;&gt;currentThread&lt;/span&gt;().interrupt()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;}&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;&lt;/pre&gt;&lt;p&gt;会发现两个窗口都在卖同一张票，这就是由于多线程导致的线程安全问题。&lt;/p&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;解决方案&lt;/b&gt;&lt;/div&gt;&lt;div&gt;通常我们使用同步（关键字为synchronized）来解决这种由于多线程同时操作共享数据带来的线程安全问题。&lt;/div&gt;&lt;div&gt;同步可以理解为：我们将多条操作共享数据的语句代码包成一个整体，让某个线程执行时其他线程不能执行。&lt;/div&gt;&lt;div&gt;同步方案包括三种方式，它们对应的锁对象是不一样的。另外我们可以通过加锁来同步代码块，解决安全问题。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;因此常用的解决方案有四种。&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;注意：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;&amp;nbsp; &amp;nbsp;同步可以解决问题的根本原因就在于锁对象上，因此要避免线程安全问题，多个线程必须使用同一个锁对象，否则，不能解决问题。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;1、同步代码块&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;/**&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * 1、同步代码块&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * 格式：synchronized(对象) {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; *        需要被同步的代码;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * }&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; *&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * 这里的锁对象可以是任意对象。&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * 利用这种方法优化后的代码如下：&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; *&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * //创建锁对象。这个也是共享的资源。多个线程使用的是同一锁对象&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * private Object obj = new Object();&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * synchronized(obj) {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; *&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; *       需要被同步的代码;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * }&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; *原理：&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * 当线程进入同步代码块时，首先会判断是否有对象锁，如果有对象锁，会获取到该对象锁然后执行同步代码块的内容，&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * 当上一个线程还没有退出CPU执行权限时，该对象锁会一直跟随线程，其它线程由于获取不到对象锁就会处于阻塞状态，直到上一个线程&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * 释放锁对象&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt; * **/&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;利用这种方法优化后的代码如下：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;class &lt;/span&gt;SellTicketRunnable &lt;span style=&quot;color:#cc7832;&quot;&gt;implements &lt;/span&gt;Runnable{&lt;br&gt;    &lt;span style=&quot;color:#808080;&quot;&gt;//公共资源。代售票&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;private int &lt;/span&gt;&lt;span style=&quot;color:#9876aa;&quot;&gt;ticketCount &lt;/span&gt;= &lt;span style=&quot;color:#6897bb;&quot;&gt;100&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//创建锁对象。这个也是共享的资源。多个线程使用的是同一锁对象&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;private &lt;/span&gt;Object &lt;span style=&quot;color:#9876aa;&quot;&gt;obj &lt;/span&gt;= &lt;span style=&quot;color:#cc7832;&quot;&gt;new &lt;/span&gt;Object()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#bbb529;&quot;&gt;@Override&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#bbb529;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;public void &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;run&lt;/span&gt;() {&lt;br&gt;        &lt;span style=&quot;color:#cc7832;&quot;&gt;while &lt;/span&gt;(&lt;span style=&quot;color:#cc7832;&quot;&gt;true&lt;/span&gt;) {&lt;br&gt;            &lt;span style=&quot;color:#808080;&quot;&gt;//同步代码块&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;synchronized &lt;/span&gt;(&lt;span style=&quot;color:#9876aa;&quot;&gt;obj&lt;/span&gt;) {&lt;br&gt;                &lt;span style=&quot;color:#cc7832;&quot;&gt;if &lt;/span&gt;(&lt;span style=&quot;color:#9876aa;&quot;&gt;ticketCount &lt;/span&gt;&amp;gt; &lt;span style=&quot;color:#6897bb;&quot;&gt;0&lt;/span&gt;) {&lt;br&gt;                    &lt;span style=&quot;color:#808080;&quot;&gt;// 模拟多线程对共享数据造成污染的概率&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;                    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;try &lt;/span&gt;{&lt;br&gt;                        Thread.&lt;span style=&quot;font-style:italic;&quot;&gt;sleep&lt;/span&gt;(&lt;span style=&quot;color:#6897bb;&quot;&gt;100&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;                    &lt;/span&gt;} &lt;span style=&quot;color:#cc7832;&quot;&gt;catch &lt;/span&gt;(InterruptedException e) {&lt;br&gt;                        &lt;span style=&quot;color:#808080;&quot;&gt;// &lt;/span&gt;&lt;span style=&quot;color:#a8c023;font-style:italic;&quot;&gt;TODO Auto-generated catch block&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#a8c023;font-style:italic;&quot;&gt;                        &lt;/span&gt;e.printStackTrace()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;                    &lt;/span&gt;}&lt;br&gt;                    &lt;span style=&quot;color:#808080;&quot;&gt;//模拟售票过程&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;                    &lt;/span&gt;System.&lt;span style=&quot;color:#9876aa;font-style:italic;&quot;&gt;out&lt;/span&gt;.println(Thread.&lt;span style=&quot;font-style:italic;&quot;&gt;currentThread&lt;/span&gt;().getName()&lt;br&gt;                            + &lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;正在卖第：&quot; &lt;/span&gt;+ &lt;span style=&quot;color:#9876aa;&quot;&gt;ticketCount&lt;/span&gt;-- + &lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;张票&quot;&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;                &lt;/span&gt;} &lt;span style=&quot;color:#cc7832;&quot;&gt;else &lt;/span&gt;{&lt;br&gt;                    &lt;span style=&quot;color:#808080;&quot;&gt;//终止线程&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;                    &lt;/span&gt;Thread.&lt;span style=&quot;font-style:italic;&quot;&gt;currentThread&lt;/span&gt;().interrupt()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;                &lt;/span&gt;}&lt;br&gt;            }&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;2、同步方法&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;/*&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* 格式： 修饰符 synchronized  返回值类型 方法名（参数）{&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;*      需要被同步的代码;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* }。&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* 这时的锁对象是this。&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;* **/&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;class &lt;/span&gt;SellTicketRunnable &lt;span style=&quot;color:#cc7832;&quot;&gt;implements &lt;/span&gt;Runnable {&lt;br&gt;    &lt;span style=&quot;color:#808080;&quot;&gt;// 公共资源。代售票&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;private int &lt;/span&gt;&lt;span style=&quot;color:#9876aa;&quot;&gt;ticketCount &lt;/span&gt;= &lt;span style=&quot;color:#6897bb;&quot;&gt;100&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#bbb529;&quot;&gt;@Override&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#bbb529;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;public void &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;run&lt;/span&gt;() {&lt;br&gt;        &lt;span style=&quot;color:#cc7832;&quot;&gt;while &lt;/span&gt;(&lt;span style=&quot;color:#cc7832;&quot;&gt;true&lt;/span&gt;) {&lt;br&gt;            sellTicket()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;}&lt;br&gt;    }&lt;br&gt;    &lt;span style=&quot;color:#808080;&quot;&gt;//同步方法.这时的锁对象是this。也就是SellTicketRunnable&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;private synchronized void &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;sellTicket&lt;/span&gt;() {&lt;br&gt;        &lt;span style=&quot;color:#cc7832;&quot;&gt;if &lt;/span&gt;(&lt;span style=&quot;color:#9876aa;&quot;&gt;ticketCount &lt;/span&gt;&amp;gt; &lt;span style=&quot;color:#6897bb;&quot;&gt;0&lt;/span&gt;) {&lt;br&gt;            &lt;span style=&quot;color:#cc7832;&quot;&gt;try &lt;/span&gt;{&lt;br&gt;                &lt;span style=&quot;color:#808080;&quot;&gt;// 模拟售票过程&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;                &lt;/span&gt;Thread.&lt;span style=&quot;font-style:italic;&quot;&gt;sleep&lt;/span&gt;(&lt;span style=&quot;color:#6897bb;&quot;&gt;100&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;} &lt;span style=&quot;color:#cc7832;&quot;&gt;catch &lt;/span&gt;(InterruptedException e) {&lt;br&gt;                e.printStackTrace()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;}&lt;br&gt;            System.&lt;span style=&quot;color:#9876aa;font-style:italic;&quot;&gt;out&lt;/span&gt;.println(Thread.&lt;span style=&quot;font-style:italic;&quot;&gt;currentThread&lt;/span&gt;().getName() + &lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;正在卖第：&quot;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#6a8759;&quot;&gt;                    &lt;/span&gt;+ &lt;span style=&quot;color:#9876aa;&quot;&gt;ticketCount&lt;/span&gt;-- + &lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;张票&quot;&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;}&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;3、静态同步方法&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;格式：将同步加在静态方法上。此时的锁对象为当前类的.class文件。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;class &lt;/span&gt;SellTicketRunnable &lt;span style=&quot;color:#cc7832;&quot;&gt;implements &lt;/span&gt;Runnable {&lt;br&gt;    &lt;span style=&quot;color:#808080;&quot;&gt;// 公共静态资源。代售票&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;private static int &lt;/span&gt;&lt;span style=&quot;color:#9876aa;font-style:italic;&quot;&gt;ticketCount &lt;/span&gt;= &lt;span style=&quot;color:#6897bb;&quot;&gt;100&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#bbb529;&quot;&gt;@Override&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#bbb529;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;public void &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;run&lt;/span&gt;() {&lt;br&gt;        &lt;span style=&quot;color:#cc7832;&quot;&gt;while &lt;/span&gt;(&lt;span style=&quot;color:#cc7832;&quot;&gt;true&lt;/span&gt;) {&lt;br&gt;            &lt;span style=&quot;font-style:italic;&quot;&gt;sellTicket&lt;/span&gt;()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;}&lt;br&gt;    }&lt;br&gt;    &lt;span style=&quot;color:#808080;&quot;&gt;//同步方法.这时的锁对象是this。也就是SellTicketRunnable&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;private static synchronized void &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;sellTicket&lt;/span&gt;() {&lt;br&gt;        &lt;span style=&quot;color:#cc7832;&quot;&gt;if &lt;/span&gt;(&lt;span style=&quot;color:#9876aa;font-style:italic;&quot;&gt;ticketCount &lt;/span&gt;&amp;gt; &lt;span style=&quot;color:#6897bb;&quot;&gt;0&lt;/span&gt;) {&lt;br&gt;            &lt;span style=&quot;color:#cc7832;&quot;&gt;try &lt;/span&gt;{&lt;br&gt;                &lt;span style=&quot;color:#808080;&quot;&gt;// 模拟售票过程&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;                &lt;/span&gt;Thread.&lt;span style=&quot;font-style:italic;&quot;&gt;sleep&lt;/span&gt;(&lt;span style=&quot;color:#6897bb;&quot;&gt;100&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;} &lt;span style=&quot;color:#cc7832;&quot;&gt;catch &lt;/span&gt;(InterruptedException e) {&lt;br&gt;                e.printStackTrace()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;}&lt;br&gt;            System.&lt;span style=&quot;color:#9876aa;font-style:italic;&quot;&gt;out&lt;/span&gt;.println(Thread.&lt;span style=&quot;font-style:italic;&quot;&gt;currentThread&lt;/span&gt;().getName() + &lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;正在卖第：&quot;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#6a8759;&quot;&gt;                    &lt;/span&gt;+ &lt;span style=&quot;color:#9876aa;font-style:italic;&quot;&gt;ticketCount&lt;/span&gt;-- + &lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;张票&quot;&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;}&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;&lt;div&gt;4、加锁Lock解决问题&lt;/div&gt;&lt;div&gt;将需要一次执行完代码块用lock()和unlock()包裹，来保证线程安全。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;class &lt;/span&gt;SellTicketRunnable &lt;span style=&quot;color:#cc7832;&quot;&gt;implements &lt;/span&gt;Runnable {&lt;br&gt;    &lt;span style=&quot;color:#808080;&quot;&gt;// 公共静态资源。代售票&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;private static int &lt;/span&gt;&lt;span style=&quot;color:#9876aa;font-style:italic;&quot;&gt;ticketCount &lt;/span&gt;= &lt;span style=&quot;color:#6897bb;&quot;&gt;100&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//定义锁对象。ReentrantLock是Lock的实现类.&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;private &lt;/span&gt;Lock &lt;span style=&quot;color:#9876aa;&quot;&gt;lock &lt;/span&gt;= &lt;span style=&quot;color:#cc7832;&quot;&gt;new &lt;/span&gt;ReentrantLock()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#bbb529;&quot;&gt;@Override&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#bbb529;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;public void &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;run&lt;/span&gt;() {&lt;br&gt;        &lt;span style=&quot;color:#cc7832;&quot;&gt;while &lt;/span&gt;(&lt;span style=&quot;color:#cc7832;&quot;&gt;true&lt;/span&gt;) {&lt;br&gt;            &lt;span style=&quot;color:#cc7832;&quot;&gt;try &lt;/span&gt;{&lt;br&gt;                &lt;span style=&quot;color:#808080;&quot;&gt;//加锁&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;                &lt;/span&gt;&lt;span style=&quot;color:#9876aa;&quot;&gt;lock&lt;/span&gt;.lock()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;                if &lt;/span&gt;(&lt;span style=&quot;color:#9876aa;font-style:italic;&quot;&gt;ticketCount &lt;/span&gt;&amp;gt; &lt;span style=&quot;color:#6897bb;&quot;&gt;0&lt;/span&gt;) {&lt;br&gt;                    &lt;span style=&quot;color:#cc7832;&quot;&gt;try &lt;/span&gt;{&lt;br&gt;                        &lt;span style=&quot;color:#808080;&quot;&gt;// 模拟售票过程&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;                        &lt;/span&gt;Thread.&lt;span style=&quot;font-style:italic;&quot;&gt;sleep&lt;/span&gt;(&lt;span style=&quot;color:#6897bb;&quot;&gt;100&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;                    &lt;/span&gt;} &lt;span style=&quot;color:#cc7832;&quot;&gt;catch &lt;/span&gt;(InterruptedException e) {&lt;br&gt;                        e.printStackTrace()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;                    &lt;/span&gt;}&lt;br&gt;                    System.&lt;span style=&quot;color:#9876aa;font-style:italic;&quot;&gt;out&lt;/span&gt;.println(Thread.&lt;span style=&quot;font-style:italic;&quot;&gt;currentThread&lt;/span&gt;().getName()&lt;br&gt;                            + &lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;正在卖第：&quot; &lt;/span&gt;+ &lt;span style=&quot;color:#9876aa;font-style:italic;&quot;&gt;ticketCount&lt;/span&gt;-- + &lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;张票&quot;&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;                &lt;/span&gt;}&lt;br&gt;            } &lt;span style=&quot;color:#cc7832;&quot;&gt;finally&lt;/span&gt;{&lt;br&gt;                &lt;span style=&quot;color:#808080;&quot;&gt;//释放锁&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;                &lt;/span&gt;&lt;span style=&quot;color:#9876aa;&quot;&gt;lock&lt;/span&gt;.unlock()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;}&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p style=&quot;background-color: rgb(43, 43, 43); color: rgb(169, 183, 198); font-family: 宋体; font-size: 12pt;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;\n                                                            &lt;img src=&quot;/upload/article/20190507/78c96378157e9cbc01d46689f9fda47b.png&quot; data-filename=&quot;img&quot; style=&quot;width: 909.464px; height: 443px;&quot;&gt;&lt;/p&gt;&lt;br&gt;                            ',0,'2017-06-19 00:00:00','34',41),(152,1,'CSS3自定义滚动条样式 ','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;CSS3自定义滚动条样式 -webkit-scrollbar&lt;/p&gt;&lt;p&gt;当内容超出容器时，容器会出现滚动条，其自带的滚动条有时无法满足我们审美要求，那么我们可以通过css伪类来实现对滚动条的自定义。&lt;/p&gt;&lt;p&gt;首先我们要了解滚动条。滚动条从外观来看是由两部分组成：1，可以滑动的部分，我们叫它滑块2，滚动条的轨道，即滑块的轨道，一般来说滑块的颜色比轨道的颜色深。&lt;/p&gt;&lt;p&gt;滚动条的css样式主要有三部分组成：&lt;/p&gt;&lt;p&gt;　　1、::-webkit-scrollbar&amp;nbsp; &amp;nbsp;定义了滚动条整体的样式；&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;2、::-webkit-scrollbar-thumb&amp;nbsp; 滑块部分；&lt;/p&gt;&lt;p&gt;　&amp;nbsp; &amp;nbsp;3、::-webkit-scrollbar-thumb&amp;nbsp; 轨道部分；&lt;/p&gt;&lt;p&gt;下面以overflow-y:auto;为例（overflow-x:auto同）&lt;/p&gt;&lt;p&gt;html代码：&lt;/p&gt;&lt;pre&gt;&amp;lt;div class=&quot;test test-1&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;scrollbar&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;br&gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;&lt;p&gt;css:&lt;/p&gt;&lt;pre&gt;.test{&lt;br&gt;&amp;nbsp; &amp;nbsp; width: 50px;&lt;br&gt;&amp;nbsp; &amp;nbsp; height: 200px;&lt;br&gt;&amp;nbsp; &amp;nbsp; overflow: auto;&lt;br&gt;&amp;nbsp; &amp;nbsp; float: left;&lt;br&gt;&amp;nbsp; &amp;nbsp; margin: 5px;&lt;br&gt;&amp;nbsp; &amp;nbsp; border: none;&lt;br&gt;}&lt;br&gt;.scrollbar{&lt;br&gt;&amp;nbsp; &amp;nbsp; width: 30px;&lt;br&gt;&amp;nbsp; &amp;nbsp; height: 300px;&lt;br&gt;&amp;nbsp; &amp;nbsp; margin: 0 auto;&lt;br&gt;&amp;nbsp;&lt;br&gt;}&lt;br&gt;.test-1::-webkit-scrollbar {/*滚动条整体样式*/&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; width: 10px;&amp;nbsp; &amp;nbsp; &amp;nbsp;/*高宽分别对应横竖滚动条的尺寸*/&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; height: 1px;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;.test-1::-webkit-scrollbar-thumb {/*滚动条里面小方块*/&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; border-radius: 10px;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;-webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.2);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; background: #535353;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;.test-1::-webkit-scrollbar-track {/*滚动条里面轨道*/&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; -webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.2);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; border-radius: 10px;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; background: #EDEDED;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;/pre&gt;&lt;p&gt;效果图：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190507/eaf439d97ba2bf9f9197d0d2564297f0.png&quot; data-filename=&quot;img&quot; style=&quot;width: 89px;&quot;&gt;&lt;/p&gt;&lt;p&gt;此外，滚动条的滑块不仅可以填充颜色还可以填充图片如下：&lt;/p&gt;&lt;p&gt;html代码：&lt;/p&gt;&lt;pre&gt;&amp;lt;div class=&quot;test test-5&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;scrollbar&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;br&gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;&lt;p&gt;css代码：&lt;/p&gt;&lt;pre&gt;.test-5::-webkit-scrollbar {/*滚动条整体样式*/&lt;br&gt;&amp;nbsp; &amp;nbsp; width: 10px;&amp;nbsp; &amp;nbsp; &amp;nbsp;/*高宽分别对应横竖滚动条的尺寸*/&lt;br&gt;&amp;nbsp; &amp;nbsp; height: 1px;&lt;br&gt;}&lt;br&gt;.test-5::-webkit-scrollbar-thumb {/*滚动条里面小方块*/&lt;br&gt;&amp;nbsp; &amp;nbsp; border-radius: 10px;&lt;br&gt;    background-color: #F90;&lt;br&gt;    background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);&lt;br&gt;}&lt;br&gt;.test-5::-webkit-scrollbar-track {/*滚动条里面轨道*/&lt;br&gt;&amp;nbsp; &amp;nbsp; -webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.2);&lt;br&gt;&amp;nbsp; &amp;nbsp; /*border-radius: 10px;*/&lt;br&gt;&amp;nbsp; &amp;nbsp; background: #EDEDED;&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;效果如下：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190507/949c40207e23b305d322a717e70d76d3.png&quot; data-filename=&quot;img&quot; style=&quot;width: 71px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;',0,'2019-05-07 00:00:00','21',145),(153,1,'Java中equals和==的区别','','&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;一、java当中的数据类型和“==”的含义：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;基本数据类型（也称原始数据类型） ：byte,short,char,int,long,float,double,boolean。他们之间的比较，应用双等号（==）,比较的是他们的值。&lt;/div&gt;&lt;div&gt;引用数据类型：当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址（确切的说，是堆内存地址）。&lt;/div&gt;&lt;div&gt;注：对于第二种类型，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。因为每new一次，都会重新开辟堆内存空间。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;二、equals()方法介绍：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;JAVA当中所有的类都是继承于Object这个超类的，在Object类中定义了一个equals的方法，equals的源码是这样写的：&lt;/div&gt;&lt;pre&gt;public boolean equals(Object obj) {&lt;br&gt;&amp;nbsp; &amp;nbsp; //this - s1&lt;br&gt;&amp;nbsp; &amp;nbsp; //obj - s2&lt;br&gt;&amp;nbsp; &amp;nbsp; return (this == obj);&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;可以看到，这个方法的初始默认行为是比较对象的内存地址值，一般来说，意义不大。所以，在一些类库当中这个方法被重写了，如String、Integer、Date。在这些类当中equals有其自身的实现（一般都是用来比较对象的成员变量值是否相同），而不再是比较类在堆内存中的存放地址了。&amp;nbsp;&lt;/div&gt;&lt;div&gt;所以说，对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是内存中的存放位置的地址值，跟双等号（==）的结果相同；如果被复写，按照复写的要求来。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;我们对上面的两段内容做个总结吧：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;== 的作用：&lt;/div&gt;&lt;div&gt;　　基本类型：比较的就是值是否相同&lt;/div&gt;&lt;div&gt;　　引用类型：比较的就是地址值是否相同&lt;/div&gt;&lt;div&gt;equals 的作用:&lt;/div&gt;&lt;div&gt;　　引用类型：默认情况下，比较的是地址值。(&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;对于特殊的数据类型，单纯的比较地址值是没有意义的，比如说字符串，就算地址值不一样，只要它们的内容相同就认为它们是相等的&lt;/span&gt;)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;三、String类的equals()方法：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;现在我们拿String类来举例：&lt;/div&gt;&lt;div&gt;我们去\\src\\java\\lang目录中找到String类，发现equals方法被重写如下：&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;public boolean equals(Object anObject) {&lt;br&gt;&amp;nbsp; &amp;nbsp; //为了提高效率：如果两个内存地址相等，那么一定是指向同一个对内存中的对象，就无需比较两个对象的属性值&lt;br&gt;&amp;nbsp; &amp;nbsp; if (this == anObject) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return true;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; //为了提供程序的健壮性&lt;br&gt;&amp;nbsp; &amp;nbsp; //我先判断一下，obj是不是String类一个对象，如果是，再做向下转型，如果不是，直接返回false。&lt;br&gt;&amp;nbsp; &amp;nbsp; //这个时候，我们要判断的是对象是否是某个类的对象?&lt;br&gt;&amp;nbsp; &amp;nbsp; //记住一个格式：对象名 instanceof 类名。表示：判断该对象是否是该类的一个对象&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; if (anObject instanceof String) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; String anotherString = (String)anObject;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int n = value.length;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (n == anotherString.value.length) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; char v1[] = value;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; char v2[] = anotherString.value;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int i = 0;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; while (n-- != 0) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (v1[i] != v2[i])&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return false;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; i++;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return true;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; return false;&lt;br&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;上述代码可以看出，String类中被复写的equals()方法其实是比较两个字符串的内容。下面我们通过实际代码来看看String类的比较。&lt;/div&gt;&lt;div&gt;1、举例代码如下：&lt;/div&gt;&lt;div&gt;&lt;pre&gt;public class StringDemo {&lt;br&gt;&amp;nbsp; &amp;nbsp; public static void main(String[] args) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; String s1 = &quot;Hello&quot;;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; String s2 = &quot;Hello&quot;;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println(s1 == s2);&amp;nbsp; &amp;nbsp;// true&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;上方代码中，用“==”比较s1和s2，返回的结果是true。&lt;/p&gt;&lt;p&gt;2、稍微改动一下程序，会有奇怪的发现：&lt;/p&gt;&lt;pre&gt;public class StringDemo {&lt;br&gt;&amp;nbsp; &amp;nbsp; public static void main(String args[]) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; String str1 = &quot;Hello&quot;;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; String str2 = new String(&quot;Hello&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; String str3 = str2; // 引用传递&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println(str1 == str2); // false&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println(str1 == str3); // false&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println(str2 == str3); // true&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println(str1.equals(str2)); // true&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println(str1.equals(str3)); // true&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println(str2.equals(str3)); // true&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;上方第4行代码中，我们new了一个对象，用“==”比较s1和s2，返回的结果却是false；而用用“equals”比较s1和s2，返回的结果是true。&amp;nbsp;&lt;/p&gt;&lt;p&gt;为了分析上面的代码，我们必须首先分析堆内存空间和栈内存空间，这一点非常重要：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190507/721b250d88b23564701f02e4412fd0cf.png&quot; data-filename=&quot;img&quot; style=&quot;width: 685px;&quot;&gt;&lt;/p&gt;&lt;p&gt;看完上面的图，再结合上面的代码，就一目了然了。现在我们可以给自己出一道面试题：&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;面试题：请解释字符串比较之中“==”和equals()的区别？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&amp;nbsp;==：比较的是两个字符串内存地址（堆内存）的数值是否相等，属于数值比较；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&amp;nbsp;equals()：比较的是两个字符串的内容，属于内容比较。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;以后进行字符串相等判断的时候都使用equals()。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3、再次更改程序：&lt;/p&gt;&lt;pre&gt;public class ObjectDemo{&lt;br&gt;&amp;nbsp; &amp;nbsp; public static void main(String[] args) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; String s1 = &quot;Hello&quot;;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; String s2 = new String(&quot;Hello&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; s2 = s2.intern();&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println(s1 == s2);&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;//&amp;nbsp; true&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println(s1.equals(s2));&amp;nbsp; //&amp;nbsp; true&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;上述代码的第5行中，java.lang.String的intern()方法&quot;abc&quot;.intern()方法的返回值还是字符串&quot;abc&quot;，表面上看起来好像这个方法没什么用处。但实际上，它做了个小动作：检查字符串池里是否存在&quot;abc&quot;这么一个字符串，如果存在，就返回池里的字符串；如果不存在，该方法会 把&quot;abc&quot;添加到字符串池中，然后再返回它的引用。&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;\n                                                            ',0,'2017-12-21 00:00:00','34',43),(154,1,'分布式系统数据一致性的解决方案','','&lt;div&gt;分布式系统数据一致性的解决方案&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;随着互联网的发展，计算机系统规模变得越来越大，常规的将所有业务单元集中部署在一个或者若干个大型机上的集中式架构，已经越来越不能满足当今大型互联网系统的快速发展。分布式服务架构以及微服务架构已经越来越受到业界的青睐。而在目前的应用系统中，不管是集中式的部署架构还是分布式的系统架构，数据的一致性是每个应用系统都需要面临的问题。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在传统的集中式部署的系统中，应用一般不存在横跨多数据库的情况，借助关系型数据库自带的事务管理机制，关系型数据库具有ACID特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），保证数据一致性是比较容易的。而在分布式系统中，一个普通的业务功能，内部可能需要调用部署在多个服务器上的服务，并操作多个数据库或分片来实现，情况往往会复杂很多。保证数据一致性也变得更加艰难，再通过传统的关系型数据库的事务机制等单一的技术手段和解决方案，已经无法应对和满足这些复杂的场景了。当然这些问题单纯依靠特定的开源框架和组件并不能解决，更多的还是需要根据自己的业务场景，选择合适的解决方案。本文笔者将给大家介绍几种业界比较常用的解决数据一致性的实现方案，希望可以起到一个抛砖引玉的作用。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;一．CAP理论和BASE理论&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、CAP理论&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;谈及分布式系统，就不能不提到CAP理论，CAP理论由Berkeley的计算机教授Eric Brewer在2000年提出，其核心思想是任何基于网络的数据共享系统最多只能满足数据一致性(Consistency)、可用性(Availability)和网络分区容忍(Partition Tolerance)三个特性中的两个，三个特性的定义如下：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;一致性（Consistency）&lt;/b&gt;：一致性，这个和数据库ACID的一致性类似，但这里关注的是所有数据节点上的数据一致性和正确性，而数据库的ACID关注的是在一个事务内，对数据的一些约束。系统在执行过某项操作后仍然处于一致的状态。在分布式系统中，更新操作执行成功后所有的用户都应该读取到最新值。&lt;/div&gt;&lt;div&gt;&lt;b&gt;可用性（Availability）：&lt;/b&gt;每一个操作总是能够在一定时间内返回结果。需要注意&quot;一定时间&quot;和&quot;返回结果&quot;。&quot;一定时间&quot;是指，系统结果必须在给定时间内返回。&quot;返回结果&quot;是指系统返回操作成功或失败的结果。&lt;/div&gt;&lt;div&gt;&lt;b&gt;分区容忍性（Partition Tolerance）：&lt;/b&gt;是否可以对数据进行分区。这是考虑到性能和可伸缩性。&lt;/div&gt;&lt;div&gt;在分布式系统中，同时满足&quot;CAP定律&quot;中的&quot;一致性&quot;、&quot;可用性&quot;和&quot;分区容错性&quot;三者是不可能的。在互联网应用的绝大多数的场景，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证&quot;最终一致性&quot;，只要这个最终时间是在用户可以接受的范围内即可。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;2、BASE理论&lt;/p&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果， 是基于CAP定理逐步演化而来的。BASE理论的核心思想是：&lt;span style=&quot;font-weight: 700;&quot;&gt;即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性&lt;/span&gt;。接下来看一下BASE中的三要素：&lt;/p&gt;&lt;ul style=&quot;color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;&lt;li&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;基本可用:&lt;/span&gt;&amp;nbsp;基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。注意，这绝不等价于系统不可用。&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;软状态：&lt;/span&gt;&amp;nbsp;软状态是指允许系统存在中间状态，并且该中间状态不会影响系统整体可用性。即允许系统在不同节点间副本同步的时候存在延时。&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;最终一致性：&lt;/span&gt;系统中的所有数据副本经过一定时间后，最终能够达到一致的状态，不需要实时保证系统数据的强一致性。最终一致性是弱一致性的一种特殊情况。&lt;/li&gt;&lt;/ul&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，&lt;span style=&quot;font-weight: 700;&quot;&gt;它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态&lt;/span&gt;。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。&lt;/p&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;根据CAP理论和BASE理论，在分布式系统中，我们无法找到一种能够满足分布式系统所有系统属性的一致性解决方案，如果不想牺牲一致性，我们只能放弃可用性，这显然不能接受。因此，为了保证数据的一致性同时又不影响系统运行的性能，许多分布式系统采用弱一致性来提高性能，一些不同的一致性模型也相继被提出：&lt;/p&gt;&lt;ul style=&quot;color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;&lt;li&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;强一致性:&lt;/span&gt;&amp;nbsp;当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;弱一致性：&lt;/span&gt;&amp;nbsp;系统并不保证跨进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;最终一致性：&lt;/span&gt;弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS 是一个典型的最终一致性系统。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;&lt;b&gt;数据一致性的几种解决方案&lt;/b&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;1、分布式事务&lt;/p&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;要想理解分布式事务，我们需要先介绍一下两阶段提交协议。&lt;/p&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;两阶段提交协议（Two-phase Commit，2PC）经常被用来实现分布式事务。一般分为协调器和若干事务执行者两种角色。这里的事务执行者就是具体的数据库，抽象点可以说是可以控制给数据库的程序。 协调器可以和事务执行器在一台机器上。&lt;/p&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;在分布式系统中，每个节点虽然可以知晓自己的操作的成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)。&lt;/p&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;&lt;img src=&quot;/upload/article/20190509/07c03d0cea38bc9ed3fa1fdbb4af9f92.png&quot; data-filename=&quot;img&quot; style=&quot;width: 536px;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;两阶段提交协议在主流开发语言平台，数据库产品中都有广泛应用和实现：&lt;/p&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;1、在Java平台下，WebLogic、Webshare等主流商用的应用服务器提供了JTA的实现和支持。&lt;/p&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;2、在Windows .NET平台中，则可以借助ado.net中的TransactionScop&amp;nbsp;API来编程实现，还必须配置和借助Windows操作系统中的MSDTC服务。&lt;/p&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;总结：&lt;/span&gt;这种实现方式实现比较简单，比较适合传统的单体应用，在同一个方法中存在跨数据库操作的情况。但是因为两阶段的提交会创建多次节点的网络通信，通信时间变长后，事务的时间也相对变长，锁定的资源时间也变长，造成资源等待时间也变长，这会带来严重的性能问题，因此大部分高并发服务往往都避免使用二阶段提交协议，所以后来业界又引入了三阶段提交协议来解决该类问题。&lt;/p&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;2、非事务型消息队列+本地消息表&lt;/p&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;此方案关键是要有个本地消息表，基本思路就是：&lt;/p&gt;&lt;ol style=&quot;color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;&lt;li&gt;消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交。&lt;/li&gt;&lt;li&gt;消息消费方：处理消息并完成自己的业务逻辑。此时如果本地事务处理成功，那发送给生产方一个confirm消息，表明已经处理成功了。如果处理失败，则将消息放回MQ。&lt;/li&gt;&lt;li&gt;生产方定时扫描本地消息表，把还没处理完成的消息重新发送一遍，直到本地消息表中记录的该消息为已成功状态。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190509/4ed11209422a66652f68439e4e4dfa24.png&quot; data-filename=&quot;img&quot; style=&quot;width: 639px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;通过上图可以看出，消费方会面临一个问题就是，当消费方完成本地事务处理，给生产方发送CONFIRM消息失败时，生产方由于本地消息表的消息状态没有更新，会进行重试，那么这时候就存在了消息重复投递的问题，这时候消费方收到重复投递过来的消息后，要保证消费者调用业务的服务接口的幂等性，即：如果重复消费，也不能因此影响业务结果，同一消息多次被执行会得到相同的结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: 700; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;总结&lt;/span&gt;&lt;span style=&quot;color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;：这种方式的根本原理就是：将分布式事务转换为多个本地事务，然后依靠重试等方式达到最终一致性。这种方式比较常见。如果MQ自身和业务都具有高可用性，理论上是可以满足大部分的业务场景的。但是由于可能存在的长时间处于中间状态，不建议交易类业务直接使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190509/e550e110c38b3a8e371b7a6a07201d66.png&quot; data-filename=&quot;img&quot; style=&quot;width: 550px;&quot;&gt;&lt;span style=&quot;color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;总结&lt;/span&gt;：目前各大知名的电商平台和互联网公司，几乎都是采用类似的设计思路来实现&quot;最终一致性&quot;的。这种方式适合的业务场景广泛，而且比较可靠。不过这种方式技术实现的难度比较大。目前主流的开源MQ（ActiveMQ、RabbitMQ、Kafka）均未实现对事务消息的支持，所以需二次开发。&lt;/p&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;后记：&amp;nbsp;&lt;/span&gt;上述所介绍的几种方案，笔者也只是大致总结了其基本设计思路，这几种方案只是众多解决数据一致性的方案中比较经典的几种。在如今越来越复杂的分布式系统架构下，数据的一致性，并不是说简单的引入某个中间件能够解决的，最终一致性并没有一个放之四海而皆准的成功实践。更多的还是根据业务场景、业务特性以及业务不同的发展阶段，选择合适的方式来灵活应对。&lt;/p&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;摘要：&lt;a href=&quot;https://toutiao.io/posts/jyloiw/preview&quot; target=&quot;_blank&quot;&gt;https://toutiao.io/posts/jyloiw/preview&lt;/a&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.7em; color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(88, 102, 110); font-family: &amp;quot;PingFang SC&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Microsoft Yahei&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, Verdana, sans-serif; font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;\n                                                            ',0,'2018-06-12 00:00:00','34',60),(155,1,'搭建Java Web开发环境','','\n                                &lt;h4 id=&quot;jdk-的下载&quot; style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; font-weight: bold; color: rgb(0, 150, 136); font-size: 14px; font-family: Verdana, Arial, Helvetica, sans-serif;&quot;&gt;JDK 的下载&lt;/h4&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; font-size: 15px; line-height: 28px; color: rgb(89, 89, 89); font-family: 微软雅黑;&quot;&gt;JDK的官方下载地址在这：&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/index.html&quot;&gt;http://www.oracle.com/technetwork/java/javase/downloads/index.html&lt;/a&gt;&lt;a href=&quot;https://link.jianshu.com/?t=http://www.oracle.com/technetwork/java/javase/downloads/index.html&quot; style=&quot;margin: 0px; padding: 0px; color: rgb(0, 0, 0); text-decoration-line: underline;&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; font-size: 15px; line-height: 28px; color: rgb(89, 89, 89); font-family: 微软雅黑;&quot;&gt;&lt;img src=&quot;/upload/article/20190509/7e5f5604f0ceff6c3ad94d71aa442a15.png&quot; data-filename=&quot;img&quot; style=&quot;width: 560px;&quot;&gt;&lt;/p&gt;&lt;h4 id=&quot;jdk-的安装-1&quot; style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; font-weight: bold; color: rgb(0, 150, 136); font-size: 14px; font-family: Verdana, Arial, Helvetica, sans-serif;&quot;&gt;JDK 的安装&lt;/h4&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; font-size: 15px; line-height: 28px; color: rgb(89, 89, 89); font-family: 微软雅黑;&quot;&gt;上图就是一个JDK的下载过程，安装很简单，我就直接粘网上的图了&lt;strong style=&quot;margin: 0px; padding: 0px; color: rgb(191, 54, 12);&quot;&gt;（重要的是记住JDK安装的路径用于配置环境变量）&lt;/strong&gt;：&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; font-size: 15px; line-height: 28px; color: rgb(89, 89, 89); font-family: 微软雅黑;&quot;&gt;&lt;img src=&quot;/upload/article/20190509/b2d8950f0adea801679575d539e99492.png&quot; data-filename=&quot;img&quot; style=&quot;width: 50%;&quot;&gt;&lt;/p&gt;&lt;h4 style=&quot;font-size: 14px; font-weight: bold; margin-top: 10px; margin-right: 0px; margin-left: 0px; color: rgb(0, 0, 0); font-family: &amp;quot;black Verdana&amp;quot;, Arial, Helvetica, sans-serif;&quot;&gt;JDK环境变量的配置&lt;/h4&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; font-family: &amp;quot;black Verdana&amp;quot;, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;Java环境变量涉及到三个名词：JAVA_HOME、path、classpath。&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; font-family: &amp;quot;black Verdana&amp;quot;, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;JAVA_HOME代表JDK安装主目录，path代表JDK下可执行文件目录，classpath代表运行java程序时需要查找class文件的目录。&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; font-family: &amp;quot;black Verdana&amp;quot;, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;依据上面的安装步骤：&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; font-family: &amp;quot;black Verdana&amp;quot;, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;&lt;strong&gt;JAVA_HOME&lt;/strong&gt;应该设置为：D:\\jdk8&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; font-family: &amp;quot;black Verdana&amp;quot;, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;&lt;img src=&quot;/upload/article/20190509/29c42e22dfc999113399fd71b81a3fee.png&quot; data-filename=&quot;img&quot; style=&quot;width: 565px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; font-family: &amp;quot;black Verdana&amp;quot;, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;&lt;strong&gt;path&lt;/strong&gt;应该设置为：%JAVA_HOME%\\bin;&amp;nbsp; (开头添加，注意后面有个分号)&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; font-family: &amp;quot;black Verdana&amp;quot;, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;&lt;img src=&quot;/upload/article/20190509/4d4c2472864f1b9fcdf5c9907e741d02.png&quot; data-filename=&quot;img&quot; style=&quot;width: 521px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; font-family: &amp;quot;black Verdana&amp;quot;, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;&lt;strong&gt;classpath&lt;/strong&gt;应该设置为：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;&lt;strong&gt;（注意最前面的点代表当前路径，&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;JDK1.5之后这项不用设置了&lt;/span&gt;）&lt;/strong&gt;&lt;/p&gt;&lt;h4 id=&quot;验证-jdk-是否安装成功&quot; style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; font-weight: bold; color: rgb(0, 150, 136); font-size: 14px; font-family: Verdana, Arial, Helvetica, sans-serif;&quot;&gt;&lt;br&gt;&lt;/h4&gt;&lt;h4 id=&quot;验证-jdk-是否安装成功&quot; style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; font-weight: bold; color: rgb(0, 150, 136); font-size: 14px; font-family: Verdana, Arial, Helvetica, sans-serif;&quot;&gt;验证 JDK 是否安装成功&lt;/h4&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; font-size: 15px; line-height: 28px; color: rgb(89, 89, 89); font-family: 微软雅黑;&quot;&gt;打开命令提示符，WINDOWS 下的快捷键为【Win + R】，然后输入 cmd ，输入【java -version】查看是否输出正确地版本信息&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; font-size: 15px; line-height: 28px; color: rgb(89, 89, 89); font-family: 微软雅黑;&quot;&gt;&lt;img src=&quot;/upload/article/20190509/b9e76b10a113047b03de963164c592b1.png&quot; data-filename=&quot;img&quot; style=&quot;width: 589px;&quot;&gt;&lt;/p&gt;&lt;h3 style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto;&quot;&gt;&lt;font face=&quot;black Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/h3&gt;&lt;h3 style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto;&quot;&gt;&lt;font face=&quot;black Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;&lt;b&gt;安装Tomcat服务器&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/h3&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto;&quot;&gt;&lt;font face=&quot;black Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;下载&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto;&quot;&gt;&lt;font face=&quot;black Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;Tomcat 的官方网站是：http://tomcat.apache.org/ 你可以去官网下载最新的版本&amp;nbsp; &amp;nbsp;（下载后解压压缩包文件）&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;h4 style=&quot;font-size: 14px; margin-top: 10px; margin-right: 0px; margin-left: 0px; color: rgb(0, 0, 0); font-family: &amp;quot;black Verdana&amp;quot;, Arial, Helvetica, sans-serif;&quot;&gt;配置环境变量&amp;nbsp; &amp;nbsp;新建变量&lt;span style=&quot;font-weight: bold;&quot;&gt;&amp;nbsp;：CATALINA_HOME&lt;/span&gt;&lt;/h4&gt;&lt;h4 style=&quot;font-size: 14px; margin-top: 10px; margin-right: 0px; margin-left: 0px; color: rgb(0, 0, 0); font-family: &amp;quot;black Verdana&amp;quot;, Arial, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p style=&quot;font-size: 14px; margin-top: 10px; margin-right: 0px; margin-left: 0px; color: rgb(0, 0, 0); font-family: &amp;quot;black Verdana&amp;quot;, Arial, Helvetica, sans-serif;&quot;&gt;&lt;img src=&quot;/upload/article/20190509/7d2e6d5e62937bcd90ea2d127b6c5957.png&quot; data-filename=&quot;img&quot; style=&quot;width: 735px;&quot;&gt;&lt;/p&gt;&lt;h4 style=&quot;font-size: 14px; font-weight: bold; margin-top: 10px; margin-right: 0px; margin-left: 0px; color: rgb(0, 0, 0); font-family: &amp;quot;black Verdana&amp;quot;, Arial, Helvetica, sans-serif;&quot;&gt;启动&lt;/h4&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; font-family: &amp;quot;black Verdana&amp;quot;, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;找到 D:\\apache-tomcat-8.5.5 路径下的 bin 目录中的 startup.bat 文件，双击运行，如果输出启动信息，并未输出任何异常，则 Tomcat 安装正确&lt;strong&gt;（注意，弹出的命令提示符窗口不能关闭，否则服务器将停止运行！）&lt;/strong&gt;&lt;/p&gt;&lt;h4 id=&quot;打开浏览器验证-tomcat&quot; style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; font-weight: bold; color: rgb(0, 150, 136); font-size: 14px; font-family: Verdana, Arial, Helvetica, sans-serif;&quot;&gt;打开浏览器验证 Tomcat&lt;/h4&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; font-size: 15px; line-height: 28px; color: rgb(89, 89, 89); font-family: 微软雅黑;&quot;&gt;打开浏览器，在地址栏输入地址：http://localhost:8080/ 或者 http://127.0.0.1:8080/ ，如果能够打开 Tomcat 配置页面，则说明 Tomcat 配置成功：&lt;/p&gt;&lt;h4 id=&quot;在-tomcat-中新建-web-工程&quot; style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; font-weight: bold; color: rgb(0, 150, 136); font-size: 14px; font-family: Verdana, Arial, Helvetica, sans-serif;&quot;&gt;在 Tomcat 中新建 Web 工程&lt;/h4&gt;&lt;p style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; font-weight: bold; color: rgb(0, 150, 136); font-size: 14px; font-family: Verdana, Arial, Helvetica, sans-serif;&quot;&gt;步骤：&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; padding: 0px;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-weight: 700; color: rgb(99, 99, 99);&quot;&gt;① 找到 Tomcat 目录下的 webapps 目录。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; padding: 0px;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-weight: 700; color: rgb(99, 99, 99);&quot;&gt;② 在 webapps 目录下新建一个目录： first_webapp。（注意 first 和 webapp 中间为下划线）&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; padding: 0px;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-weight: 700; color: rgb(99, 99, 99);&quot;&gt;③ 在 first_webapp 中建立一个目录： WEB-INF。（注意大小写，WEB 和 INF 之间为横线）&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; padding: 0px;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-weight: 700; color: rgb(99, 99, 99);&quot;&gt;④ 在WEB-INF 目录中新建web.xml 文件。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; padding: 0px;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-weight: 700; color: rgb(99, 99, 99);&quot;&gt;⑤ 将提供的 index.html 文件复制到 first_webapp 目录下。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; padding: 0px;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-weight: 700; color: rgb(99, 99, 99);&quot;&gt;⑥ 启动 Tomcat。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; padding: 0px;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-weight: 700; color: rgb(99, 99, 99);&quot;&gt;⑦ 在浏览器中输入网址：http://localhose:8080/first_webapp ，查看是否能够正确访问，如果可以正确显示页面，则表示 Tomcat 中创建新项目成功。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; padding: 0px;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-weight: 700; color: rgb(99, 99, 99);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; padding: 0px;&quot;&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: rgb(99, 99, 99);&quot;&gt;tomcat下配置虚拟主机 域名&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; padding: 0px;&quot;&gt;&lt;font color=&quot;#636363&quot; face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;配置路径：apache-tomcat-8.5\\conf\\server.xml&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;\n                                                                                        ',0,'2016-02-02 00:00:00','34',19),(156,1,'使用IntelliJ IDEA开发java web的配置步骤','','\n                                \n                                &lt;p&gt;&lt;b&gt;一、配之前准备&lt;/b&gt;&lt;/p&gt;&lt;p&gt;首先下载安装 IntelliJ IDEA&amp;nbsp; 和安装tomcat应用服务器&lt;/p&gt;&lt;p&gt;1.安装IntelliJ IDEA&lt;/p&gt;&lt;p&gt;官网的下载地址： http://www.jetbrains.com/idea/download/ ，支持mac/windows/linux三大主流平台，我用的是windows版本。&lt;/p&gt;&lt;p&gt;注：IntelliJ IDEA是商业软件，有二个版本，&lt;/p&gt;&lt;p&gt;Ultimate Edition是商业版本，功能完善，可以免费试用30天，建议下载该版本学习；（可以找破解方法，免费永久使用）&lt;/p&gt;&lt;p&gt;2.Tomcat 的下载安装及配置&lt;/p&gt;&lt;p&gt;官网的下载地址：http://tomcat.apache.org/&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;二、在itelliji idea上创建web项目&lt;/b&gt;&lt;/p&gt;&lt;p&gt;1.File -&amp;gt; New Project ，进入创建项目窗口&lt;/p&gt;&lt;p&gt;注：在IntelliJ IDEA里面“new Project” 就相当于eclipse里的“workspace”，而“new Module”才是创建一个工程。这个和Eclipse有很大的区别&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190512/55ba8ac815c5a20bcaf6e0c343044d86.png&quot; data-filename=&quot;img&quot; style=&quot;width: 816px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190512/52444bc54e119a9867098f588a9c3b26.png&quot; data-filename=&quot;img&quot; style=&quot;width: 810px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190512/1cb0a391339f546d62b7c059b51250c2.png&quot; data-filename=&quot;img&quot; style=&quot;width: 842px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;2、在 WEB-INF 目录下点击右键，New -&amp;gt; Directory，创建 classes 和 lib 两个目录&amp;nbsp; （注：classes用于存放编译后的java字节码，lib存放引用的jar包。）&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190512/26d4f67cfb6636679b524bf371bcb229.png&quot; data-filename=&quot;img&quot; style=&quot;width: 426px;&quot;&gt;&lt;/p&gt;&lt;p&gt;3、File -&amp;gt; Project Structure，进入 Project Structure窗口，点击 Modules -&amp;gt; 选中项目“JavaWeb1” -&amp;gt; 切换到 Paths 选项卡 -&amp;gt; 勾选 “Use module compile output path”，将 “Output path” 和 “Test output path” 都改为之前创建的classes目录&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190512/d0dd2bd2c6c1d22618d3ffabf5c7151b.png&quot; data-filename=&quot;img&quot; style=&quot;width: 1029px;&quot;&gt;&lt;/p&gt;&lt;p&gt;4.点击 Modules -&amp;gt; 选中项目“JavaWeb1” -&amp;gt; 切换到 Dependencies 选项卡 -&amp;gt; 点击右边的“+”，选择 “JARs or directories”&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190512/867c78aecbe7bdfba98723f9f2d00de3.png&quot; data-filename=&quot;img&quot; style=&quot;width: 50%;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;strong style=&quot;margin: 0px; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;注：&lt;/strong&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;Java Web项目是需要依赖 上图看到的 JDK 与 Tomcat包（Servlet模块就在里面）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190512/4834cb254a6e0db390664d9138a0ee65.png&quot; data-filename=&quot;img&quot; style=&quot;width: 635px;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190512/3c1546ef10269b6bc5996bc944746eff.png&quot; data-filename=&quot;img&quot; style=&quot;width: 477px;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190512/3be75ba1a138776eda397cedc8b13bc4.png&quot; data-filename=&quot;img&quot; style=&quot;width: 1024px;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;5.配置打包方式Artifacts：点击&amp;nbsp;Artifacts选项卡，IDEA会为该项目自动创建一个名为“JavaWeb:war exploded”的打包方式，表示 打包成war包，并且是文件展开性的，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;输出路径为当前项目下的 out 文件夹，保持默认即可。另外勾选下“Build on make”，表示编译的时候就打包部署，勾选“Show content of elements”，表示显示详细的内容列表。&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190512/c214b9693f2e05493500aa7fb38f6aa8.png&quot; data-filename=&quot;img&quot; style=&quot;width: 1007px;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;&lt;strong style=&quot;margin: 0px; padding: 0px;&quot;&gt;三、配置 Tomcat&lt;/strong&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;1、Run -&amp;gt; Edit Configurations，进入“Run Configurations”窗口，在“Server”选项板中，去掉勾选“After launch”，设置“HTTP port”和“JMX port”，点击 Apply -&amp;gt; OK，至此Tomcat配置完成。&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;&lt;img src=&quot;/upload/article/20190512/ec5ed8dcdd9dbf15378fea631fdf7946.png&quot; data-filename=&quot;img&quot; style=&quot;width: 1080px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;点击“Deployment”选项卡，修改“Application context”-&amp;gt; Apply -&amp;gt; OK&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong style=&quot;margin: 0px; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;&lt;strong style=&quot;margin: 0px; padding: 0px;&quot;&gt;四、在 Tomcat中运行项目&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190512/ee575072de2077beba5c0495ffb9884c.png&quot; data-filename=&quot;img&quot; style=&quot;width: 50%;&quot;&gt;&lt;strong style=&quot;margin: 0px; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;&lt;strong style=&quot;margin: 0px; padding: 0px;&quot;&gt;&lt;br&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190510/c7b2d673319e4535930fd51dd661f1b4.png&quot; data-filename=&quot;img&quot; style=&quot;width: 436px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在浏览器输入运行项目的url路径&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                                                        ',0,'2017-06-13 00:00:00','36',23),(157,1,'为什么vue项目要基于node.js开发','','\n                                \n                                &lt;div&gt;在这段时间由于公司项目需要使用vue开发做一个前后端分离，总结一下vue开发的一些疑惑:&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1.如果是单纯的使用vue作为前端开发的辅助插件库的话，那么你只需要直接&amp;lt;script&amp;gt;引用vue.js便可以实现vue的双向绑定的功能；&lt;/div&gt;&lt;div&gt;但是如果要用vue开发一个大型项目，这个时候我门就需要vue-cli脚手架来开发了，这也是为什么开发vue项目需要安装node.js的原因之一，使用node.js我们可以很方便的通过命令 npm/cnpm install -g vue-cli快速的搭建一个vue项目的一个基本目录框架。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.本地开发时，把vue运行在node.js服务器上，其实只是在模拟线上真实的环境效果，方便开发调式。vue开发的是前端的东西，不是nodejs 服务端程序，按道理讲，生产环境里就不该存在npm，甚至nodejs也不需要，一般我们在本地开发完后，需要使用webpacke打包（基于node.js的工具），把vue-cli下的文件编译成浏览器能够识别的js\\css\\html文件（vue-cli里面有很多的node.js语法，还有每个组件都是.vue的文件形式存在），&amp;nbsp; 所以这个也是需要node.js的原因之一。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.通过npm run build 生成的dist文件夹里的内容，这些内容根本与node.js毫无关系，所以生产环境也不需要安装什么node.js。里面的东西就是我们之前传统的web开发需要的普通文件js\\css\\html,再把这些内容放在web服务器如：apache 、 nginx的项目目录下&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;总结：开发vue项目需要安装node.js的原因其实就是为了本地快速开发，方便下载一些项目所需的依赖包以及在本地模拟线上服务器的效果方便开发调试仅此而已。生产环境根本不需要安装什么node.js 、webpacke、npm 等等这些基于node的工具&lt;/div&gt;\n                                                                                                                    ',0,'2019-02-04 00:00:00','22',140),(158,1,'Maven安装与配置以及在intelliji idea创建web项目','','\n                                \n                                \n                                \n                                \n                                \n                                \n                                \n                                \n                                \n                                \n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、下载maven安装包：&lt;a href=&quot;https://maven.apache.org/download.cgi&quot; target=&quot;_blank&quot;&gt;https://maven.apache.org/download.cgi&lt;/a&gt;，(下载 Binary zip archive选项的压缩包)解压即可使用。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、maven环境变量配置，配置方式跟tomcat有些类似。新建环境变量M2_HOME（值为maven的根目录）、然后在PATH环境变量里加入%M2_HOME%\\bin; (&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;win10 系统maven后面不能加 ；号&lt;/span&gt;)即可。&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190514/971bd7878a4960eca8adfab80bd52236.png&quot; data-filename=&quot;img&quot; style=&quot;width: 602px;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;3、设置setting.xml文件，配置本地仓库。apache-maven-3.2.1\\conf下有个setting.xml文件，打开，找到localRepository的值设置成你本地仓库的路径。&lt;/div&gt;&lt;div&gt;我在maven根目录D:\\apache-maven-3.6.1下创建了个repository文件夹作为本地仓库&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190514/1cadd354f98958a3a8afe8979afc21f3.png&quot; data-filename=&quot;img&quot; style=&quot;width: 770px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;4.在IntelliJ IDEA中配置maven&amp;nbsp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;打开-File-Settings&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190515/cf2977b6e0154e16416be1623e6ae605.png&quot; data-filename=&quot;img&quot; style=&quot;width: 927.844px; height: 523px;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;maven 创建的WEB项目目录结构：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190515/5916ba1bf3d56c8c398b1fd2be8921f3.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 514px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;5.IntelliJ IDEA 使用Maven创建web项目&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190515/9657a286cd645effdf015b371c2fb0e2.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 531px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190515/6f17fc724dcf154ca45b5a6135c69707.png&quot; data-filename=&quot;img&quot; style=&quot;width: 706px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;（&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; 注：maven-archetype中 quickstart与 webapp的区别&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 1，maven-archetype-quickstart&amp;nbsp; （当需要一个后端的模块时用）&lt;br&gt;&lt;/div&gt;&lt;div&gt;默认的Archetype,基本内容包括：&lt;/div&gt;&lt;div&gt;一个包含junit依赖声明的pom.xml&lt;/div&gt;&lt;div&gt;src/main/java主代码目录及一个名为App的类&lt;/div&gt;&lt;div&gt;src/test/java测试代码目录及一个名为AppTest的测试用例&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 2，maven-archetype-webapp&amp;nbsp; （当需要创建一个web应用模块时用）&lt;/div&gt;&lt;div&gt;一个最简单的Maven war项目模板，当需要快速创建一个Web应用的时候可以使用它。生成的项目内容包括：&lt;/div&gt;&lt;div&gt;一个packaging为war且带有junit依赖声明的pom.xml&lt;/div&gt;&lt;div&gt;src/main/webapp/目录&lt;/div&gt;&lt;div&gt;src/main/webapp/index.jsp文件&lt;/div&gt;&lt;div&gt;src/main/webapp/WEB-INF/web.xml文件&lt;/div&gt;&lt;div&gt;&lt;b&gt;）&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;点击NEXT&amp;nbsp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190515/3b197a0d648aa61bac2929b1983145f9.png&quot; data-filename=&quot;img&quot; style=&quot;width: 497px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;（&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;注：GroupId 和ArtifactId 其实可以理解为当前项目在maven中的一个坐标（x,y）。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;它们的命名规则一般是：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; 1.项目要是只有一个模块&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/b&gt;&lt;b&gt;GroupId ： 域（com/cn/org）. 组织名（公司名/个人名字）&amp;nbsp; &amp;nbsp; &amp;nbsp; 比如: cn.lzc&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/b&gt;&lt;b&gt;ArtifactId :&amp;nbsp; &amp;nbsp;项目名&amp;nbsp; &amp;nbsp; 比如：&amp;nbsp;&lt;/b&gt;&lt;b&gt;mvnweb&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 2&lt;b&gt;.项目要是有多个模块&lt;/b&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/b&gt;&lt;b&gt;GroupId ： 域（com/cn/org）. 组织名（公司名/个人名字）.项目名&amp;nbsp; &amp;nbsp; &amp;nbsp; 比如: cn.lzc.mvnproject&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/b&gt;&lt;b&gt;ArtifactId :&amp;nbsp; &amp;nbsp;项目名-模块名&amp;nbsp; &amp;nbsp; 比如：&amp;nbsp;&lt;/b&gt;&lt;b&gt;mvnproject&lt;/b&gt;&lt;b&gt;-service&amp;nbsp; &amp;nbsp;、&lt;/b&gt;&lt;b&gt;&amp;nbsp;&lt;/b&gt;&lt;b&gt;mvnproject&lt;/b&gt;&lt;b&gt;-dao&amp;nbsp; 、&amp;nbsp;&lt;/b&gt;&lt;b&gt;&amp;nbsp;&lt;/b&gt;&lt;b&gt;mvnproject&lt;/b&gt;&lt;b&gt;-api&amp;nbsp;&lt;/b&gt;&lt;b&gt;&amp;nbsp;、&lt;/b&gt;&lt;b&gt;mvnproject-webapp&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;）&lt;br&gt;&lt;/b&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;点击NEXT&amp;nbsp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;img src=&quot;/upload/article/20190515/dba4be1a603bebc95e6e113ffa4e6dd0.png&quot; data-filename=&quot;img&quot; style=&quot;width: 905px; height: 236.939px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;点击NEXT&amp;nbsp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190515/1ebe892bc0afc037eab4823b61a3e359.png&quot; data-filename=&quot;img&quot; style=&quot;width: 578px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;点击Finish&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190515/9e37c486420a081e3b47adf9bae4d190.png&quot; data-filename=&quot;img&quot; style=&quot;width: 395px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;导入完成后的项目目录结构如下：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190515/d13556f916056068f1924c9f8c450690.png&quot; data-filename=&quot;img&quot; style=&quot;width: 309px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;接下来创建Tomcat运行这个web项目&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190515/74746917eeb0a02e84a97a559c402986.png&quot; data-filename=&quot;img&quot; style=&quot;width: 341px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190515/23d6bf9e6fcfaa97d7401d21cdf3bb48.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 606px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190516/cca8cbd41af1cb315f1111d9e2101b6c.png&quot; data-filename=&quot;img&quot; style=&quot;width: 794.28px; height: 216.063px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190516/1902ddad5afebc627e05c01d4cd45cf0.png&quot; data-filename=&quot;img&quot; style=&quot;width: 890.077px; height: 189px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190516/c59b1c2665a28df3fd81b28c30af478f.png&quot; data-filename=&quot;img&quot; style=&quot;width: 441px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190516/1feed761a76f35c1b9c2a5cd9453a5a4.png&quot; data-filename=&quot;img&quot; style=&quot;width: 341px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190516/d7b260b657f8a5255dee31397933ca13.png&quot; data-filename=&quot;img&quot; style=&quot;width: 436px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;点击OK&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190516/5917635cde05fef9807084a8274038ba.png&quot; data-filename=&quot;img&quot; style=&quot;width: 592px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;点击NEXT,直至Finish完成&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;然后继续添加Artifacts&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190516/daf0dd680a6dab8dcd593edac38e2cbd.png&quot; data-filename=&quot;img&quot; style=&quot;width: 541px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;点击OK完成&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;然后在回到Tomcat配置界面&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190516/4e0d3c820b2dabdc0f308727889f87cd.png&quot; data-filename=&quot;img&quot; style=&quot;width: 848px; height: 177.364px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190516/7b9e9e68d89310d0f2d9a001f83c0be8.png&quot; data-filename=&quot;img&quot; style=&quot;width: 723px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;自此配置完成，可以运行刚刚配置的tomcat，浏览器 &lt;a href=&quot;http://localhost:8080/mvnwebsite/&quot;&gt;http://localhost:8080/mvnwebsite/&lt;/a&gt;&amp;nbsp; &amp;nbsp;会显示hello world&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;b&gt;参考：&lt;/b&gt;&lt;a href=&quot;https://blog.csdn.net/qq_27093465/article/details/63683873&quot;&gt;https://blog.csdn.net/qq_27093465/article/details/63683873&lt;/a&gt;&lt;a href=&quot;https://blog.csdn.net/qq_27093465/article/details/63683873&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;a href=&quot;https://www.cnblogs.com/lindp/p/4484390.html&quot;&gt;https://www.cnblogs.com/lindp/p/4484390.html&lt;/a&gt;&lt;br&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;br&gt;&lt;/div&gt;\n                                                                                                                                                                                                                                                                                                                                                                                ',0,'2017-06-06 00:00:00','36',33),(159,1,'简单代码实现点击按钮显示隐藏提示框','','\n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br&gt;&amp;lt;html&amp;gt;&lt;br&gt;&amp;lt;head&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;title&amp;gt;提示弹窗&amp;lt;/title&amp;gt;&lt;br&gt;&amp;lt;/head&amp;gt;&lt;br&gt;&amp;lt;style type=&quot;text/css&quot;&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;.model-box{display:none;}&lt;br&gt;&amp;lt;/style&amp;gt;&lt;br&gt;&amp;lt;body&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;div&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;lt;button class=&quot;btn&quot;&amp;gt;点击&amp;lt;/button&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;lt;div class=&quot;model-box&quot;&amp;gt;提示内容&amp;lt;/div&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;/div&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;div&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;lt;button class=&quot;btn&quot;&amp;gt;点击&amp;lt;/button&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;lt;div class=&quot;model-box&quot;&amp;gt;提示内容&amp;lt;/div&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;/div&amp;gt;&lt;br&gt;&amp;lt;/body&amp;gt;&lt;br&gt;&amp;lt;/html&amp;gt;&lt;br&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;br&gt;$(document).ready(function(){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;// 闭包写法，避免变量被污染&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;(function(){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;var tip_model&amp;nbsp; &amp;nbsp; = null;&amp;nbsp; //初始化弹窗&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; $(&quot;.btn&quot;).on(&quot;click&quot;,function(e){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;$(\'.model-box\').hide(); // 点击.btn时，先让所有的弹窗都隐藏&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var click_obj = $(this); //&amp;nbsp;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; tip_model&amp;nbsp; &amp;nbsp; = reference.siblings(\'.model-box\');&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var e = e || window.event;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; tip_model.show();&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; e.stopPropagation();&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; })&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; $(document).on(&quot;click&quot;,function(e){ //点击页面其它地方隐藏model,点击model区域不显示&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var e = e || window.event;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var target = $(e.target).closest(&quot;div.model-box&quot;)  // 从点击的当前元素往外找，直到找到div类为model-box的父辈。通过这个来判断是否是在model区域&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if(tip_model !==null &amp;amp;&amp;amp; !target.is(tip_model)) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; tip_model.hide();&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; })&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;})();&lt;br&gt;})&lt;br&gt;&amp;lt;/script&amp;gt;&lt;/pre&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                            ',0,'2019-04-02 00:00:00','22',113),(160,1,'JS字符串False转Boolean','','&lt;div&gt;其实这个是伪命题，也就是说在js中不管是字符串false还是字符串true转成Boolean类型，它们的结果还是true&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;1.var hasAuth = \'false\';&lt;br&gt;单纯的利用if来判断是boolean false还是true 是判断不出来的&lt;br&gt;&lt;br&gt;var hasAuth = \'true\';&lt;br&gt;if(hasAuth){ //此时的hasAuth是true&lt;br&gt;&amp;nbsp;&amp;nbsp;&lt;br&gt;}&lt;br&gt;var hasAuth = \'false\';&lt;br&gt;if(hasAuth){ //此时的hasAuth还是true&lt;br&gt;&amp;nbsp;&amp;nbsp;&lt;br&gt;}&lt;br&gt;2.用Boolean的构造方法还是一样不能判断&lt;br&gt;&amp;nbsp;Boolean(\'true\') === true;&lt;br&gt;&amp;nbsp;Boolean(\'false\') === true;&lt;br&gt;&lt;br&gt;&amp;nbsp;最终的解决办法就是利用字符串判断&lt;br&gt;&lt;br&gt;&lt;br&gt;var hasAuth = \'true\' === \'true\' ;&lt;br&gt;console.log(hasAuth);//true&lt;br&gt;&lt;br&gt;var hasAuth = \'false\' === \'true\' ;&lt;br&gt;console.log(hasAuth);//false&lt;/pre&gt;\n                                                            ',0,'2019-05-17 00:00:00','22',120),(161,1,'Tomcat jsp Servlet关系','','&lt;div&gt;Tomcat：是一个应用服务容器 它包含jsp、servlet&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;jsp ：是jsp文件中的html包含java代码&lt;/div&gt;&lt;div&gt;servlet ：是java的一个类，在java代码中输出html到客户端&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;客户单请求服务端的流程：&lt;/div&gt;&lt;div&gt;浏览器请求jsp文件时，服务端的Tomcat会把请求转发给servlet处理，此时servlet会把jsp文件转成servlet(就是.java的文件)，再编译成.class来运行。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;有了jsp，因此在MVC模式中servlet不再负责生成html页面,转而担任&amp;nbsp;&lt;/div&gt;&lt;div&gt;控制程序逻辑的作用，控制jsp和javabean之间的流转。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;Servlet与Jsp的区别&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; * Servlet中没有内置对象，原来Jsp中的内置对象都是必须通过HttpServletRequest对象，或由&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;HttpServletResponse对象生成。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; * 对于静态的HTML标签，Servlet都必须使用页面输出流诼行输出。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;总之，Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，至于Jsp中的&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;方法用于生成对客户端的响应。&amp;nbsp;&lt;/div&gt;&lt;div&gt;-Servlet的开发&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; Servlet通常称为服务器端小程序，用于处理和响应客户端的请求。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; Servlet是个特殊的Java类，这个Java类必须继承HttpServlet。每个Servlet可以响应客户端的请求。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; Servlet提供了不同的方法用于响应客户端请求。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; * doGet&amp;nbsp; &amp;nbsp;: 用于响应客户端的get请求&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; * doPost&amp;nbsp; : 用于响应客户端的post请求&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; * doPut&amp;nbsp; &amp;nbsp;: 用于响应客户端的put请求&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; * doDelete: 用于响应客户端的delete请求&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; * service(HttpServletRequest&amp;nbsp; request,&amp;nbsp; &amp;nbsp;[可以响应客户端所有类型的请求]&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;HttpServletResponse response)&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;throws ServletException,java.io.IOException&amp;nbsp;&lt;/div&gt;&lt;div&gt;其他方法&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; * init(Servletconfig config)&amp;nbsp; : 创建Servlet实例时，调用的初始化方法。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; * destory()&amp;nbsp; &amp;nbsp;: 销毁Servlet实例时，自动调用的资源回收方法。&amp;nbsp;&lt;/div&gt;&lt;div&gt;-Servlet的配置&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 编译好的Servlet源文件并不能响应用户请求，还必须将其编译成class文件。将编译后的.class&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 文件放在WEB-INF/classes路径下，如果Servlet有包，则还应该将class文件放在对应的包路径下。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 为了让Servlet能响应用户请求，还必须将Servlet配置在Web应用中。配置Servlet时，需要修改&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; web.xml文件。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;配置Servlet需要配置两个部分：&amp;nbsp; &amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; * 配置Servlet的名字：对应web.xml中的&amp;lt;servlet/&amp;gt;元素&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; * 配置Servlet的URL ：对应web.xml中的&amp;lt;servlet-mapping/&amp;gt;元素&amp;nbsp;&lt;/div&gt;&lt;div&gt;-Servlet的生命周期&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;Servlet在容器中运行，其实例的创建以及销毁等都不是由程序员决定的，而是由容器进行控制的。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;Servlet的创建有两个选择：&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;*客户端请求对应的Servlet时，创建Servlet实例：大部分的Servlet都是这种Servlet&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;*Web应用启动时，立刻创建Servlet实例：即load-on-startup Servlet&amp;nbsp;&lt;/div&gt;&lt;div&gt;Servlet的生命周期:&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;Begin&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ---&amp;gt; 创建实例完成&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ---&amp;gt; 初始化[init]&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ---&amp;gt; 响应客户端请求[doGet,doPost,service]&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ---&amp;gt; 被销毁[destroy] ---&amp;gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;End&amp;nbsp;&lt;/div&gt;&lt;div&gt;-使用Servlet作为控制器&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;使用Servlet作为表现层的工作量太大，所有的HTML标签都需要使用页面输出流生成。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;因此使用Servlet作为表现层有如下三个劣势：&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* 开发效率低，所有的HTML标签都需使用页面输出流完成&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* 不利于团队协作，美工人员无法参与Servlet界面的开发&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* 程序可维护性差，即使修改一个按钮的标题，读需要重新编辑Java代码，并重新编译&amp;nbsp;&lt;/div&gt;&lt;div&gt;使用Servlet的MVC的架构实现：&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;Jsp页面--&amp;gt; Servlet程序 --&amp;gt; Servlet根据条件转发新的Jsp页面&amp;nbsp;&lt;/div&gt;&lt;div&gt;-load-on-startup Servlet&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;Servlet实例化的时机还有在Web应用启动时，即load-on-startup Servlet&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;应用启动时就启动的Servlet，通常是用于某些后台服务的Servlet，或者拦截很多请求的Servlet；&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;这种Servlet通常作为基础的Servlet使用，提供重要的后台服务。&amp;nbsp;&lt;/div&gt;&lt;div&gt;web.xml中的配置：&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;在&amp;lt;servlet/&amp;gt;元素中增加元素&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt; load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;-访问Servlet的配置参数&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;配置Servlet时，还可以增加附加的配置参数，通过使用配置参数，可以实现更好的解除耦合，&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;避免将所有的参数以硬编码方式写在程序中。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;访问Servlet配置参数要通过ServletConfig类的实例完成，ServletConfig提供如下方法：&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;java.lang.String getInitParameter(java.lang.String name) [获取初始化参数]&amp;nbsp;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;',0,'2017-06-13 00:00:00','34',22),(162,1,'javascript拖动DIV实现跟随鼠标移动的吸附效果','','\n                                \n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;鼠标拖动DIV需要理解文中提到的偏差值，以及鼠标移动时，实时计算出DIV的坐标值公式。这样整个拖动原理也就理解了&lt;/p&gt;&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;html&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;html&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;head&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;    &amp;lt;meta &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;charset=&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;    &amp;lt;style&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;body &lt;/span&gt;{&lt;span style=&quot;color:#bababa;&quot;&gt;margin&lt;/span&gt;:&lt;span style=&quot;color:#6897bb;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;px&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;/span&gt;}&lt;br&gt;        .&lt;span style=&quot;color:#e8bf6a;&quot;&gt;box &lt;/span&gt;{&lt;br&gt;            &lt;span style=&quot;color:#bababa;&quot;&gt;position&lt;/span&gt;: &lt;span style=&quot;color:#a5c261;&quot;&gt;absolute&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;width&lt;/span&gt;: &lt;span style=&quot;color:#6897bb;&quot;&gt;200&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;px&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;height&lt;/span&gt;: &lt;span style=&quot;color:#6897bb;&quot;&gt;200&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;px&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;background&lt;/span&gt;: &lt;span style=&quot;color:#6897bb;&quot;&gt;#e6e1e1&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;box-shadow&lt;/span&gt;:&lt;span style=&quot;color:#6897bb;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;px &lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;10&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;px &lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;12&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;px &lt;/span&gt;&lt;span style=&quot;color:#6897bb;&quot;&gt;#ccc&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;}&lt;br&gt;    &lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/style&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/head&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;body &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;style=&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;height&lt;/span&gt;:&lt;span style=&quot;color:#6897bb;&quot;&gt;2000&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;px&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;div &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;class=&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;&quot;box&quot;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;    &amp;lt;div &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;id=&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;&quot;drag_bar&quot; &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;style=&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;height&lt;/span&gt;:&lt;span style=&quot;color:#6897bb;&quot;&gt;30&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;px&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;background-color&lt;/span&gt;:&lt;span style=&quot;color:#6897bb;&quot;&gt;#9f9fbf&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;cursor&lt;/span&gt;:&lt;span style=&quot;color:#a5c261;&quot;&gt;move&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/div&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;script&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;var &lt;/span&gt;box = document.&lt;span style=&quot;color:#ffc66d;&quot;&gt;getElementsByClassName&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;box&quot;&lt;/span&gt;)[&lt;span style=&quot;color:#6897bb;&quot;&gt;0&lt;/span&gt;]&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//获取元素&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;var &lt;/span&gt;drag_bar = document.&lt;span style=&quot;color:#ffc66d;&quot;&gt;getElementById&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;drag_bar&quot;&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//存储鼠标mousedown时，鼠标的坐标点X与div左边距的偏差值，同理Y与div上边距的偏差值。利用这个偏差值可以计算出div的坐标&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;var &lt;/span&gt;x&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;y&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;var &lt;/span&gt;isDrop = &lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;false&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//移动状态的判断鼠标按下才能移动&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;drag_bar.&lt;span style=&quot;color:#9876aa;&quot;&gt;onmousedown &lt;/span&gt;= &lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;function&lt;/span&gt;(e) {&lt;br&gt;        &lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;var &lt;/span&gt;e = e || window.&lt;span style=&quot;color:#9876aa;&quot;&gt;event&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//要用event这个对象来获取鼠标的位置&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        &lt;/span&gt;x = e.&lt;span style=&quot;color:#9876aa;&quot;&gt;clientX &lt;/span&gt;- box.&lt;span style=&quot;color:#9876aa;&quot;&gt;offsetLeft&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//box.offsetLeft   div距离浏览器左边的距离&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        &lt;/span&gt;y = e.&lt;span style=&quot;color:#9876aa;&quot;&gt;clientY &lt;/span&gt;- box.&lt;span style=&quot;color:#9876aa;&quot;&gt;offsetTop&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;  &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//box.offsetTop    div距离浏览器顶部的距离&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        &lt;/span&gt;isDrop = &lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;true&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//设为true表示可以移动&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;}&lt;br&gt;    document.&lt;span style=&quot;color:#9876aa;&quot;&gt;onmousemove &lt;/span&gt;= &lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;function&lt;/span&gt;(e) {&lt;br&gt;        &lt;span style=&quot;color:#808080;&quot;&gt;//是否为可移动状态                　　　　　　　　　　　 　　　　　　　&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;if&lt;/span&gt;(isDrop) {&lt;br&gt;            &lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;var &lt;/span&gt;e = e || window.&lt;span style=&quot;color:#9876aa;&quot;&gt;event&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//移动鼠标实时计算出div的坐标值，公式为：鼠标坐标 - 偏差值&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;var &lt;/span&gt;moveX = e.&lt;span style=&quot;color:#9876aa;&quot;&gt;clientX &lt;/span&gt;- x&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//得到距离左边距离                    　　&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;var &lt;/span&gt;moveY = e.&lt;span style=&quot;color:#9876aa;&quot;&gt;clientY &lt;/span&gt;- y&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//得到距离上边距离&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;            &lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;var &lt;/span&gt;maxX = document.&lt;span style=&quot;color:#9876aa;&quot;&gt;documentElement&lt;/span&gt;.&lt;span style=&quot;color:#9876aa;&quot;&gt;clientWidth &lt;/span&gt;- box.&lt;span style=&quot;color:#9876aa;&quot;&gt;offsetWidth&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//document.documentElement.clientHeight 浏览器可视区高度 &lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;var &lt;/span&gt;maxY = document.&lt;span style=&quot;color:#9876aa;&quot;&gt;documentElement&lt;/span&gt;.&lt;span style=&quot;color:#9876aa;&quot;&gt;clientHeight &lt;/span&gt;- box.&lt;span style=&quot;color:#9876aa;&quot;&gt;offsetHeight&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//考虑页面可能出现滚动条的情况，&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;            &lt;/span&gt;maxY += document.&lt;span style=&quot;color:#9876aa;&quot;&gt;documentElement&lt;/span&gt;.&lt;span style=&quot;color:#9876aa;&quot;&gt;scrollTop  &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;// 滚动条向下滚动的高度&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;            //范围限定二　&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;            &lt;/span&gt;moveX=Math.&lt;span style=&quot;color:#ffc66d;&quot;&gt;min&lt;/span&gt;(maxX&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;Math.&lt;span style=&quot;color:#ffc66d;&quot;&gt;max&lt;/span&gt;(&lt;span style=&quot;color:#6897bb;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;moveX))&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;moveY=Math.&lt;span style=&quot;color:#ffc66d;&quot;&gt;min&lt;/span&gt;(maxY&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;Math.&lt;span style=&quot;color:#ffc66d;&quot;&gt;max&lt;/span&gt;(&lt;span style=&quot;color:#6897bb;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;,&lt;/span&gt;moveY))&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;box.&lt;span style=&quot;color:#9876aa;&quot;&gt;style&lt;/span&gt;.&lt;span style=&quot;color:#9876aa;&quot;&gt;left &lt;/span&gt;= moveX + &lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;px&quot;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;box.&lt;span style=&quot;color:#9876aa;&quot;&gt;style&lt;/span&gt;.&lt;span style=&quot;color:#9876aa;&quot;&gt;top &lt;/span&gt;= moveY + &lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;px&quot;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;}&lt;br&gt;    }&lt;br&gt;    document.&lt;span style=&quot;color:#9876aa;&quot;&gt;onmouseup &lt;/span&gt;= &lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;function&lt;/span&gt;() {&lt;br&gt;        isDrop = &lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;false&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//设置为false不可移动&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;}&lt;br&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/script&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/body&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/pre&gt;                                                        ',0,'2019-05-13 00:00:00','22',165),(165,1,'Intelliji idea 选择maven 的mvaven-archetype-quickstart选项创建项目报错','','\n                                &lt;div&gt;Intelliji idea 选择maven 的mvaven-archetype-quickstart选项创建项目报错&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;[ERROR] Maven execution terminated abnormally (exit code 1)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;解决办法：&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190518/c8e13223349c2282a8814938c8b666ca.png&quot; data-filename=&quot;img&quot; style=&quot;width: 443px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190518/15132ebff7bed6133144a31845be0055.png&quot; data-filename=&quot;img&quot; style=&quot;width: 975px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190518/2871a31650a40aed6fd406e0ca8f74f1.png&quot; data-filename=&quot;img&quot; style=&quot;width: 807px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;(VM Option :&lt;b&gt; -Dmaven.multiModuleProjectDirectory=$MAVEN_HOME&lt;/b&gt; )&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190518/664607c9785c05d86961538329dc755b.png&quot; data-filename=&quot;img&quot; style=&quot;width: 712px;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;(避免联网下载)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\n                                                                                        ',0,'2017-06-19 00:00:00','36',47),(164,1,'js获取窗口滚动条高度、窗口可视范围高度、文档实际内容高度、滚动条离浏览器底部的高度','','&lt;p&gt;\n                                &lt;/p&gt;&lt;p&gt;1.获取窗口可视范围的高度&lt;/p&gt;&lt;pre&gt;//获取窗口可视范围的高度&lt;br&gt;function getClientHeight(){&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; var clientHeight=0;&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; if(document.body.clientHeight&amp;amp;&amp;amp;document.documentElement.clientHeight){&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var clientHeight=(document.body.clientHeight&amp;lt;document.documentElement.clientHeight)?document.body.clientHeight:document.documentElement.clientHeight;&lt;br&gt;&amp;nbsp; &amp;nbsp; }else{&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var clientHeight=(document.body.clientHeight&amp;gt;document.documentElement.clientHeight)?document.body.clientHeight:document.documentElement.clientHeight;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; return clientHeight;&amp;nbsp;&amp;nbsp;&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;2.获取窗口滚动条高度&lt;/p&gt;&lt;p&gt;&lt;pre&gt;function getScrollTop(){&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; var scrollTop=0;&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; if(document.documentElement&amp;amp;&amp;amp;document.documentElement.scrollTop){&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; scrollTop=document.documentElement.scrollTop;&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; }else if(document.body){&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; scrollTop=document.body.scrollTop;&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; return scrollTop;&amp;nbsp;&amp;nbsp;&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;3.获取文档内容实际高度&lt;/p&gt;&lt;/p&gt;&lt;pre&gt;function getScrollHeight(){&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; return Math.max(document.body.scrollHeight,document.documentElement.scrollHeight);&amp;nbsp;&amp;nbsp;&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;4.使用方法&lt;/p&gt;&lt;/p&gt;&lt;pre&gt;window.onscroll=function(){&lt;br&gt;&amp;nbsp; &amp;nbsp; // 窗口可视范围的高度&lt;br&gt;&amp;nbsp; &amp;nbsp; var height=getClientHeight(),&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 窗口滚动条高度&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; theight=getScrollTop(),&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 窗口可视范围的高度&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; rheight=getScrollHeight(),&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 滚动条距离底部的高度&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; bheight=rheight-theight-height;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; document.getElementById(\'show\').innerHTML=\'此时浏览器可见区域高度为：\'+height+\'&amp;lt;br /&amp;gt;此时文档内容实际高度为：\'+rheight+\'&amp;lt;br /&amp;gt;此时滚动条距离顶部的高度为：\'+theight+\'&amp;lt;br /&amp;gt;此时滚动条距离底部的高度为：\'+bheight;&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',0,'2017-06-20 00:00:00','22',53),(166,1,'intelliji idea 使用maven创建项目多模块','','\n                                \n                                \n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;首先第一步创建 顶级项目目录 （所有的子模块都在该目录下面），只有一个pom.xml文件&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190520/dea61929cc5d9dbec3deb824ee4fec02.png&quot; data-filename=&quot;img&quot; style=&quot;width: 721px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190520/2138d3753c956954c7f57a25ace105e6.png&quot; data-filename=&quot;img&quot; style=&quot;width: 719px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190520/c77af876c63c1d705d824bf2cd4513b6.png&quot; data-filename=&quot;img&quot; style=&quot;width: 724px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190520/43e22dbb27431770248e4881f8106060.png&quot; data-filename=&quot;img&quot; style=&quot;width: 339px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;最后顶级目录结构如下：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190520/c1a62b515aaccc9e32a47d1c54795f87.png&quot; data-filename=&quot;img&quot; style=&quot;width: 336px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;接下来在顶级目录下创建子模块&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190520/7a432c74a158921f641a7d03fca30be8.png&quot; data-filename=&quot;img&quot; style=&quot;width: 937px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190520/aaa6259953a29a6af190c1336c565dc0.png&quot; data-filename=&quot;img&quot; style=&quot;width: 763px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190520/f8a614874961f010c3200cea48b28328.png&quot; data-filename=&quot;img&quot; style=&quot;width: 743px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190520/4eef28b2af7e57b8ff4fdeed63d1fc4c.png&quot; data-filename=&quot;img&quot; style=&quot;width: 775px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;strong style=&quot;color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;&quot;&gt;archetypeCatalog&lt;/strong&gt;&lt;span style=&quot;color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;&quot;&gt;用来指定maven-archetype-plugin读取本地手动下载的archetype-catalog.xml文件的位置，加快maven创建的速度：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190520/ae641a4ff3fe079791218a5ba4b88202.png&quot; data-filename=&quot;img&quot; style=&quot;width: 779px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190520/3dac717af0b162e56764b82de339ee4f.png&quot; data-filename=&quot;img&quot; style=&quot;width: 380px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;继续添加非web子模块&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190520/dc9b4e45f6c9780724a069050fc671f0.png&quot; data-filename=&quot;img&quot; style=&quot;width: 924px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190520/db4810d94b2070b417595641ca3f233f.png&quot; data-filename=&quot;img&quot; style=&quot;width: 763px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190520/7dcd8deed8141da0f0f575aa0d3635d4.png&quot; data-filename=&quot;img&quot; style=&quot;width: 767px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190520/faf820fc10a3edbb96e6d560174cdf87.png&quot; data-filename=&quot;img&quot; style=&quot;width: 775px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190520/55c194b3796acb6a6d148ef8e3cadfcb.png&quot; data-filename=&quot;img&quot; style=&quot;width: 786px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190520/810a1907e737b8d854a69a830c07647f.png&quot; data-filename=&quot;img&quot; style=&quot;width: 406px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190520/47ebb51704840595e31c6e8689474459.png&quot; data-filename=&quot;img&quot; style=&quot;width: 365px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190520/c9596ad7f370ea1570a52fb404d27189.png&quot; data-filename=&quot;img&quot; style=&quot;width: 587px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;这样真个项目的子模块已经创建完成了，接下来就是进行pom.xml的整合了。待续....&lt;/b&gt;&lt;/div&gt;\n                                                                                                                                                ',0,'2017-06-21 00:00:00','36',45),(163,1,'HTML5实现拖动DIV交换位置详解','','\n                                \n                                &lt;p&gt;主要是利用HTML5提供的API接口实现拖动元素&amp;nbsp;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;“交换位置”&amp;nbsp; &amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190520/d692619d3b4738224ffa0be4885cf17c.png&quot; data-filename=&quot;img&quot; style=&quot;width: 629px;&quot;&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;单纯的用H5来实现的话，用户体验并不好。 一般都是利用js的mousedown mouseup mousemove来实现&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;span style=&quot;font-family: 宋体; font-size: 12pt; white-space: pre-wrap; color: rgb(232, 191, 106);&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;&lt;span style=&quot;font-family: 宋体; font-size: 12pt; white-space: pre-wrap; color: rgb(186, 186, 186);&quot;&gt;html&lt;/span&gt;&lt;span style=&quot;font-family: 宋体; font-size: 12pt; white-space: pre-wrap; color: rgb(232, 191, 106);&quot;&gt;&amp;gt; &lt;/span&gt;&lt;/p&gt;&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;html&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;head&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;    &amp;lt;meta &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;charset&lt;/span&gt;&lt;span style=&quot;color:#6a8759;&quot;&gt;=&quot;utf-8&quot; &lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;/&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;    &amp;lt;title&amp;gt;&lt;/span&gt;HTML5实现拖动DIV交换位置&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/title&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;    &amp;lt;style &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;type&lt;/span&gt;&lt;span style=&quot;color:#6a8759;&quot;&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;        &lt;/span&gt;.&lt;span style=&quot;color:#e8bf6a;&quot;&gt;column &lt;/span&gt;{&lt;span style=&quot;color:#bababa;&quot;&gt;width&lt;/span&gt;:&lt;span style=&quot;color:#6897bb;&quot;&gt;600&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;px&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;height&lt;/span&gt;: &lt;span style=&quot;color:#6897bb;&quot;&gt;56&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;px&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;margin-bottom&lt;/span&gt;: &lt;span style=&quot;color:#6897bb;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;px&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;/span&gt;}&lt;br&gt;        .&lt;span style=&quot;color:#e8bf6a;&quot;&gt;c01&lt;/span&gt;{&lt;span style=&quot;color:#bababa;&quot;&gt;background-color&lt;/span&gt;: &lt;span style=&quot;color:#a5c261;&quot;&gt;blue&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;margin-top&lt;/span&gt;: &lt;span style=&quot;color:#6897bb;&quot;&gt;50&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;px&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;/span&gt;}&lt;br&gt;        .&lt;span style=&quot;color:#e8bf6a;&quot;&gt;c02&lt;/span&gt;{&lt;span style=&quot;color:#bababa;&quot;&gt;background-color&lt;/span&gt;: &lt;span style=&quot;color:#a5c261;&quot;&gt;bisque&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;/span&gt;}&lt;br&gt;        .&lt;span style=&quot;color:#e8bf6a;&quot;&gt;c03&lt;/span&gt;{&lt;span style=&quot;color:#bababa;&quot;&gt;background-color&lt;/span&gt;: &lt;span style=&quot;color:#a5c261;&quot;&gt;gray&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;/span&gt;}&lt;br&gt;        .&lt;span style=&quot;color:#e8bf6a;&quot;&gt;c04&lt;/span&gt;{&lt;span style=&quot;color:#bababa;&quot;&gt;background-color&lt;/span&gt;: &lt;span style=&quot;color:#a5c261;&quot;&gt;yellow&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;/span&gt;}&lt;br&gt;        .&lt;span style=&quot;color:#e8bf6a;&quot;&gt;over&lt;/span&gt;{&lt;span style=&quot;color:#bababa;&quot;&gt;border&lt;/span&gt;:&lt;span style=&quot;color:#6897bb;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#a5c261;&quot;&gt;px dashed red&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;/span&gt;}&lt;br&gt;    &lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/style&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/head&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;body&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;      &amp;lt;div &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;class&lt;/span&gt;&lt;span style=&quot;color:#6a8759;&quot;&gt;=&quot;column c01&quot; &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;draggable&lt;/span&gt;&lt;span style=&quot;color:#6a8759;&quot;&gt;=&quot;true&quot;&lt;/span&gt;&quot;&amp;gt;&lt;br&gt;        &lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;div &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;class&lt;/span&gt;&lt;span style=&quot;color:#6a8759;&quot;&gt;=&quot;box1&quot;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;            &lt;/span&gt;盒子01&lt;br&gt;        &lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/div&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;      &amp;lt;/div&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;        &amp;lt;div &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;class&lt;/span&gt;&lt;span style=&quot;color:#6a8759;&quot;&gt;=&quot;column c02&quot; &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;draggable&lt;/span&gt;&lt;span style=&quot;color:#6a8759;&quot;&gt;=&quot;true&quot;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;            &amp;lt;div &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;class&lt;/span&gt;&lt;span style=&quot;color:#6a8759;&quot;&gt;=&quot;box2&quot;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;                &lt;/span&gt;盒子02&lt;br&gt;            &lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/div&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;        &amp;lt;/div&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;        &amp;lt;div &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;class&lt;/span&gt;&lt;span style=&quot;color:#6a8759;&quot;&gt;=&quot;column c03&quot; &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;draggable&lt;/span&gt;&lt;span style=&quot;color:#6a8759;&quot;&gt;=&quot;true&quot;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;            &amp;lt;div &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;class&lt;/span&gt;&lt;span style=&quot;color:#6a8759;&quot;&gt;=&quot;box3&quot;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;                &lt;/span&gt;盒子03&lt;br&gt;            &lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/div&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;        &amp;lt;/div&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;        &amp;lt;div &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;class&lt;/span&gt;&lt;span style=&quot;color:#6a8759;&quot;&gt;=&quot;column c04&quot; &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;draggable&lt;/span&gt;&lt;span style=&quot;color:#6a8759;&quot;&gt;=&quot;true&quot;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;            &amp;lt;div &lt;/span&gt;&lt;span style=&quot;color:#bababa;&quot;&gt;class&lt;/span&gt;&lt;span style=&quot;color:#6a8759;&quot;&gt;=&quot;box4&quot;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;                &lt;/span&gt;盒子04&lt;br&gt;            &lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/div&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;        &amp;lt;/div&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;script&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;/**&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     ondragstart 拖动哪个对象【事件对象是被拖动的对象】  (按下鼠标左键且移动鼠标时，触发)&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     有个属性dataTransfer  专门用来存储拖放时要携带的数据，把拖动的数据存入其中&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     setData有两个参数：&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     1.第一个参数为携带数据的数据种类的字符串，只能填入类似“text/plain”或“textml”的表示&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     MIME类型的文字&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     2.第二个参数为要携带的数据&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     目标元素使用getData（）方法 获取被拖动的对象携带的数据&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     (1).目标元素接受到被拖放的元素后，执行getData()方法从DataTransfer里获取数据&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     (2).getData()方法的参数为setData()方法中指定的数据类型&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     发生拖动时，从拖动目标(dragstart事件触发的元素)生成半透明图像，并在拖动过程中跟随鼠标指针。这个图片是自动创建的，&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     你不需要自己去创建它。然而，如果想要设置为自定义图像，那么 DataTransfer.setDragImage() 方法就能派上用场。&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     **/&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;function &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;handleDragStart&lt;/span&gt;(e) {&lt;br&gt;        console.&lt;span style=&quot;color:#ffc66d;&quot;&gt;log&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;开始拖动&quot;&lt;/span&gt;)&lt;br&gt;&lt;br&gt;        &lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;this&lt;/span&gt;.&lt;span style=&quot;color:#9876aa;&quot;&gt;style&lt;/span&gt;.&lt;span style=&quot;color:#9876aa;&quot;&gt;opacity &lt;/span&gt;= &lt;span style=&quot;color:#6a8759;&quot;&gt;\'1\'&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;// 添加一个透明度，做一个对比&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#9876aa;&quot;&gt;dragSrcEl &lt;/span&gt;= &lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;this&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;e.&lt;span style=&quot;color:#9876aa;&quot;&gt;dataTransfer&lt;/span&gt;.&lt;span style=&quot;color:#9876aa;&quot;&gt;effectAllowed &lt;/span&gt;= &lt;span style=&quot;color:#6a8759;&quot;&gt;\'move\'&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;// 可有可无，没看出啥不同的地方&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        &lt;/span&gt;e.&lt;span style=&quot;color:#9876aa;&quot;&gt;dataTransfer&lt;/span&gt;.&lt;span style=&quot;color:#ffc66d;&quot;&gt;setData&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;\'text/html\'&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;this&lt;/span&gt;.&lt;span style=&quot;color:#9876aa;&quot;&gt;innerHTML&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;/**&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;         创建一个图像并且使用它作为拖动图像&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;         请注意： 改变 &quot;example.gif&quot; 为一个已经存在的图片&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;         或者，一个还没有创建出来的图片，那么浏览器将会使用默认的拖动图片&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;         译者注：默认的拖动图片与拖动对象没有联系。一般是一个小型文件图标&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;         */&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;// var img = new Image();&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        // img.src = \'example.gif\';&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        // ev.dataTransfer.setDragImage(img, 10, 10);&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;}&lt;br&gt;&lt;br&gt;    &lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;/**&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     ondragenter（当拖动的对象进入落地点时触发该事件，【事件对象是目标点对象】用途：可以添加一个样式给可落地点，给用户一个提示）&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     (这个事件可以理解是做了一些算法处理，因为我们在拖动对象到两个相邻的对象附近时，&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     它会根据被拖动的对象在两个对象中所占区域的比例大小来决定落在哪个对象对上，也就是和那个对象交换位置，&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     其实也不是真正意义上的交换位置，只是把对象里的内容交换了而已)&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     **/&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;function &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;handleDragEnter&lt;/span&gt;(e) {&lt;br&gt;        console.&lt;span style=&quot;color:#ffc66d;&quot;&gt;log&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;找到了一个落地点，需要降落吗？&quot;&lt;/span&gt;)&lt;br&gt;        &lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;this&lt;/span&gt;.&lt;span style=&quot;color:#9876aa;&quot;&gt;classList&lt;/span&gt;.&lt;span style=&quot;color:#ffc66d;&quot;&gt;add&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;\'over\'&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;}&lt;br&gt;&lt;br&gt;    &lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;/**&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     ondragleave (拖动对象离开了落地点触发改时间，【事件对象是目标点对象】用途：可以与ondragenter结合来用，当离开可落地点时，移除刚刚添加的样式)&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     **/&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;function &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;handleDragLeave&lt;/span&gt;(e) {&lt;br&gt;        console.&lt;span style=&quot;color:#ffc66d;&quot;&gt;log&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;离开落地点啦&quot;&lt;/span&gt;)&lt;br&gt;        &lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;this&lt;/span&gt;.&lt;span style=&quot;color:#9876aa;&quot;&gt;classList&lt;/span&gt;.&lt;span style=&quot;color:#ffc66d;&quot;&gt;remove&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;\'over\'&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;}&lt;br&gt;&lt;br&gt;    &lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;/**&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     ondragover 规定拖动的对象允许在哪落地。【事件对象是目标点对象】&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     （dragstart触发后，鼠标在移动的过程中会扫描其它的dom对象，只要扫描的dom对象有监听该事件且设置为event.preventDefault()，都是允许拖动的对象落地的&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     ）&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     这要通过调用 ondragover 事件的 event.preventDefault() 方法：&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     **/&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;function &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;handleDragOver&lt;/span&gt;(e) {&lt;br&gt;        console.&lt;span style=&quot;color:#ffc66d;&quot;&gt;log&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;我这里可以允许落地哦&quot;&lt;/span&gt;)&lt;br&gt;&lt;br&gt;        &lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;if &lt;/span&gt;(e.&lt;span style=&quot;color:#ffc66d;&quot;&gt;preventDefault&lt;/span&gt;) {&lt;br&gt;&lt;br&gt;            e.&lt;span style=&quot;color:#ffc66d;&quot;&gt;preventDefault&lt;/span&gt;()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;}&lt;br&gt;    }&lt;br&gt;    &lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;/**&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     ondrop 当放置被拖数据时，会发生触发该事件。【事件对象是目标点对象】&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;     **/&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#629755;font-style:italic;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;function &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;handleDrop&lt;/span&gt;(e) {&lt;br&gt;        console.&lt;span style=&quot;color:#ffc66d;&quot;&gt;log&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;现在落地开始交换数据啦&quot;&lt;/span&gt;)&lt;br&gt;        &lt;span style=&quot;color:#808080;&quot;&gt;// 阻止默认动作（如打开一些元素的链接）&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        &lt;/span&gt;e.&lt;span style=&quot;color:#ffc66d;&quot;&gt;preventDefault&lt;/span&gt;()&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;if &lt;/span&gt;(dragSrcEl != &lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;this&lt;/span&gt;) {&lt;br&gt;&lt;br&gt;            &lt;span style=&quot;color:#808080;&quot;&gt;// 这里其实就是拖动对象与落地点目标对象的内部内容交换而已。并不是真正意义上的两个dom元素交换位置&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;            &lt;/span&gt;dragSrcEl.&lt;span style=&quot;color:#9876aa;&quot;&gt;innerHTML &lt;/span&gt;= &lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;this&lt;/span&gt;.&lt;span style=&quot;color:#9876aa;&quot;&gt;innerHTML&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;this&lt;/span&gt;.&lt;span style=&quot;color:#9876aa;&quot;&gt;innerHTML &lt;/span&gt;= e.&lt;span style=&quot;color:#9876aa;&quot;&gt;dataTransfer&lt;/span&gt;.&lt;span style=&quot;color:#ffc66d;&quot;&gt;getData&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;\'text/html\'&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;}&lt;br&gt;    }&lt;br&gt;&lt;br&gt;&lt;br&gt;    &lt;span style=&quot;color:#808080;&quot;&gt;//拖拽完成后，作用在被拖拽元素上【事件对象是目标点对象】&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;function &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;handleDragEnd&lt;/span&gt;(e) {&lt;br&gt;        console.&lt;span style=&quot;color:#ffc66d;&quot;&gt;log&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;&quot;终于完成落地啦&quot;&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;this&lt;/span&gt;.&lt;span style=&quot;color:#9876aa;&quot;&gt;style&lt;/span&gt;.&lt;span style=&quot;color:#9876aa;&quot;&gt;opacity &lt;/span&gt;= &lt;span style=&quot;color:#6a8759;&quot;&gt;\'1\'&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;[].&lt;span style=&quot;color:#ffc66d;&quot;&gt;forEach&lt;/span&gt;.&lt;span style=&quot;color:#ffc66d;&quot;&gt;call&lt;/span&gt;(divs&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;function&lt;/span&gt;(d) {&lt;br&gt;            d.&lt;span style=&quot;color:#9876aa;&quot;&gt;classList&lt;/span&gt;.&lt;span style=&quot;color:#ffc66d;&quot;&gt;remove&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;\'over\'&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;})&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;}&lt;br&gt;&lt;br&gt;    &lt;span style=&quot;color:#808080;&quot;&gt;//获取所有需要拖动的节点元素&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;var &lt;/span&gt;divs = document.&lt;span style=&quot;color:#ffc66d;&quot;&gt;querySelectorAll&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;\'.column\'&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;//为每个需要拖动的元素添加监听H5提供的api事件&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;    &lt;/span&gt;[].&lt;span style=&quot;color:#ffc66d;&quot;&gt;forEach&lt;/span&gt;.&lt;span style=&quot;color:#ffc66d;&quot;&gt;call&lt;/span&gt;(divs&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;function&lt;/span&gt;(d) {&lt;br&gt;        &lt;span style=&quot;color:#808080;&quot;&gt;// 整个拖动交换位置的过程，事件的执行顺序如下&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;        &lt;/span&gt;d.&lt;span style=&quot;color:#ffc66d;&quot;&gt;addEventListener&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;\'dragstart\'&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;handleDragStart&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;false&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;d.&lt;span style=&quot;color:#ffc66d;&quot;&gt;addEventListener&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;\'dragenter\'&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;handleDragEnter&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;false&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;d.&lt;span style=&quot;color:#ffc66d;&quot;&gt;addEventListener&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;\'dragover\'&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;handleDragOver&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;false&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;d.&lt;span style=&quot;color:#ffc66d;&quot;&gt;addEventListener&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;\'dragleave\'&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;handleDragLeave&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;false&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;d.&lt;span style=&quot;color:#ffc66d;&quot;&gt;addEventListener&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;\'drop\'&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;handleDrop&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;false&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;        &lt;/span&gt;d.&lt;span style=&quot;color:#ffc66d;&quot;&gt;addEventListener&lt;/span&gt;(&lt;span style=&quot;color:#6a8759;&quot;&gt;\'dragend\'&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#ffc66d;&quot;&gt;handleDragEnd&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#cc7832;font-weight:bold;&quot;&gt;false&lt;/span&gt;)&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;    &lt;/span&gt;})&lt;span style=&quot;color:#cc7832;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#cc7832;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/script&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/body&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;相关的API文档&amp;nbsp;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer/setDragImage&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer/setDragImage&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;                                                        ',0,'2019-05-18 00:00:00','22,29',151),(167,1,'Idea maven项目不能新建package和class的解决','','\n                                \n                                \n                                \n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(79, 79, 79); font-family: &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, Roboto, Noto, Arial, &amp;quot;PingFang SC&amp;quot;, sans-serif; font-size: 16px;&quot;&gt;如图，新建的maven项目不能新建package&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(79, 79, 79); font-family: &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, Roboto, Noto, Arial, &amp;quot;PingFang SC&amp;quot;, sans-serif; font-size: 16px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190521/b56d3381b8d4b6cf5ee7debd62a113c0.png&quot; data-filename=&quot;img&quot; style=&quot;width: 734px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(79, 79, 79); font-family: &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, Roboto, Noto, Arial, &amp;quot;PingFang SC&amp;quot;, sans-serif; font-size: 16px;&quot;&gt;这是因为java是普通的文件夹，要设置为&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(79, 79, 79); font-family: &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, Roboto, Noto, Arial, &amp;quot;PingFang SC&amp;quot;, sans-serif; font-size: 16px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190521/5e49e5f956af6d57ed5dbce53ce8cbbd.png&quot; data-filename=&quot;img&quot; style=&quot;width: 700px;&quot;&gt;&lt;br&gt;&lt;/div&gt;\n                                                                                                                                                                            ',0,'2017-06-23 00:00:00','36',46),(168,1,'mysql中FIND_IN_SET和INSTR的使用方法','','\n                                \n                                \n                                &lt;div&gt;在mysql中，有时我们在做数据库查询时，需要得到某字段中包含某个值的记录，但是它也不是用like能解决的，使用like可能查到我们不想要的记录，它比like更精准，这时候mysql的FIND_IN_SET函数就派上用场了，下面来具体了解一下。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;正常where IN() 处理字符串的查询的时候会有问题&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;FIND_IN_SET(str,strlist)函数&amp;nbsp; &amp;nbsp;(&lt;/b&gt;表示在数据库中查找出str字段的字符串数据包含在strlist中的数据)&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;str 要查询的字符串字段名&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;strlist 字符串参数以”,”分隔 如 (1,2,6,8)&amp;nbsp; // 对于一些表存储的字段有多个值字符串时，使用FIND_IN_SET查询这些字符串值对应的数据再好不过了。&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;div style=&quot;font-weight: bold;&quot;&gt;用法如下&lt;/div&gt;&lt;div style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;font-weight: bold;&quot;&gt;SELECT * FROM `test` t WHERE FIND_IN_SET( t.number , \'number1,number2,number3,number4,number5\')&amp;nbsp; // 记住需要用 \'\' 单引号引起来&lt;/div&gt;&lt;div style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;例子：SELECT * FROM `test` t WHERE FIND_IN_SET( e.number , \'21,25,32\') (只要number&amp;nbsp;字段中字符串的值为\'21\'或\'21,32\',或\'25,21\')都可以查询出来&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;mysql中INSTR函数的用法&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;INSTR(字段字符串, \'搜索字符串\')&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;注意：字段字符串必须是这样的存储形式如：120,123,3,45,5,67&lt;/div&gt;&lt;div style=&quot;&quot;&gt;如果我们的字段是上面的存储形式的话，使用like查询出来的结果可能不是我们预期的结果，比如我们只想查出字段字符串中是否包含有123的时候&lt;/div&gt;&lt;div style=&quot;&quot;&gt;使用like \'%12%\'也可以匹配到&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;但是使用INSTR的话可以很精准的进行查询，&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;INSTR(\'120,123,3,45,5,67\', \'12\') 查不出来结果&lt;/div&gt;&lt;div style=&quot;&quot;&gt;INSTR(\'120,123,3,45,5,67\', \'1\')&amp;nbsp; 查不出来结果&lt;/div&gt;&lt;div style=&quot;&quot;&gt;INSTR(\'120,123,3,45,5,67\', \'120\') 可以查询出来结果&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;INSTR(字段字符串, \'搜索字符串\') = 0 表示搜索的字符串不在字段字符串中&lt;/div&gt;&lt;div style=&quot;&quot;&gt;INSTR(字段字符串, \'搜索字符串\') &amp;gt; 0 表示搜索的字符串在字段字符串中&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n                                                                                                                                                ',0,'2018-06-05 00:00:00','11',59),(169,1,'php 二维数组排序 array_multisort','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;对2维数组或者多维数组排序是常见的问题，在php中我们有个专门的多维数组排序函数，下面简单介绍下：&lt;/p&gt;&lt;p&gt;$array_key = array_colum($origin_array,$field_name) // 利用array_colum获取需要排序的原始数组字段作为一个一维数组&lt;/p&gt;&lt;p&gt;array_multisort($array_key,sorting order,$origin_array）是对多个数组或多维数组进行排序的函数。&lt;/p&gt;&lt;p&gt;sorting order： 可能的值是 SORT_ASC 和 SORT_DESC。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;多种类型排序&lt;/p&gt;&lt;p&gt;array_multisort(array1,sorting order, sorting type,array2,array3..）&lt;/p&gt;&lt;p&gt;array1&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 必需。规定输入的数组。&lt;/p&gt;&lt;p&gt;sorting order&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;可选。规定排列顺序。可能的值是 SORT_ASC 和 SORT_DESC。&lt;/p&gt;&lt;p&gt;sorting type&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;可选。规定排序类型。可能的值是SORT_REGULAR、SORT_NUMERIC和SORT_STRING。&lt;/p&gt;&lt;p&gt;array2&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 可选。规定输入的数组。&lt;/p&gt;&lt;p&gt;array3&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 可选。规定输入的数组。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;SORT_ASC - 默认，按升序排列。(A-Z)&lt;/p&gt;&lt;p&gt;SORT_DESC - 按降序排列。(Z-A)&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;SORT_REGULAR - 默认。将每一项按常规顺序排列。&lt;/p&gt;&lt;p&gt;SORT_NUMERIC - 将每一项按数字顺序排列。&lt;/p&gt;&lt;p&gt;SORT_STRING - 将每一项按字母顺序排列&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;',0,'2016-07-08 00:00:00','23',35),(170,1,'javascript 中文数字字母排序的问题','','\n                                \n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在JavaScript中提供了一个函数arrayName.sort() 默认是升序。且一般用于简单的数组。类似：arr = [3,4,5,54,2,45];但是对于一个对象数据，且有多个字段时，我们需要根据某个字段的值来进行升序和降序操作。该什么处理呢。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;我们可以利用sort()函数提供的一个参数，该参数是一个函数。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;arrayName.sort(sortby)&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;说明&lt;/div&gt;&lt;div&gt;如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。&lt;/div&gt;&lt;div&gt;若 a 等于 b，则返回 0。&lt;/div&gt;&lt;div&gt;若 a 大于 b，则返回一个大于 0 的值。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;sortby 为一个函数&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;function sortby (a,b){&lt;br&gt;   return a - b; // b - a&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;上面的函数的参数 a b就是我们需要排序的数组里面的值（或对象）&lt;/div&gt;&lt;div&gt;当 函数 返回 a -b 可以理解是升序 ；反之， b - a 是降序。利用这个特性我们可以实现数组对象的升序和降序操作&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;对于简单的一维数组&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;function sortNumber(a,b)&lt;br&gt;{&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;return a - b // b - a 降序&lt;br&gt;}&lt;br&gt;var arr = new Array(6)&lt;br&gt;arr[0] = &quot;10&quot;&lt;br&gt;arr[1] = &quot;5&quot;&lt;br&gt;arr[2] = &quot;40&quot;&lt;br&gt;arr[3] = &quot;25&quot;&lt;br&gt;arr[4] = &quot;1000&quot;&lt;br&gt;arr[5] = &quot;1&quot;&lt;br&gt;document.write(arr.sort(sortNumber))&amp;nbsp;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;对于一个对象数据有多个属性值时，我们需要改造一下sort的参数函数&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;// 首先定义一个函数&amp;nbsp;&lt;br&gt;function sortByAttribute(attrName,sortType){&amp;nbsp; //attrName：属性名&amp;nbsp; &amp;nbsp;sortType ：排序类型&amp;nbsp; 比如 asc(升序)&amp;nbsp; desc （降序）&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;br&gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;return function(obj01,obj02) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var a =&amp;nbsp; obj01[attrName];&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var b =&amp;nbsp; obj02[attrName];&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if(sortType == &quot;asc&quot;) {&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt; return&amp;nbsp; a - b;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }else if(sortType == &quot;desc&quot;) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt; return&amp;nbsp; b - a;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;对象数组排序应用场景，比如ul 下面的多个li标签。我们需要根据标签里的时间等标签属性值进行排序&lt;/div&gt;&lt;pre&gt;&amp;lt;ul id=&quot;test&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;lt;li data-time=&quot;158664475&quot;&amp;gt;&amp;lt;/li&amp;gt;&lt;br&gt;&amp;nbsp; &amp;lt;li data-time=&quot;158664485&quot;&amp;gt;&amp;lt;/li&amp;gt;&lt;br&gt;&amp;nbsp; &amp;lt;li data-time=&quot;158664435&quot;&amp;gt;&amp;lt;/li&amp;gt;&lt;br&gt;&amp;nbsp; &amp;lt;li data-time=&quot;158664445&quot;&amp;gt;&amp;lt;/li&amp;gt;&lt;br&gt;&amp;lt;/ul&amp;gt;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;获取ul下面的li 使用JQ。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;var arr_li = $(&quot;#test li&quot;);&amp;nbsp; 此时获取到li的对象数据&lt;br&gt;function sortByAttribute(attrName,sortType){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;br&gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;return function(obj01,obj02) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var a =&amp;nbsp; $(obj01).data(attrName);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var b =&amp;nbsp; $(obj02).data(attrName);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if(sortType == &quot;asc&quot;) {&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt; return&amp;nbsp; a - b;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }else if(sortType == &quot;desc&quot;) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt; return&amp;nbsp; b - a;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}&lt;br&gt;}&lt;br&gt;arr_li.sort(sortByAttribute(\'time\',&quot;desc&quot;))&amp;nbsp; // 排好序后 在循环插入到ul中&amp;nbsp;&lt;br&gt;for(var i= 0; i &amp;lt; arr_li.length;i++;) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;$(&quot;#test&quot;).append(arr_li[i]) // 由于插入的是对象，不会重复出现li；所以不需要清空ul&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;&lt;b&gt;localeCompare() 方法实现中文排序&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;定义：用本地特定的顺序来比较两个字符串。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　语法：stringObject.localeCompare(target)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　参数：target——要以本地特定的顺序与 stringObject 进行比较的字符串。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　返回值：说明比较结果的数字。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　（1）如果 stringObject 小于 target，则 localeCompare() 返回小于 0 的数。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　（2）如果 stringObject 大于 target，则该方法返回大于 0 的数。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　（3）如果两个字符串相等，或根据本地排序规则没有区别，该方法返回 0。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　说明：把 &amp;lt; 和 &amp;gt; 运算符应用到字符串时，它们只用字符的 Unicode 编码比较字符串，而不考虑当地的排序规则。以这种方法生成的顺序不一定是正确的。localeCompare() 方法提供的比较字符串的方法，考虑了默认的本地排序规则。ECMAscript 标准并没有规定如何进行本地特定的比较操作，它只规定该函数采用底层操作系统提供的排序规则。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;实例：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、可以使用localeCompare() 方法来实现中文按照拼音排序&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;function compareFunction(item1, item2) {&lt;br&gt;&amp;nbsp; &amp;nbsp; return item1.localeCompare(item2);&amp;nbsp; // 倒序，把item1、item2位置交换一下&amp;nbsp; return item2.localeCompare(item)&lt;br&gt;}&lt;br&gt;var array = [\'白鸽\', \'麻雀\', \'大象\', \'狗\', \'猫\', &quot;鸡&quot;];&lt;br&gt;array = array.sort(compareFunction(item1, item2));&lt;br&gt;//[&quot;白鸽&quot;, &quot;大象&quot;, &quot;狗&quot;, &quot;鸡&quot;, &quot;麻雀&quot;, &quot;猫&quot;]&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.而且可以通过如下代码实现中文按照拼音排序，并且可以将中文按照a,b,c,d……进行区分。代码如下：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;function pySegSort(arr,empty) {&lt;br&gt;&amp;nbsp; &amp;nbsp; if(!String.prototype.localeCompare)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return null;&lt;br&gt;&amp;nbsp; &amp;nbsp; var letters = &quot;*abcdefghjklmnopqrstwxyz&quot;.split(\'\');&lt;br&gt;&amp;nbsp; &amp;nbsp; var zh = &quot;阿八嚓哒妸发旮哈讥咔垃痳拏噢妑七呥扨它穵夕丫帀&quot;.split(\'\');&lt;br&gt;&amp;nbsp; &amp;nbsp; var segs = [];&lt;br&gt;&amp;nbsp; &amp;nbsp; var curr;&lt;br&gt;&amp;nbsp; &amp;nbsp; $.each(letters, function(i){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; curr = {letter: this, data:[]};&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; $.each(arr, function() {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if((!zh[i-1] || zh[i-1].localeCompare(this) &amp;lt;= 0) &amp;amp;&amp;amp; this.localeCompare(zh[i]) == -1) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; curr.data.push(this);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; });&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if(empty || curr.data.length) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; segs.push(curr);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; curr.data.sort(function(a,b){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return a.localeCompare(b);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; });&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; });&lt;br&gt;&amp;nbsp; &amp;nbsp; return segs;&lt;br&gt;}&lt;br&gt;console.log(JSON.stringify(pySegSort([\'白鸽\', \'麻雀\',\'黑\',\'大象\', \'狗\', \'猫\',\'妈妈\',\'马\', &quot;鸡&quot;,\'瘦\',\'胖\'])));&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;　结果显示为：[{&quot;letter&quot;:&quot;b&quot;,&quot;data&quot;:[&quot;白鸽&quot;]},{&quot;letter&quot;:&quot;d&quot;,&quot;data&quot;:[&quot;大象&quot;]},{&quot;letter&quot;:&quot;g&quot;,&quot;data&quot;:[&quot;狗&quot;]},{&quot;letter&quot;:&quot;h&quot;,&quot;data&quot;:[&quot;黑&quot;]},{&quot;letter&quot;:&quot;j&quot;,&quot;data&quot;:[&quot;鸡&quot;]},{&quot;letter&quot;:&quot;m&quot;,&quot;data&quot;:[&quot;妈妈&quot;,&quot;麻雀&quot;,&quot;马&quot;,&quot;猫&quot;]},{&quot;letter&quot;:&quot;p&quot;,&quot;data&quot;:[&quot;胖&quot;]},{&quot;letter&quot;:&quot;s&quot;,&quot;data&quot;:[&quot;瘦&quot;]}]；通过这个就可以写一个电话薄，像现在手机上面的，通过人名来进行分组、排序，之后再通过循环和布局就可以实现电话薄的功能。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;3、实现字母、数字的混合排序：&lt;/div&gt;&lt;pre&gt;var d = [1,2,3,\'a\',\'k\',\'b\',\'d\',10,20,\'c\']&amp;nbsp;&amp;nbsp;&lt;br&gt;d.sort(function(a,b){&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; var c = isFinite(a), // 如果 number 是有限数字（或可转换为有限数字），那么返回 true。否则，如果 number 是 NaN（非数字），或者是正、负无穷大的数，则返回 false。&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; d = isFinite(b);&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; return (c != d &amp;amp;&amp;amp; d - c) || a &amp;gt; b;&amp;nbsp;&amp;nbsp;&lt;br&gt;})&amp;nbsp;&amp;nbsp;&lt;br&gt;console.log(d);&lt;br&gt;//[1, 2, 3, 10, 20, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;k&quot;]&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;isFinite() 判断a、b是否是数字。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　return 后面的语句：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;　　c != d &amp;amp;&amp;amp; c - d&amp;nbsp; 如果c和d不相等 ，也就是说比较的值不是同一类型。那就比较 c-d的值是1还是-1（中间进行了隐式类型转换）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; 　　 如果c == d 也就是说c、d是同一类型的值，c、d可能都是字母，也可能都是数字。这里就可以直接比较大小了（都是字母的话不能直接做减法）。&lt;/div&gt;&lt;div&gt;　　isFinite() 函数用于检查其参数是否是无穷大。如果 number 是有限数字（或可转换为有限数字），那么返回 true。否则，如果 number 是 NaN（非数字），或者是正、负无穷大的数，则返回 false。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n                                                                                                                    ',0,'2019-05-27 00:00:00','22',94),(171,1,'Concurrenthashmap原理分析','','\n                                \n                                &lt;h4 style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; line-height: 1.5;&quot;&gt;一、背景：&lt;/h4&gt;&lt;h3 style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; line-height: 1.5;&quot;&gt;&lt;font face=&quot;Helvetica Neue, Helvetica, Verdana, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;&lt;b&gt;线程不安全的HashMap&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/h3&gt;&lt;h3 style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; line-height: 1.5;&quot;&gt;&lt;font face=&quot;Helvetica Neue, Helvetica, Verdana, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;&amp;nbsp; &amp;nbsp; 因为多线程环境下，使用Hashmap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。&lt;/span&gt;&lt;/font&gt;&lt;/h3&gt;&lt;h3 style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; line-height: 1.5;&quot;&gt;&lt;font face=&quot;Helvetica Neue, Helvetica, Verdana, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;&lt;b&gt;效率低下的HashTable容器&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/h3&gt;&lt;h3 style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; line-height: 1.5;&quot;&gt;&lt;font face=&quot;Helvetica Neue, Helvetica, Verdana, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;&amp;nbsp;HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。&lt;/span&gt;&lt;/font&gt;&lt;/h3&gt;&lt;h3 style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; line-height: 1.5;&quot;&gt;&lt;font face=&quot;Helvetica Neue, Helvetica, Verdana, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;&lt;b&gt;锁分段技术&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/h3&gt;&lt;h3 style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; line-height: 1.5;&quot;&gt;&lt;font face=&quot;Helvetica Neue, Helvetica, Verdana, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;&amp;nbsp; &amp;nbsp; HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。&lt;/span&gt;&lt;/font&gt;&lt;/h3&gt;&lt;h3 style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; line-height: 1.5;&quot;&gt;&lt;img src=&quot;/upload/article/20191024/ddd1c404efaa9542dd917045e8753c37.png&quot; data-filename=&quot;img&quot; style=&quot;width: 308px;&quot;&gt;&lt;font face=&quot;Helvetica Neue, Helvetica, Verdana, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/h3&gt;&lt;h3 style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; line-height: 1.5;&quot;&gt;&lt;font face=&quot;Helvetica Neue, Helvetica, Verdana, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。&lt;/span&gt;&lt;/font&gt;&lt;/h3&gt;&lt;h3 style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; line-height: 1.5;&quot;&gt;&lt;font face=&quot;Helvetica Neue, Helvetica, Verdana, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;&lt;b&gt;应用场景&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/h3&gt;&lt;h3 style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; line-height: 1.5;&quot;&gt;&lt;font face=&quot;Helvetica Neue, Helvetica, Verdana, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;&amp;nbsp; &amp;nbsp; 当有一个大数组时需要在多个线程共享时就可以考虑是否把它给分层多个节点了，避免大锁。并可以考虑通过hash算法进行一些模块定位。&lt;/span&gt;&lt;/font&gt;&lt;/h3&gt;&lt;h3 style=&quot;margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px; line-height: 1.5;&quot;&gt;&lt;font face=&quot;Helvetica Neue, Helvetica, Verdana, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;其实不止用于线程，当设计数据表的事务时（事务某种意义上也是同步机制的体现），可以把一个表看成一个需要同步的数组，如果操作的表数据太多时就可以考虑事务分离了（这也是为什么要避免大表的出现），比如把数据进行字段拆分，水平分表等.&lt;/span&gt;&lt;/font&gt;&lt;/h3&gt;&lt;h4 style=&quot;line-height: 1.5; color: rgb(0, 0, 0); margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px;&quot;&gt;&lt;font face=&quot;Helvetica Neue, Helvetica, Verdana, Arial, sans-serif&quot;&gt;&amp;nbsp; Concurrenthashmap和hashmap扩容&lt;/font&gt;&lt;font face=&quot;Helvetica Neue, Helvetica, Verdana, Arial, sans-serif&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;font face=&quot;Helvetica Neue, Helvetica, Verdana, Arial, sans-serif&quot;&gt;如果超过阀值，数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时HashMap就进行了一次无效的扩容。&lt;br&gt;&lt;/font&gt;&lt;font face=&quot;Helvetica Neue, Helvetica, Verdana, Arial, sans-serif&quot;&gt;Concurrenthashmap如何扩容。扩容的时候首先会创建一个两倍于原容量的数组，然后将原数组里的元素进行再hash后插入到新的数组里。为了高效ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。&lt;/font&gt;&lt;/h4&gt;&lt;h3 style=&quot;line-height: 1.5; color: rgb(0, 0, 0); margin-top: 10px; margin-right: 0px; margin-left: 0px; padding: 0px;&quot;&gt;&lt;font face=&quot;Helvetica Neue, Helvetica, Verdana, Arial, sans-serif&quot;&gt;&lt;/font&gt;&lt;/h3&gt;\n\n                                                                                                                    ',0,'2019-05-28 00:00:00','34',1),(172,1,'IDEA显示详细的报错信息','','\n                                &lt;div&gt;在使用idea开发时，常常会有报错的问题，但是提示的错误信息太少。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;解决方案：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;只要是能看到详细的报错日志，要解决问题就迎刃而解了，可是得有日志文件出来呀&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;所以，在classpath：下新建一个logging.properties文件【classpath就是你项目的/目录下】&amp;nbsp; 使用idea，在target目录的classes 目录下新建&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;handlers = org.apache.juli.FileHandler, java.util.logging.ConsoleHandler&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;############################################################&lt;br&gt;# Handler specific properties.&lt;br&gt;# Describes specific configuration info for Handlers.&lt;br&gt;############################################################&lt;br&gt;org.apache.juli.FileHandler.level = FINE&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;org.apache.juli.FileHandler.directory = ../logs&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;org.apache.juli.FileHandler.prefix = error-debug.&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;java.util.logging.ConsoleHandler.level = FINE&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; line-height: 1.5; font-family: verdana, &amp;quot;ms song&amp;quot;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif;&quot;&gt;然后重新启动项目&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; line-height: 1.5; font-family: verdana, &amp;quot;ms song&amp;quot;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif;&quot;&gt;在你tomcat的logs，目录下查看日志文件&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; line-height: 1.5;&quot;&gt;&lt;a href=&quot;D:\\apache-tomcat-8.5\\logs&quot;&gt;D:\\apache-tomcat-8.5\\logs&lt;/a&gt;&lt;a href=&quot;D:\\apache-tomcat-8.5\\logs&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; line-height: 1.5;&quot;&gt;&lt;span style=&quot;font-family: verdana, &amp;quot;ms song&amp;quot;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif;&quot;&gt;或直接在IDEA 的 console下查看错误：&lt;/span&gt;&lt;br&gt;&lt;font face=&quot;verdana, ms song, 宋体, Arial, 微软雅黑, Helvetica, sans-serif&quot;&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; line-height: 1.5;&quot;&gt;&lt;font face=&quot;verdana, ms song, 宋体, Arial, 微软雅黑, Helvetica, sans-serif&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\n                                                                                        ',0,'2018-01-02 00:00:00','36',54),(173,1,'JAVA_Web项目SSM框架开发目录结构','','&lt;p&gt;\n                                \n                                &lt;p&gt;&lt;img src=&quot;/upload/article/20190603/34c00b3a88e54fb109fb68708bcf7740.png&quot; data-filename=&quot;img&quot; style=&quot;width: 603px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;br&gt;├──pom.xml                                      //maven 依赖包配置文件&lt;br&gt;├──main&lt;br&gt;|  ├──java&lt;br&gt;|  |  └──com&lt;br&gt;|  |     └──lzc&lt;br&gt;|  |        ├── ssmstudy&lt;br&gt;|  |        |  ├── controller                   //控制器包&lt;br&gt;|  |        |  ├── pojo                         //POJO包&lt;br&gt;|  |        |  ├── dao                          //Mapper接口包&lt;br&gt;|  |        |  ├── service                      //Service接口包&lt;br&gt;|  |        |         └── impl                  //service实现类文件夹&lt;br&gt;|  |        └──util                             //工具包&lt;br&gt;|  ├── resources                                //资源文件夹（配置文件）&lt;br&gt;|  |  ├──jdbc.properties                        //数据库配置文件&lt;br&gt;|  |  ├──log4j.properties                       //log4j配置文件&lt;br&gt;|  |  ├──mybatis-config.xml                     //mybatis配置文件&lt;br&gt;|  |  └── mapping                               //mapper.xml文件夹&lt;br&gt;|  |     └── PaperMapper.xml                    // 对应的sql语句&lt;br&gt;|  |  └── spring                                // spring整合配置文件夹&lt;br&gt;|  |      └── spring-mvc.xml                    //springMvc配置文件&lt;br&gt;|  |      └── spring-service.xml                //spring-mybatis整合配置&lt;br&gt;|  |      └── spring-dao.xml                    //spring-mybatis整合配置&lt;br&gt;|  └── webapp                                   ///web应用部署根目录&lt;br&gt;|     ├──index.jsp                              //首页&lt;br&gt;|     ├──static                                 //静态资源文件夹&lt;br&gt;|     |  ├──css&lt;br&gt;|     |  |  └── login.css&lt;br&gt;|     |  ├──images&lt;br&gt;|     |  |  ├──login-img.png&lt;br&gt;|     |  |  └── login_logo.png&lt;br&gt;|     |  └── js&lt;br&gt;|     |     └── JQuery.js&lt;br&gt;|     └── WEB-INF&lt;br&gt;|       └── web.xml                           // web页面配置&lt;br&gt;        ├──jsp                                    //jsp页面文件夹&lt;br&gt;           └── studentList.jsp                    //对应的页面文件&lt;/pre&gt;                                                        &lt;/p&gt;&lt;p&gt;SSM中各层作用及关系&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.持久层：DAO层（mapper层）（属于mybatis模块）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;DAO层：主要负责与数据库进行交互设计，用来处理数据的持久化工作。&lt;/p&gt;&lt;p&gt;DAO层的设计首先是设计DAO的接口，也就是项目中你看到的Dao包。&lt;/p&gt;&lt;p&gt;然后在Spring的xml配置文件中定义此接口的实现类，就可在其他模块中调用此接口来进行数据业务的处理，而不用关心接口的具体实现类是哪个类，这里往往用到的就是反射机制，DAO层的jdbc.properties数据源配置，以及有 关数据库连接的参数都在Spring的配置文件中进行配置。&lt;/p&gt;&lt;p&gt;ps:（有的项目里面Dao层，写成mapper，当成一个意思理解。）&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.业务层：Service层（属于spring模块）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Service层：主要负责业务模块的逻辑应用设计。也就是项目中你看到的Service包。&lt;/p&gt;&lt;p&gt;Service层的设计首先是设计接口，再设计其实现的类。也就是项目中你看到的service+impl包。&lt;/p&gt;&lt;p&gt;接着再在Spring的xml配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。&lt;/p&gt;&lt;p&gt;最后通过调用DAO层已定义的接口，去实现Service具体的实现类。&lt;/p&gt;&lt;p&gt;ps:(Service层的业务实现，具体要调用到已定义的DAO层的接口.)&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.控制层/表现层：Controller层（Handler层） （属于springMVC模块）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Controller层：主要负责具体的业务模块流程控制，也就是你看到的controller包。&lt;/p&gt;&lt;p&gt;Controller层通过要调用Service层的接口来控制业务流程，控制的配置也同样是在Spring的xml配置文件里面，针对具体的业务流程，会有不同的控制器。&lt;/p&gt;&lt;p&gt;&lt;b&gt;4.View层 （属于springMVC模块）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;负责前台jsp页面的展示，此层需要与Controller层结合起来开发。&lt;/p&gt;&lt;p&gt;Jsp发送请求，controller接收请求，处理，返回，jsp回显数据。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190603/a3ba44b1383de626761acabb98622c39.png&quot; data-filename=&quot;img&quot; style=&quot;width: 597px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;4.各层之间的联系&lt;/b&gt;&lt;/p&gt;&lt;p&gt;DAO层，Service层这两个层次可以单独开发，互相的耦合度很低。&lt;/p&gt;&lt;p&gt;Controller，View层耦合度比较高，因而要结合在一起开发。也可以听当做两层来开发，这样，在层与层之前我们只需要知道接口的定义，调用接口即可完成所需要的逻辑单元应用，项目会显得清晰简单。&lt;/p&gt;&lt;p&gt;值得注意的是，Service逻辑层设计：&amp;nbsp;&lt;/p&gt;&lt;p&gt;Service层是建立在DAO层之上的，在Controller层之下。因而Service层应该既调用DAO层的接口，又提供接口给Controller层的类来进行调用，它处于一个中间层的位置。每个模型都有一个Service接口，每个接口分别封装各自的业务处理方法。&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190603/0edae8655c7ed06c40cf6f8d979d37c6.png&quot; data-filename=&quot;img&quot; style=&quot;width: 668px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;4.SSM框架实现一个web程序主要使用到如下三个技术：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Spring：用到注解和自动装配，就是Spring的两个精髓IOC(反向控制)和 AOP(面向切面编程)。&lt;/li&gt;&lt;li&gt;SpringMVC：用到了MVC模型，将流程控制代码放到Controller层处理，将业务逻辑代码放到Service层处理。&lt;/li&gt;&lt;li&gt;Mybatis：用到了与数据库打交道的层面，dao（mapper）层，放在所有的逻辑之后，处理与数据库的CRUD相关的操作。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;比如你开发项目的时候，需要完成一个功能模块：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;先写实体类entity，定义对象的属性，（可以参照数据库中表的字段来设置，数据库的设计应该在所有编码开始之前）。&lt;/li&gt;&lt;li&gt;写Mapper.xml（Mybatis），其中定义你的功能，对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。&lt;/li&gt;&lt;li&gt;写Mapper.java/Dao.java，将Mapper.xml中的操作按照id映射成Java函数。实际上就是Dao接口，二者选一即可。&lt;/li&gt;&lt;li&gt;写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。&lt;/li&gt;&lt;li&gt;写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。&lt;/li&gt;&lt;li&gt;写JSP页面调用，请求哪些参数，需要获取什么数据。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',0,'2017-12-21 00:00:00','34',66),(174,1,'php 获取本周开始日期和结束日期的方法','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre&gt;//当前日期&lt;br&gt;$sdefaultDate = date(&quot;Y-m-d&quot;);&lt;br&gt;//$first =1 表示每周星期一为开始日期 0表示每周日为开始日期&lt;br&gt;$first=1;&lt;br&gt;//获取当前周的第几天 周日是 0 周一到周六是 1 - 6&lt;br&gt;$w=date(\'w\',strtotime($sdefaultDate));&lt;br&gt;//获取本周开始日期，如果$w是0，则表示周日，减去 6 天&lt;br&gt;$week_start=date(\'Y-m-d\',strtotime(&quot;$sdefaultDate -&quot;.($w ? $w - $first : 6).\' days\'));&lt;br&gt;//本周结束日期&lt;br&gt;$week_end=date(\'Y-m-d\',strtotime(&quot;$week_start +6 days&quot;));&lt;br&gt;echo &quot;$week_start&quot;.&quot;$week_end&quot;;&lt;/pre&gt;',0,'2018-02-02 00:00:00','23',40),(175,1,'dom对象互换位置实现原理','','\n                                \n                                &lt;p&gt;在实际业务中我们有时候需要改变dom节点的位置；在一些节点滚动效果的动画中，其实很多也是用了改变dom节点的位置实现的，比如把dom03与dom01交换位置。&lt;/p&gt;&lt;p&gt;下面以jq对象为例&lt;/p&gt;&lt;p&gt;html代码：&lt;/p&gt;&lt;pre&gt;&amp;lt;ul id=&quot;test&quot;&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;li&amp;gt;dom01&amp;lt;/li&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;li&amp;gt;dom02&amp;lt;/li&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;li&amp;gt;dom03&amp;lt;/li&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;lt;li&amp;gt;dom04&amp;lt;/li&amp;gt;&lt;br&gt;&amp;lt;/ul&amp;gt;&lt;/pre&gt;&lt;p&gt;获取所有的li对象&amp;nbsp;&amp;nbsp;&lt;/p&gt;&lt;pre&gt;var parent_dom = $(&quot;#test&quot;);&lt;br&gt;var list_li = $(&quot;#test &amp;gt;&amp;nbsp; li&quot;);&lt;br&gt;var dom01 = $(list_li[0]), dom02 = $(list_li[2]);&lt;/pre&gt;&lt;p&gt;定义函数：&lt;/p&gt;&lt;pre&gt;/**&lt;br&gt;@param cur_dom 当前要交换的dom对象 比如 dom01&amp;nbsp;&lt;br&gt;@param tar_dom 要与当前dom对象交换的目标对象 比如 dom02&lt;br&gt;@param parent_dom 交换对象的父节点dom对象&lt;br&gt;*/&lt;br&gt;function swapDom(cur_dom,tar_dom,parent_dom) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;var cur_nextNode = cur_dom.next(); // 当前的下一个节点&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;var tar_nextNode = tar_dom.next(); // 目标的下一个节点&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;if(cur_nextNode.length &amp;amp;&amp;amp; tar_nextNode.length) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;tar_dom.insertBefore(cur_nextNode);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;cur_dom.insertBefore(tar_nextNode);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}else{&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;if(cur_nextNode.length) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;parent_dom.append(cur_dom);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;tar_dom.insertBefore(cur_nextNode);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;if(tar_nextNode.length) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;parent_dom.append(tar_dom);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;			&lt;/span&gt;cur_dom.insertBefore(tar_nextNode);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                                                        ',0,'2019-06-03 00:00:00','22',105),(176,1,'http get/post请求，参数出现空格等情况的处理','','\n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;今天线上项目有个小功能突然报错，经排查得知：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在get请求中，有时候会出现空格的请求，导致后端接收的数据不完整，解决方式，&lt;/div&gt;&lt;pre&gt;利用JavaScript的encodeURL(参数)编码后在传递，然后后端比如php接收时，利用urldecode(参数)解码可以解决&lt;/pre&gt;&lt;p&gt;拓展：&lt;/p&gt;&lt;p&gt;客户端向服务器发起http请求传递参数时，url出现+，空格，/，?，%，#，&amp;amp;，=等特殊符号的时候就自动变成空格，可能在服务器端无法获得正确的参数值&lt;/p&gt;&lt;pre&gt;URL字符转义&lt;br&gt;URL 中+号表示空格&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; %2B&amp;nbsp; &amp;nbsp;&lt;br&gt;空格 URL中的空格可以用+号或者编码&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; %20&amp;nbsp;&lt;br&gt;/&amp;nbsp; &amp;nbsp;分隔目录和子目录&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;%2F&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;br&gt;?&amp;nbsp; &amp;nbsp; 分隔实际的URL和参数&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;%3F&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;br&gt;%&amp;nbsp; &amp;nbsp; 指定特殊字符&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; %25&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;br&gt;#&amp;nbsp; &amp;nbsp; 表示书签&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; %23&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;br&gt;&amp;amp;&amp;nbsp; &amp;nbsp; URL 中指定的参数间的分隔符&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; %26&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;br&gt;=&amp;nbsp; &amp;nbsp; URL 中指定参数的值&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; %3D&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;客户端可以通过:&lt;/p&gt;&lt;p&gt;url.replace(\'+\',\'%2B\'); 替换的形式，替换后在传递值&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;                            ',0,'2019-06-05 00:00:00','22',115),(177,1,'java对象转json所需要的jar包','','&lt;p&gt;通过maven下载依赖包 ，配置pom依赖：&lt;/p&gt;&lt;pre style=&quot;background-color:#2b2b2b;color:#a9b7c6;font-family:\'宋体\';font-size:10.5pt;&quot;&gt;&lt;span style=&quot;color:#808080;&quot;&gt;&amp;lt;!-- json-lib包 用于 对象转json格式使用 --&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;dependency&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;       &amp;lt;groupId&amp;gt;&lt;/span&gt;net.sf.json-lib&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;       &amp;lt;artifactId&amp;gt;&lt;/span&gt;json-lib&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;       &amp;lt;version&amp;gt;&lt;/span&gt;2.4&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/version&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;       &amp;lt;classifier&amp;gt;&lt;/span&gt;jdk15&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/classifier&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt; &amp;lt;/dependency&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;&amp;lt;!-- json-lib还需要以下依赖包 --&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;dependency&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;     &amp;lt;groupId&amp;gt;&lt;/span&gt;commons-lang&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;     &amp;lt;artifactId&amp;gt;&lt;/span&gt;commons-lang&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;     &amp;lt;version&amp;gt;&lt;/span&gt;2.5&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/version&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt; &amp;lt;/dependency&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt; &amp;lt;dependency&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;     &amp;lt;groupId&amp;gt;&lt;/span&gt;commons-beanutils&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;     &amp;lt;artifactId&amp;gt;&lt;/span&gt;commons-beanutils&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;     &amp;lt;version&amp;gt;&lt;/span&gt;1.9.2&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/version&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt; &amp;lt;/dependency&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt; &amp;lt;dependency&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;     &amp;lt;groupId&amp;gt;&lt;/span&gt;commons-collections&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;     &amp;lt;artifactId&amp;gt;&lt;/span&gt;commons-collections&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;     &amp;lt;version&amp;gt;&lt;/span&gt;3.2.1&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/version&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt; &amp;lt;/dependency&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt; &amp;lt;dependency&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt; &amp;lt;groupId&amp;gt;&lt;/span&gt;commons-logging&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt; &amp;lt;artifactId&amp;gt;&lt;/span&gt;commons-logging&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt; &amp;lt;version&amp;gt;&lt;/span&gt;1.2&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/version&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#e8bf6a;&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/pre&gt;&lt;pre&gt;Student stu=new Student();&lt;br&gt;stu.setName(&quot;JSON&quot;);&lt;br&gt;stu.setAge(&quot;23&quot;);&lt;br&gt;stu.setAddress(&quot;北京市西城区&quot;);&lt;br&gt;//1、使用JSONObject&lt;br&gt;JSONObject json = JSONObject.fromObject(stu);&lt;br&gt;//2、使用JSONArray&lt;br&gt;JSONArray array=JSONArray.fromObject(stu);&lt;br&gt;String strJson=json.toString();&lt;br&gt;String strArray=array.toString();&lt;br&gt;System.out.println(&quot;strJson:&quot;+strJson);&lt;br&gt;System.out.println(&quot;strArray:&quot;+strArray);&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;&lt;pre&gt;strJson:{&quot;address&quot;:&quot;北京市西城区&quot;,&quot;age&quot;:&quot;23&quot;,&quot;name&quot;:&quot;JSON&quot;}&lt;br&gt;strArray:[{&quot;address&quot;:&quot;北京市西城区&quot;,&quot;age&quot;:&quot;23&quot;,&quot;name&quot;:&quot;JSON&quot;}]&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',0,'2017-12-21 00:00:00','34',43),(178,1,'VMware15 安装centos7 NAT模式下配置静态IP','','\r\n                                \r\n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;一、GUI图形界面配置&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190609/95ebbc3d82eff791318563d8d101bcf8.png&quot; data-filename=&quot;img&quot; style=&quot;width: 549px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190609/d8fd63a87d999865e58229d3ee49b2b0.png&quot; data-filename=&quot;img&quot; style=&quot;width: 619px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190609/392d2c317fbde73335cb65d277cb5c7a.png&quot; data-filename=&quot;img&quot; style=&quot;width: 662px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上面Addresses配置可参照NAT的配置来自定义&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190609/83d40b3f16783583edcc5736ae6dde3f.png&quot; data-filename=&quot;img&quot; style=&quot;width: 518px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190609/b38f6c827fd0760dc71e30dd5ed06a8e.png&quot; data-filename=&quot;img&quot; style=&quot;width: 690px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190609/37d12efaa205a9c61953e496ef339df0.png&quot; data-filename=&quot;img&quot; style=&quot;width: 537px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;配置完成后，重启网络： systemctl restart network&lt;/p&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190609/7eafa608a412b4582bf2fa7d32bc8e4c.png&quot; data-filename=&quot;img&quot; style=&quot;width: 757px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;然后利用ping &lt;a href=&quot;http://www.baidu.com&quot;&gt;www.baidu.com&lt;/a&gt;&amp;nbsp;测试是否可以上网，以及ping 本地主机IP 是否可以ping 通&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;二、修改配置文件配置静态IP&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;以centos7为例：网卡配置一般在 ：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;/etc/sysconfig/network-scripts/ifcfg-*  (我的为ifcfg-ens33)&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190609/ff925cb5b3b7fa60671189bd8674784f.png&quot; data-filename=&quot;img&quot; style=&quot;width: 682px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;编辑上面的文件&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190609/89f23ed94d4f4880cfbec0b8f1eac346.png&quot; data-filename=&quot;img&quot; style=&quot;width: 569px;&quot;&gt;&lt;/p&gt;&lt;p&gt;然后重启网络&amp;nbsp;&lt;span style=&quot;color: rgb(87, 89, 98); font-family: Poppins; font-size: 14px;&quot;&gt;&lt;b&gt;systemctl restart network&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(87, 89, 98); font-family: Poppins; font-size: 14px;&quot;&gt;&lt;b&gt;用 ip add 可以看到 ifcfg-ens33 的IP配置信息&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\r\n                                                            &lt;/p&gt;                                                        ',0,'2018-06-05 00:00:00','17',30),(179,1,'HTML锚点几种方式','','&lt;div&gt;HTML锚点几种方式&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1. 在同一页面中&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;&amp;lt;a name=&quot;add&quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;!-- 定义锚点 --&amp;gt;&lt;br&gt;&amp;lt;a href=&quot;#add&quot;&amp;gt;跳转到name为:add 的标签&amp;lt;/a&amp;gt;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2. 在不同页面中，锚点定位在a.html中，从b页面的链接跳转到这个锚点&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;b.html&lt;/div&gt;&lt;pre&gt;&amp;lt;a href=&quot;a.html#add&quot;&amp;gt;跳转到a.html中标签name为:add 的标签&amp;lt;/a&amp;gt;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.利用JavaScript提供的API实现定位&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;&amp;lt;div id=&quot;divNode&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;br&gt;&amp;lt;a href=&quot;JavaScript:;&quot; onclick=&quot;scrollIntoNode();&quot;&amp;gt;通过scrollIntoView实现锚点效果&amp;lt;/a&amp;gt;&lt;br&gt;&amp;lt;script&amp;gt;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;function scrollIntoNode() {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;document.getElemetnById(\'divNode\').scrollIntoView(true); // 还有一个API是 scrollTo 也是定位的&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;br&gt;&lt;/span&gt;&amp;lt;/script&amp;gt;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\n                                                            ',0,'2019-06-10 00:00:00','22,29',103),(180,1,'php静态变量的销毁','','&lt;p&gt;函数内静态变量每次执行完后，都会把结果保存在内存中，并不会被清空，需要自己手动销毁&lt;/p&gt;&lt;pre&gt;public function _childrenids($data,$cate_id,$clear=false)&lt;br&gt;&amp;nbsp;{&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;static $arr = array();&lt;br&gt;&amp;nbsp; &amp;nbsp; // 外部调用时需要把$clear设置为true，清空上次的数据&lt;br&gt;&amp;nbsp; &amp;nbsp; if ($clear)&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;{&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;$arr = array();&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;}&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;foreach ($data as $k =&amp;gt; $v)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;{&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;if($v[\'pid\'] == $cate_id)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;{&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;$arr[] = $v[\'id\'];&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;$this -&amp;gt; _childrenids($data,$v[\'id\']);&amp;nbsp; // 内部调用本身不需要销毁。&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;}&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;}&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;return $arr;&lt;br&gt;&amp;nbsp;}&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;',0,'2016-06-07 00:00:00','23',29),(181,1,'仿CSDN隐藏显示文章内容实现','','\n                                \n                                &lt;p&gt;看了一下CSDN的实现，其实很简单就是给文章显示的DIV一个固定的高度,利用overflow:hidden属性隐藏多余的内容，然后在通过点击显示文章详情，把height 和overflow 去掉&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre&gt;&amp;lt;div class=&quot;text-hidden&quot; style=&quot;height:50px;overflow:hidden;position:relative;&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; 测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;lt;span class=&quot;more&quot; style=&quot;position:absolute;right:0px;top:0px;&quot;&amp;gt;更多&amp;lt;/span&amp;gt;&lt;br&gt;&amp;nbsp; &amp;lt;/div&amp;gt;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; $(&quot;.more&quot;).on(&quot;click&quot;,function(){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; $(&quot;.text-hidden&quot;).css({&quot;height&quot;:&quot;&quot;,&quot;overflow&quot;:\'\'})&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; })&lt;br&gt;&amp;nbsp; &amp;lt;/script&amp;gt;&lt;/pre&gt;                                                        ',0,'2019-01-01 00:00:00','21,22',62),(182,1,'PHP递归实现无限极分类','','&lt;pre&gt;$array = array(&lt;br&gt;array(\'id\' =&amp;gt; 1, \'pid\' =&amp;gt; 0, \'name\' =&amp;gt; \'河北省\'),&lt;br&gt;array(\'id\' =&amp;gt; 2, \'pid\' =&amp;gt; 0, \'name\' =&amp;gt; \'北京市\'),&lt;br&gt;array(\'id\' =&amp;gt; 3, \'pid\' =&amp;gt; 1, \'name\' =&amp;gt; \'邯郸市\'),&lt;br&gt;array(\'id\' =&amp;gt; 4, \'pid\' =&amp;gt; 2, \'name\' =&amp;gt; \'朝阳区\'),&lt;br&gt;array(\'id\' =&amp;gt; 5, \'pid\' =&amp;gt; 2, \'name\' =&amp;gt; \'通州区\'),&lt;br&gt;array(\'id\' =&amp;gt; 6, \'pid\' =&amp;gt; 4, \'name\' =&amp;gt; \'望京\'),&lt;br&gt;array(\'id\' =&amp;gt; 7, \'pid\' =&amp;gt; 4, \'name\' =&amp;gt; \'酒仙桥\'),&lt;br&gt;array(\'id\' =&amp;gt; 8, \'pid\' =&amp;gt; 3, \'name\' =&amp;gt; \'永年区\'),&lt;br&gt;array(\'id\' =&amp;gt; 9, \'pid\' =&amp;gt; 1, \'name\' =&amp;gt; \'武安市\'),&lt;br&gt;);&lt;br&gt;第一种方式：使用递归&lt;br&gt;//生成树形结构数组&lt;br&gt;function getTree($data,$pId,$level){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;$tree = array(); //这里不需要设置静态变量&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;foreach($data as $k =&amp;gt; $v){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;$v[\'level\'] = $level;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; if($v[\'pid\'] == $pId){&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;nbsp; &amp;nbsp; //父亲找到儿子&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;nbsp; &amp;nbsp; $v[\'son\'] = getTree($data, $v[\'id\'],$level+1);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;nbsp; &amp;nbsp; $tree[] = $v;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;//把这个节点从数组中移除,减少后续递归消耗&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;nbsp; &amp;nbsp; unset($data[$k]);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}&lt;br&gt;&amp;nbsp; &amp;nbsp; return $tree;&lt;br&gt;}&lt;br&gt;$dataTree = getTree($array,0,0);&lt;br&gt;&lt;br&gt;//把树型状数组转为html&lt;br&gt;function creatTreeHtml($dataTree){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;$html = \'\';&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;foreach($dataTree as $t){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; if($t[\'pid\'] == \'\'){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;$html .= &quot;&amp;lt;li&amp;gt;{$t[\'name\']}&amp;lt;/li&amp;gt;&quot;;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; }else{&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;nbsp; &amp;nbsp;$html .= &quot;&amp;lt;li&amp;gt;&quot;.$t[\'name\'];&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;nbsp; &amp;nbsp;$html .= creatTreeHtml($t[\'son\']);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;nbsp; &amp;nbsp;$html = $html.&quot;&amp;lt;/li&amp;gt;&quot;;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; }&lt;br&gt;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;return $html ? \'&amp;lt;ul&amp;gt;\'.$html.\'&amp;lt;/ul&amp;gt;\' : $html ;&lt;br&gt;}&lt;br&gt;echo creatTreeHtml($dataTree);&lt;br&gt;&lt;br&gt;//合并上面的代码&lt;br&gt;function getTreeHtml($data,$pId){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;$html = \'\';&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;foreach($data as $k =&amp;gt; $v){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;if($v[\'pid\'] == $pId){&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;nbsp; &amp;nbsp; //父亲找到儿子&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;nbsp; &amp;nbsp; $html .= &quot;&amp;lt;li&amp;gt;&quot;.$v[\'name\'];&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;nbsp; &amp;nbsp; $html .= getTreeHtml($data, $v[\'id\']);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;nbsp; &amp;nbsp; $html = $html.&quot;&amp;lt;/li&amp;gt;&quot;;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;nbsp; &amp;nbsp; unset($data[$k]);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;return $html ? \'&amp;lt;ul&amp;gt;\'.$html.\'&amp;lt;/ul&amp;gt;\' : $html ;&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\n                                                            ',0,'2017-04-01 00:00:00','23',40),(183,1,'利用PHP中array_flip函数巧妙删除指定的数据','','\n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;有时候我们会把ID以字符串的形式保存在数据表字段中；比如：1,10,20,&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;当我们需要删除指定的ID时，&lt;/div&gt;&lt;div&gt;我们先把：1,10,20&amp;nbsp; 转换成数组 $a = explode(&quot;,&quot;,&quot;1,10,20&quot;)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;然后利用array_flip函数可以使得 数组key-value互换。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这样的话我们根据key删除指定的数据 unset($a[$id])&lt;/div&gt;\n                                                                                        ',0,'2019-07-18 00:00:00','23',102),(184,1,'Jquery on(\"click\") 方法绑定事件后执行多次解决办法','','&lt;p&gt;项目遇到过使用js动态加载内容，同时需要对新增加的节点绑定事件，使用的是 on(‘click’,function(){}) ,然而使用on方法的时候就发现，on 对同一个元素多次绑定同一个事件的时候，这个事件就会执行多次。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre&gt;&amp;nbsp;$(function(){&lt;br&gt;&amp;nbsp; &amp;nbsp; $(&quot;.add&quot;).click(function(eve){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; $(&quot;.btn-area&quot;).append(&quot;&amp;lt;button class=\'test-btn\'&amp;gt;test button&amp;lt;/button&amp;gt;&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //$(&quot;.test-btn&quot;).off(&quot;click&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //$(&quot;.test-btn&quot;).unbind(&quot;click&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //$(&quot;.test-btn&quot;).unbind(); //去掉所有绑定事件&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; $(&quot;.test-btn&quot;).on(&quot;click&quot;,function(){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(&quot;test button .....&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; });&lt;br&gt;&amp;nbsp; &amp;nbsp; });&lt;br&gt;});&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;遇到这种情况需要在每次绑定事件之前，对该事件解绑，也就是&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;$(“.test-btn”).off(“click”); //解除绑定点击事件&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;$(&quot;.test-btn&quot;).unbind(&quot;click&quot;);//移除绑定点击事件&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;$(&quot;.test-btn&quot;).unbind(); //移除所有绑定事件&lt;/p&gt;&lt;p&gt;/*&lt;/p&gt;&lt;p&gt;&amp;nbsp;可以的情况下，可以使用jquey的&amp;nbsp; $.click(function(){})，&lt;/p&gt;&lt;p&gt;*/&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;',0,'2017-08-10 00:00:00','22',37),(185,1,'JavaScript防抖和节流函数实现','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;background-color: rgb(255, 255, 255); color: rgb(255, 0, 0);&quot;&gt;防抖: 简单理解就是防止事件频繁的多次触发，n秒内多次触发事件，只执行第一次或最后一次操作&lt;/span&gt;&lt;/p&gt;&lt;pre style=&quot;background-color:#272822;color:#ffffff;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;div&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &amp;lt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;button &lt;/span&gt;&lt;span style=&quot;color:#9fd72c;&quot;&gt;id=&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;clickBtn&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&amp;gt;&lt;/span&gt;点击&lt;span style=&quot;color:#f9faf4;&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;button&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&amp;gt; &lt;/span&gt;点击次数：&lt;span style=&quot;color:#f9faf4;&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;span &lt;/span&gt;&lt;span style=&quot;color:#9fd72c;&quot;&gt;id=&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;clickNum&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;span&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;div&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;script&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&amp;gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;// n秒内多次触发事件，只执行最后一次操作 （n秒后才会执行，有延迟）&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;function &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-style:italic;&quot;&gt;debounce&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;fn&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;wait&lt;span style=&quot;color:#f9faf4;&quot;&gt;) {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#808080;font-style:italic;&quot;&gt;/* start 这个是闭包函数，页面在加载的时候，这部分内容会执行一次，之后每次点击触发的都是返回的函数体内容部分*/&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;font-style:italic;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;let &lt;/span&gt;timeout&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;console&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;log&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;timeout-&amp;gt;&amp;gt;00:&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+&lt;/span&gt;timeout&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#808080;font-style:italic;&quot;&gt;/* end */&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;font-style:italic;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;return function&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;() {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;console&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;log&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;timeout-&amp;gt;&amp;gt;01:&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+&lt;/span&gt;timeout&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;timeout&lt;span style=&quot;color:#f9faf4;&quot;&gt;) { &lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;//清除上次触发的定时器，重新计时；保证在N秒内多次点击只执行最后一次操作&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;                &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-style:italic;&quot;&gt;clearTimeout&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;timeout&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;console&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;log&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;timeout-&amp;gt;&amp;gt;02:&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+&lt;/span&gt;timeout&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;            &lt;/span&gt;timeout &lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-style:italic;&quot;&gt;setTimeout&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;fn&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;wait&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;//开启定时器&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;console&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;log&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;timeout-&amp;gt;&amp;gt;03:&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+&lt;/span&gt;timeout&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        }&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;function &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-style:italic;&quot;&gt;getClickNum&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;() {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;numText&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;innerText &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= ++&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;num&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;let &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;btn &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;document&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;querySelector&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;#clickBtn&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;    let &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;numText &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;document&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;querySelector&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;#clickNum&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;    let &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;num &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;btn&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;onclick &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-style:italic;&quot;&gt;debounce&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-style:italic;&quot;&gt;getClickNum&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;1000&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;//防抖处理 调用闭包函数（页面加载的时候会立即执行该函数的程序）&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;由于上面的防抖函数存在一个问题就是，每次点击的时候都会等待1秒后才会执行，不利于用户体验，所以我们可以把它改成，当用户第一次点击时立即执行，然后1秒钟之后才会再次执行&lt;/p&gt;&lt;pre style=&quot;background-color:#272822;color:#ffffff;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;// n秒内多次触发事件，只执行第一次 (立即触发执行)&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;function &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-style:italic;&quot;&gt;debounce&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;fn&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;wait&lt;span style=&quot;color:#f9faf4;&quot;&gt;) {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#808080;font-style:italic;&quot;&gt;/* start 这个是闭包函数，页面在加载的时候，这部分内容会执行一次，之后每次点击触发的都是返回的函数体内容部分*/&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;font-style:italic;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;let &lt;/span&gt;timeout&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;console&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;log&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;timeout-&amp;gt;&amp;gt;00:&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+&lt;/span&gt;timeout&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#808080;font-style:italic;&quot;&gt;/* end */&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#808080;font-style:italic;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;return function&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;() {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;console&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;log&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;timeout-&amp;gt;&amp;gt;01:&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+&lt;/span&gt;timeout&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;timeout&lt;span style=&quot;color:#f9faf4;&quot;&gt;) {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-style:italic;&quot;&gt;clearTimeout&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;timeout&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;let &lt;/span&gt;callNow &lt;span style=&quot;color:#f92772;&quot;&gt;= !&lt;/span&gt;timeout&lt;span style=&quot;color:#f92772;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;// 当定时器不存在时，取反为真，使得事件立即执行，&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;console&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;log&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;timeout-&amp;gt;&amp;gt;02:&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+&lt;/span&gt;callNow&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;// 已经执行过，不再执行&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;        &lt;/span&gt;timeout &lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-style:italic;&quot;&gt;setTimeout&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;function&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;() {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;            &lt;/span&gt;timeout &lt;span style=&quot;color:#f92772;&quot;&gt;= null;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;wait&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;        if &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;callNow&lt;span style=&quot;color:#f9faf4;&quot;&gt;){&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;console&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;log&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;timeout-&amp;gt;&amp;gt;03:&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+&lt;/span&gt;callNow&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;            &lt;/span&gt;fn&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    }&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b style=&quot;box-sizing: inherit; font-family: Poppins; font-size: 14px; color: rgb(255, 0, 0);&quot;&gt;节流: 事件频繁的触发，控制事件每隔N秒执行一次&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b style=&quot;box-sizing: inherit; font-family: Poppins; font-size: 14px; color: rgb(255, 0, 0);&quot;&gt;&lt;br&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b style=&quot;box-sizing: inherit; font-family: Poppins; font-size: 14px; color: rgb(255, 0, 0);&quot;&gt;&lt;/b&gt;&lt;/p&gt;&lt;pre style=&quot;background-color:#272822;color:#ffffff;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;//（第一次触发事件时立即执行，之后每隔N秒执行一次）&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;function &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-style:italic;&quot;&gt;throttle&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;fn&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;wait&lt;span style=&quot;color:#f9faf4;&quot;&gt;) {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;let &lt;/span&gt;timeout&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;console&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;log&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;timeout-&amp;gt;&amp;gt;00:&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+&lt;/span&gt;timeout&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;return function&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;() {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;//这里不需要清除定时器，清除的话达不到节流的效果&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;        //有定时器说明已有操作触发了执行函数，只有等n秒后，才能重新设置定时器执行函数，然后续操作继续等n秒，&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;timeout&lt;span style=&quot;color:#f9faf4;&quot;&gt;){&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;return false; &lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;// 直接返回false,使程序不往下执行，达到节流的作用&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;let &lt;/span&gt;callNow &lt;span style=&quot;color:#f92772;&quot;&gt;= !&lt;/span&gt;timeout&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;        &lt;/span&gt;timeout &lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-style:italic;&quot;&gt;setTimeout&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;function&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;() {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;            &lt;/span&gt;timeout &lt;span style=&quot;color:#f92772;&quot;&gt;= null;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;wait&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;        if&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;callNow&lt;span style=&quot;color:#f9faf4;&quot;&gt;) &lt;/span&gt;fn&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;// 不立即执行的设计&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;        // timeout = setTimeout(function() {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;        //     fn();&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;        //     timeout = null;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;        // }, wait);&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;function &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-style:italic;&quot;&gt;getClickNum&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;() {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;numText&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;innerText &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= ++&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;num&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;let &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;btn &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;document&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;querySelector&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;#clickBtn&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;let &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;numText &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;document&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;querySelector&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;#clickNum&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;let &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;num &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;btn&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;onclick &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;debounce&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-style:italic;&quot;&gt;getClickNum&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;1000&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;//节流处理 调用闭包函数（页面加载的时候会立即执行该函数的程序）&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;b style=&quot;box-sizing: inherit; color: rgb(87, 89, 98); font-family: Poppins; font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/b&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',0,'2019-07-25 00:00:00','22',105),(186,1,'浏览器缓存之HTTP缓存机制','','\n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Web 缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存。&lt;/p&gt;&lt;p&gt;浏览器缓存也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。这里我们只讨论 HTTP 缓存相关内容。&lt;/p&gt;&lt;p&gt;我们在访问一个网页时，使用F12打开network栏，可以看到有很多的HTTP请求，但是有两种请求和其它的请求不一样，一个是 size(from memory cache) 还有一个是状态码为304的请求；&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190726/2c8ab1f5c51f53f89f21e04f64004d38.png&quot; data-filename=&quot;img&quot; style=&quot;width: 827px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;缓存头部信息：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190726/d211669a7d78fb08a1d06f958f495535.png&quot; data-filename=&quot;img&quot; style=&quot;width: 511px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这两种请求都是使用了浏览器的缓存机制：强缓存和协商缓存机制，一般这种HTTP缓存主要用来缓存静态文件，比如：js/css/img等文件&lt;/p&gt;&lt;p&gt;强缓存和协商缓存区别：&lt;/p&gt;&lt;p&gt;1.强缓存：不会向服务端发起HTTP请求，而是直接从浏览器缓存区获取需要请求的数据，同时状态码直接返回200&lt;/p&gt;&lt;p&gt;2.协商缓：会向服务端发起HTTP请求，由服务端判断请求的文件是否被修改，如果未被修改，服务端不会返回数据，而是告诉浏览器可以直接使用缓存区的数据，并且返回304状态码&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;强缓存实现机制：&lt;/p&gt;&lt;p&gt;强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。&lt;/p&gt;&lt;p&gt;原理：&lt;/p&gt;&lt;p&gt;1.浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires或Cache-Control或同时存在，&lt;/p&gt;&lt;p&gt;2.浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Expires&lt;/b&gt;是HTTP1.0提出的，描述的是一个绝对时间，比如：Expires: Sun, 25 Aug 2019 01:25:49 GMT，然后使用客户端浏览器当前时间与之相比较，判断缓存是否过期。&lt;/p&gt;&lt;p&gt;但是Expires有一个不足的地方就是，一旦客户端随意更改时间，就会影响缓存的命中结果；&lt;/p&gt;&lt;p&gt;所以在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt; 表示：&lt;/span&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: rgb(255, 0, 0);&quot;&gt;（31536000 / 24 / 60 * 60）天&lt;/span&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;后过期&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，&lt;/p&gt;&lt;p&gt;再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Cache-Control&lt;/b&gt;描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。&lt;/p&gt;&lt;p&gt;这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires：&lt;/p&gt;&lt;p&gt;我们可以使用nginx和apache 作为web服务器，通过配置文件，可以配置expires和cache-control，&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;协商缓存&lt;/span&gt;&lt;/p&gt;&lt;p&gt;若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify（响应头）/If-Modify-Since（请求头）或Etag（响应头）/If-None-Match（请求头）来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。&lt;/p&gt;&lt;p&gt;Last-Modify/If-Modify-Since&lt;/p&gt;&lt;p&gt;1.浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。&lt;/p&gt;&lt;p&gt;2.当浏览器再次请求该资源时，发送的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果命中缓存，则返回http304，并且不会返回资源内容，并且不会返回Last-Modify。由于对比的服务端时间，所以客户端与服务端时间差距不会导致问题。但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化很快在一秒以内最后修改时间也可以一致）。于是出现了ETag/If-None-Match。&lt;/p&gt;&lt;p&gt;ETag/If-None-Match。&lt;/p&gt;&lt;p&gt;与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化*。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。&lt;/p&gt;&lt;p&gt;Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;注意：协商缓存需要配合强缓存使用，除了Last-Modified这个header，还有强缓存的相关header，因为如果不启用强缓存的话，协商缓存根本没有意义&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                            ',0,'2019-07-26 00:00:00','25,26',96),(187,1,' Redis实现分布式锁之正确的加锁解锁方式','','\n                                \n                                &lt;div&gt;&lt;b&gt;Redis分布式锁核心指令加锁和过期时间：&lt;/b&gt;加锁和设置锁的过期时间必须是一个完整的原子性操作&lt;/div&gt;&lt;div&gt;既然是锁，我们肯定需要一个解锁的过程，如果我们没有设置锁的过期时间，一旦一个客户端出现故障没来得及解锁的话，锁会一直存在，导致死锁。要是存在过期时间的话，redis会自动删除锁&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Redis加锁并设置过期时间指令：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;SET lock_name my_random_value NX PX 30000&lt;/pre&gt;&lt;p&gt;这个指令的含义是在键“lock_name”不存在时才设置键的值，到期时间为30秒，我们通过该命令就能实现加锁功能；如果“lock_name”存在则设置失败，通过这个我们&lt;/p&gt;&lt;p&gt;可以用来判断是否获取到锁；&lt;/p&gt;&lt;ul&gt;&lt;li&gt;lock_name，即分布式锁的名称，对于 Redis 而言，lock_name 就是 Key-Value 中的 Key且具有唯一性。&lt;/li&gt;&lt;li&gt;my_random_value，由客户端生成的一个随机字符串，它要保证在足够长的一段时间内，且在所有客户端的所有获取锁的请求中都是唯一的，用于唯一标识锁的持有者。（&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;这个唯一标识用于后续执行解锁操作用。&lt;/span&gt;）&lt;/li&gt;&lt;li&gt;NX 表示只有当 lock_name(key) 不存在的时候才能 SET 成功，从而保证只有一个客户端能获得锁，而其它客户端在锁被释放之前都无法获得锁。&lt;/li&gt;&lt;li&gt;PX 30000 表示这个锁节点有一个 30 秒的自动过期时间（目的是为了防止持有锁的客户端故障后，无法主动释放锁而导致死锁，因此要求锁的持有者必须在过期时间之内执行完相关操作并释放锁）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里对该命令做一个较为详细的讲解。&lt;/p&gt;&lt;p&gt;命令格式：&amp;nbsp;&lt;/p&gt;&lt;p&gt;SET KEY VALUE&amp;nbsp; [NX|XX]&amp;nbsp; [EX seconds] [PX milliseconds]&lt;/p&gt;&lt;ul&gt;&lt;li&gt;EX seconds − 设置到期时间(秒为单位)。&lt;/li&gt;&lt;li&gt;PX milliseconds - 设置到期时间(毫秒为单位)。&lt;/li&gt;&lt;li&gt;NX - 仅在键不存在时设置键。&lt;/li&gt;&lt;li&gt;XX - 只有在键已存在时才设置。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们的目的在于使锁具有互斥性，因此采用NX参数， 仅在锁不存在时才能设置锁成功。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;Redis分布式锁错误的加锁方式：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;Jedis jedis = jedisPool.getResource();&lt;br&gt;// 如果锁不存在则进行加锁&lt;br&gt;Long lockResult = jedis.setnx(lockName, myRandomValue);&lt;br&gt;if (lockResult == 1) {&lt;br&gt;&amp;nbsp; &amp;nbsp; // 设置锁过期时间，加锁和设置过期时间是两步完成的，非原子操作&lt;br&gt;&amp;nbsp; &amp;nbsp; jedis.expire(lockName, expireTime);&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;setnx() 方法的作用就是 SET IF NOT EXIST，expire() 方法就是给锁加一个过期时间。 加锁实际上使用了两条 Redis 命令，这个组合操作是非原子性的。&lt;/p&gt;&lt;p&gt;究其原因，还是因为setNx本身虽然能够保证设置值的原子性，但它与expire组合使用，整个操作（加锁并设置过期时间）便不是原子的，隐藏了死锁风险。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;java 加锁代码&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;public class RedisTool {&lt;br&gt;&amp;nbsp; &amp;nbsp; private static final String LOCK_SUCCESS = &quot;OK&quot;;&lt;br&gt;&amp;nbsp; &amp;nbsp; private static final String SET_IF_NOT_EXIST = &quot;NX&quot;;&lt;br&gt;&amp;nbsp; &amp;nbsp; private static final String SET_WITH_EXPIRE_TIME = &quot;PX&quot;;&lt;br&gt;&amp;nbsp; &amp;nbsp; /**&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* 尝试获取分布式锁&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* @param jedis Redis客户端&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* @param lockKey 锁&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* @param requestId 请求标识&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* @param expireTime 超期时间&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* @return 是否获取成功&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;*/&lt;br&gt;&amp;nbsp; &amp;nbsp; public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (LOCK_SUCCESS.equals(result)) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return true;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return false;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(165, 74, 123);&quot;&gt;注：我们传的是requestId，有key作为锁不就够了吗，为什么还要用到value？原因就是通过给value赋值为requestId，我们就知道这把锁是哪个客户端加的锁了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;正确的解锁方式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1.通过Lua脚本执行解锁&lt;/p&gt;&lt;p&gt;Lua脚本实现的解锁代码；&lt;/p&gt;&lt;pre&gt;String script = &quot;if redis.call(\'get\', KEYS[1]) == ARGV[1]&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;then return redis.call(\'del\', KEYS[1])&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;else return 0&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;end&quot;;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们通过 Redis 的 eval() 函数执行 Lua 脚本，其中入参 lockName 赋值给参数 KEYS[1]，锁的具体值赋值给 ARGV[1]，eval() 函数将 Lua 脚本交给 Redis 服务端执行。首先获取锁对应的value值，检查是否与传入的值&amp;nbsp;相等，如果相等则删除锁（解锁）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;根据Redis官网文档的解释，通过 eval() 执行 Lua 代码时，Lua 代码将被当成一个命令去执行（可保证原子性），并且直到 eval 命令执行完成，Redis 才会执行其他命令。因此，通过 Lua 脚本结合eval函数，可以科学得实现解锁操作的原子性，避免误解锁。&lt;/p&gt;&lt;p&gt;&amp;nbsp;利用Jedis实现的Java版本代码如下：&lt;/p&gt;&lt;pre&gt;Long unlock = 1L;&lt;br&gt;Jedis jedis = null;&lt;br&gt;// Lua脚本，用于校验并释放锁&lt;br&gt;String script = &quot;if redis.call(\'get\', KEYS[1]) == ARGV[1]&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; then return redis.call(\'del\', KEYS[1])&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; else&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return 0 end&quot;;&lt;br&gt;try {&lt;br&gt;&amp;nbsp; &amp;nbsp; jedis = jedisPool.getResource();&lt;br&gt;&amp;nbsp; &amp;nbsp; // 通过 Redis 的 eval() 函数执行 Lua 脚本，&lt;br&gt;&amp;nbsp; &amp;nbsp; // 入参 lockName 赋值给参数 KEYS[1]，myRandomValue 赋值给 ARGV[1]，&lt;br&gt;&amp;nbsp; &amp;nbsp; // eval() 函数将 Lua 脚本交给 Redis 服务端执行。&lt;br&gt;&amp;nbsp; &amp;nbsp; Object result =&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; jedis.eval(script,&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Collections.singletonList(lockName),&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Collections.singletonList(myRandomValue));&lt;br&gt;&amp;nbsp; &amp;nbsp; // 注意:如果脚本顺利执行将返回1，&lt;br&gt;&amp;nbsp; &amp;nbsp; // 如果执行脚本时，其它的客户端对这个lockName对应的值进行了更改&lt;br&gt;&amp;nbsp; &amp;nbsp; // 则返回0&lt;br&gt;&amp;nbsp; &amp;nbsp; if (unlock.equals(result) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return true;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;br&gt;catch (Exception e) {&lt;br&gt;&amp;nbsp; &amp;nbsp; throw e;&lt;br&gt;}&lt;br&gt;finally {&lt;br&gt;&amp;nbsp; &amp;nbsp; if (null != jedis) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; jedis.close();&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;br&gt;return false;&lt;/pre&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;错误解锁方式1：&lt;/span&gt;&lt;/div&gt;&lt;pre&gt;&amp;nbsp;jedis.del(lockKey);&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;直接使用jedis.del()方法删除锁，这种不先判断锁的拥有者而直接解锁的方式，会导致任何客户端都可以随时进行解锁，即使这把锁不是它的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;错误解锁方式2：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;// 判断加锁与解锁是不是同一个客户端&lt;br&gt;if (requestId.equals(jedis.get(lockKey))) {&lt;br&gt;&amp;nbsp; &amp;nbsp; // 若在此时，这把锁突然不是这个客户端的，则会误解锁&lt;br&gt;&amp;nbsp; &amp;nbsp; jedis.del(lockKey);&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;由于上面分两步执行可能会存在删除别人加的锁;&lt;/p&gt;&lt;p&gt;比如：客户端A加锁，一段时间之后客户端A解锁，在执行jedis.del()之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了。&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;font color=&quot;#a54a7b&quot;&gt;如果Redis是主从模式部署的，那么可以尝试使用Redisson实现分布式锁，&lt;/font&gt;&lt;br&gt;&lt;/p&gt;\n                                                                                                                    ',0,'2019-07-27 00:00:00','16',112),(188,1,'消息中间件的常见使用场景','','&lt;div&gt;&lt;b&gt;一、异步处理&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 对于用户来说并不需要立即知道结果的业务操作，为了提升用户体验，我们可以采用异步的方式处理后续的操作。比如：用户注册业务，我们需要注册完成后&lt;/div&gt;&lt;div&gt;给用户发邮件和短信提醒。而其中的发邮件和发短信操作我们并不需要直接给用户反馈结果，我们可以把这部分交给消息中间件来异步处理，缩短整个操作返回结果的时间。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;用户注册（50ms），还需发送邮件（50ms）和短信（50ms）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;串行：（150ms）用户注册—》发送邮件----》发送短信&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;并行（100ms）：用户注册—》发送邮件| ----》发送短信&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;上面的操作我们都需要100多ms才给用户返回操作结果，而我们使用消息中间件&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;消息中间件（56ms）：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;用户注册（50ms）—》（6ms）消息中间件 【发送邮件 - 发送短信】&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;只要用户注册完成并且将关键的数据写入到中间件那么我们整个注册就算完成了，而发送邮件、发送短信后续可以异步处理。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;说明：一个用户注册流程，包含下述业务：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1.&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 注册处理以及写数据库、&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 发送注册成功的手机短信&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 发送注册成功的邮件信息&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;我们使用老方法的话，则会注册完执行发送短信再执行邮件发送。太low&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;一般使用的是：在注册成功后，使用两个线程去做发送邮件，发送短信操作。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果用消息中间件：则将两个线程创建这些事情省了，直接发送消息给消息中间件，然后让邮件服务和短信服务自己去消息中间件里面去取消息，然后取到消息后再自己做对应的业务操作。就是这么方便&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;二、应用的解耦&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;a)&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 订单系统---》库存系统（强耦合）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;b)&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;消息中间件：订单系统---》消息中间件《----库存系统（解耦）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;说明：用户购买一笔订单，订单成交—》调用库存系统—1---》返回给订单系统，此时算一个正常业务。还有不正常的业务，就是用户订单完成后，订单系统并不去滴啊用库存系统-1操作，而是调用消息中间件，写入一个订单信息。又库存系统自己去消息中间件上去获取，然后更新库存，这样能够减少互联网型应用追求的快这一个属性。而库存系统读取订单间库存其实这个操作也是非常快的，所以有消息中间件对解耦来说也是一个不错的方向。&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;三、流量的削峰&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;a)&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 用户请求-----》秒杀应用&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;b)&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 应用的前端加入消息队列&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;c)&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 用户请求-----》消息队列《----秒杀应用&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;说明：比如，系统举行秒杀活动，热门商品。流量蜂拥而至 100件商品，10万人挤进来怎么办，10万秒杀的操作，放入消息队列。秒杀应用处理消息队列中的10万个请求中的100个，其他的打回，通知失败。流量峰值控制在消息队列处，秒杀应用不会瞬间被怼死.&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\n                                                            ',0,'2018-02-01 00:00:00','23,34',33),(189,1,'RabbitMQ概念详解','','\n                                &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/bestmy/article/details/84304964&quot;&gt;RabbitMQ概念详解&lt;/a&gt;\n                                                            &lt;/p&gt;                            ',0,'2018-12-06 00:00:00','39',59),(190,1,'setTimeout延时0毫秒的作用','','\n                                &lt;div&gt;很多人认为setTimeout延时0毫秒时，会立即执行，其实事实上并不是的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;我们都知道javascript是单线程处理任务的，而setTimeout是异步事件，当javascript引擎遇到异步事件时会将其放到队列里，而不是立刻执行；javascript执行完同步的任务之后，再执行setTimeout队列中积累的任务。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;所以下面代码输出的顺序为：2、1&lt;/div&gt;&lt;pre&gt;&lt;br&gt;setTimeout(function(){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;console.log(&quot;1&quot;);&lt;br&gt;})&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;console.log(&quot;2&quot;);&lt;/pre&gt;&lt;p&gt;这样我们可以改变程序执行顺序&lt;/p&gt;&lt;p&gt;找的一张图很好的说明了这个问题：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20190801/7442dbf865e8f5d4c5832b8ae9dd134e.png&quot; data-filename=&quot;img&quot; style=&quot;width: 695px;&quot;&gt;&lt;br&gt;&lt;/p&gt;\n                                                                                        ',0,'2019-08-01 00:00:00','22',84),(191,1,'关于javascript中的call方法和apply方法','','\n                                \n                                \n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(0, 0, 255);&quot;&gt;call:方法能劫持另外一个对象的方法，继承另外一个对象的属性.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(0, 0, 255);&quot;&gt;Function.call(obj,[param1[,param2[,…[,paramN]]]])&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(0, 0, 255);&quot;&gt;obj：这个对象将代替Function类里this对象&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(0, 0, 255);&quot;&gt;params：这个是一个参数列表&amp;nbsp; （有多个参数）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;call有两个妙用：&lt;/p&gt;&lt;p&gt;1: 继承。(ES6之前类的继承法，)&lt;/p&gt;&lt;p&gt;2: 修改函数运行时的this指针。&lt;/p&gt;&lt;p&gt;在这里不想讨论call的继承，因为ES6已经有很好的类继承extends了。现在说说call的另外一个用处，改变函数运行时this的指向问题&lt;/p&gt;&lt;p&gt;定义一个函数：&lt;/p&gt;&lt;pre&gt;function a() {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;this.addr = &quot;shenzhen&quot;;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;this.weight&amp;nbsp; = &quot;65KG&quot;;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;console.log(&quot;this a fun&quot;);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;console.log(this); // 指向window&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;一般我们调用一个函数直接是&amp;nbsp;&lt;/p&gt;&lt;p&gt;a()&amp;nbsp; 或者使用call： a.call();这样来调用。&amp;nbsp;&lt;/p&gt;&lt;p&gt;上面的方式调用函数，此时的this都是指向的全局对象：window&lt;/p&gt;&lt;p&gt;但是如果我们想要改变里面的this指向怎么办呢？&lt;/p&gt;&lt;p&gt;我们可以使用call的第一个参数，它可以作为当前对象的替代对象。也就是说上面的a()调用，是当前对象window对象在调用它，我们可以使用call&lt;/p&gt;&lt;p&gt;的第一个参数作为当前对象（即window的替代对象）&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;注意：this的作用域不是定义它的函数的作用域，而是执行时的作用域。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们使用创建对象的方式来说明这个问题：&lt;/p&gt;&lt;pre&gt;function a(t01,t02) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;this.addr = &quot;shenzhen&quot;;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;this.weight&amp;nbsp; = &quot;65KG&quot;;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;console.log(&quot;t01----&amp;gt;&quot;+t01)&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;console.log(&quot;myname from b:&quot;+this.myname);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;console.log(this);&lt;br&gt;}&lt;br&gt;function b() {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;this.myname = &quot;i am b&quot;;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;this.age&amp;nbsp; = &quot;i am 20 years old&quot;;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;a.call(this,&quot;testArg01&quot;,&quot;testArg02&quot;);&amp;nbsp; //通过call在b区域内调用a函数，此时a中的this指的是b对象&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;// a();&amp;nbsp; // 通过这样的方式调用a函数的话 a中的this还是指向window对象&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;console.log(&quot;addr from a:&quot;+this.addr);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;console.log(this);&lt;br&gt;}&lt;br&gt;var bOcjec = new b();&lt;/pre&gt;&lt;p&gt;在b函数中我们通过call来调用a函数，改变了a中的this指向，这样做的好处可以看出，我们可以在a函数内部通过this调用b对象的属性。&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;同时b对象也间接的继承了a的所有属性&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;&amp;nbsp;b{myname: &quot;i am b&quot;, age: &quot;i am 20 years old&quot;, addr: &quot;shenzhen&quot;, weight: &quot;65KG&quot;}&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;一般我们在调用函数时，如果是这样的形势调用 ：a()&amp;nbsp; 其实真实的调用是这样的：Window.a() , 所以函数内部的this指向的是：谁调用函数执行，那么它的内部this指的就是谁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;当call或apply的第一个参数为null || undefined时 this指向window ||global（nodejs）&lt;/b&gt;&lt;br&gt;&lt;/p&gt;&lt;pre&gt;function test() {&lt;br&gt;     console.log(this);&lt;br&gt;}&lt;br&gt;test.call(1); // this指向 Number对象&lt;br&gt;test.call(\'a\'); // this指向 String对象&lt;br&gt;test.call();&amp;nbsp; // this指向 Window对象&lt;/pre&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(66, 66, 66); background-color: rgb(255, 255, 255); font-weight: bold;&quot;&gt;apply:和call的意思一样,只不过是参数列表不一样.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(66, 66, 66); background-color: rgb(255, 255, 255);&quot;&gt;Function.apply(obj,args)方法能接收两个参数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(66, 66, 66); background-color: rgb(255, 255, 255);&quot;&gt;obj：这个对象将代替Function类里this对象&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(66, 66, 66); background-color: rgb(255, 255, 255);&quot;&gt;args：这个是数组，它将作为参数一次性把所有的参数传给Function（args--&amp;gt;arguments）&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;/*定义一个人类*/&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;function Person(name,age)&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;{&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;&amp;nbsp; &amp;nbsp; this.name=name;&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;&amp;nbsp; &amp;nbsp; this.age=age;&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;}&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;/*定义一个学生类*/&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;functionStudent(name,age,grade)&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;{&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;&amp;nbsp; &amp;nbsp; Person.apply(this,arguments);&amp;nbsp;&amp;nbsp;//&lt;/span&gt;arguments:是一个数组,也就是[“zhangsan”,”21”,”一年级”]; &lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;这就是与call在传参上的不同之处&lt;/span&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;&amp;nbsp; &amp;nbsp; this.grade=grade;&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;}&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;//创建一个学生类&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;var student=new Student(&quot;zhangsan&quot;,21,&quot;一年级&quot;);&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;//测试&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;alert(&quot;name:&quot;+student.name+&quot;\\n&quot;+&quot;age:&quot;+student.age+&quot;\\n&quot;+&quot;grade:&quot;+student.grade);&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;//大家可以看到测试结果name:zhangsan age:21&amp;nbsp; grade:一年级&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;什么情况下用apply,什么情况下用call&lt;/span&gt;&lt;/p&gt;&lt;p&gt;其实两者的用处基本上是一样的，只不过是在传递参数时，看哪个更加方便快捷的传递参数给被调用的函数&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;比如apply示例里面传递了参数arguments,这个参数是数组类型,并且在调用Person的时候参数的列表是对应一致的(也就是Person和Student的参数列表前两位是一致的) 就可以采用 apply , 如果我的Person的参数列表是这样的(age,name),而Student的参数列表是(name,age,grade),这样就可以用call来实现了,也就是直接指定参数列表对应值的位置(Person.call(this,age,name,grade));&lt;/p&gt;&lt;p&gt;注：虽然apply在参数传递的时候是以一个数组的形式传递的，但是它内部做了一个转换，就是运行的时候把数组分解成一个个参数 [param1,param2,param3] 转换为 param1,param2,param3 。这样的话被调用的函数就可以根据参数的位置&lt;/p&gt;&lt;p&gt;获取对应的值；&lt;/p&gt;&lt;p&gt;apply的妙用：&lt;/p&gt;&lt;p&gt;1.比如：Math.max 实现得到数组中最大或最小的一项&lt;/p&gt;&lt;p&gt;因为Math.max 参数里面不支持Math.max([param1,param2]) 也就是数组&lt;/p&gt;&lt;p&gt;那么这个时候我们就可以使用apply来实现&amp;nbsp; &amp;nbsp;var max=Math.max.apply(null,array), // 第一个参数为null ,那么max函数运行时，内部的this指的就是window&lt;/p&gt;&lt;p&gt;2.Array.prototype.push 可以实现两个数组合并&lt;/p&gt;&lt;p&gt;同样push方法没有提供push一个数组,但是它提供了push(param1,param,…paramN) 所以同样也可以通过apply来装换一下这个数组,即:&lt;/p&gt;&lt;pre&gt;vararr1=new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);&amp;nbsp;&amp;nbsp;&lt;br&gt;vararr2=new Array(&quot;4&quot;,&quot;5&quot;,&quot;6&quot;);&amp;nbsp;&amp;nbsp;&lt;br&gt;Array.prototype.push.apply(arr1,arr2);&lt;/pre&gt;&lt;p&gt;arr1调用了push方法,然后将arr2作为参数通过apply将数组装换为参数列表的集合.&amp;nbsp;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                                                                                    ',0,'2019-08-03 00:00:00','22',116),(192,1,'javascript作用域以及作用域链是什么？','','\n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;作用域：我们可以简单的理解为作用域就是变量或者函数可以被访问到的地方。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;作用域我们可以分为：全局作用域和局部作用域&amp;nbsp;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们定义的全局变量所在的作用域就是全局作用域，而我们在函数内部定义的局部变量所在的作用域就是局部作用域&lt;/p&gt;&lt;p&gt;代码讲解：&lt;/p&gt;&lt;pre&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;br&gt;var a = 1;&lt;br&gt;function fn() {&lt;br&gt;    var&amp;nbsp; b = 2;&lt;br&gt;    console.log(b); console.log(a);&lt;br&gt;}&lt;br&gt;console.log(a) // 1&lt;br&gt;console.log(b) // b is not defined&lt;br&gt;fn() // 2 1&lt;br&gt;&amp;lt;/script&amp;gt;&amp;nbsp;&lt;/pre&gt;&lt;p&gt;从上面的输出结果可以看出来，由于a是全局变量所以它的作用域是全局的，即在任何地方都可以被访问到。然而，b变量是定义在函数内部的，即它是一个局部变量；它的作用域是局部作用域只能是在函数内部才能被访问到&lt;/p&gt;&lt;p&gt;&lt;b&gt;变量声明被提升：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;JavaScript并不像其它语言一样，需要先定义在使用，有时候我们先使用在定义也不会报错，这就是js在编译期会把变量声明提升到&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;当前作用域的顶部，&lt;/span&gt;记住是当前作用域顶部 （&lt;span style=&quot;color: rgb(0, 0, 255);&quot;&gt;在ES6之后有了新的定义指令let和const 不存在被提升&lt;/span&gt;）&lt;/p&gt;&lt;p&gt;在讲解这个之前我们先来了解一下&amp;nbsp;&amp;nbsp;undefined 和&amp;nbsp; xxx&amp;nbsp;is not defined 它们说明了什么：&lt;/p&gt;&lt;p&gt;（使用var 或则 let 、const都说明了变量被声明了）&lt;/p&gt;&lt;p&gt;undefined ：变量有声明但是没有赋值，直接使用会提示undefined&lt;/p&gt;&lt;p&gt;xxx&amp;nbsp;is not defined ： 变量没有声明并且也没有赋值，直接使用会提示 is not defined&amp;nbsp;&lt;br&gt;&lt;/p&gt;&lt;p&gt;代码讲解：&lt;/p&gt;&lt;pre&gt;console.log(a) // undefined&lt;br&gt;var a = 1;&lt;br&gt;console.log(b) // Uncaught ReferenceError: b is not defined&lt;/pre&gt;&lt;p&gt;根据上面对 undefined 和 xxx&amp;nbsp;is not defined 的解释，我们首先打印了a 再声明a变量，但是并没有报错而是提示undefined。这就说明了a的声明被提升了。上面的代码在编译期是这样运行的：&lt;/p&gt;&lt;pre&gt;var a;&lt;br&gt;console.log(a) // undefined&lt;br&gt;a = 1;&lt;br&gt;console.log(b) // Uncaught ReferenceError: b is not defined&lt;/pre&gt;&lt;p&gt;从上面代码可以看出，变量声明被提升，但是它的逻辑处理和赋值是原地不动的。所以a打印出来的时候a没有被赋值，&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;那么变量声明提升到当前作用域的顶部又是什么呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;首先我们可以来看下面的代码：&lt;/p&gt;&lt;pre&gt;var a = 1;&lt;br&gt;function&amp;nbsp; fn() {&lt;br&gt;    console.log(a) // undefinde&lt;br&gt;    var a = 2;&lt;br&gt;}&lt;br&gt;fn()&amp;nbsp;&lt;/pre&gt;&lt;p&gt;上面的输出结果是不是很意外呢？因为我们在外边定义了一个全局的变量a,说明它在任何地方都可以被访问到，但是为什么我们这里会显示undefined 也就是变量有声明但是没有赋值呢？&lt;/p&gt;&lt;p&gt;这里我们首先要搞清楚另外一个概念，就是同名变量被覆盖的问题。我们在函数外边定义了一个变量，但是在函数内部我们也定义了一个同名的变量的时候，在函数内部使用变量过的时候我们会用拿取内部的值不会去拿外边的那个值：&lt;/p&gt;&lt;pre&gt;var a = 1;&lt;br&gt;function&amp;nbsp; fn() {&lt;span style=&quot;white-space:pre&quot;&gt;&lt;br&gt;&lt;/span&gt;    var a = 2;&lt;br&gt;    console.log(a) // 2&lt;br&gt;}&lt;br&gt;fn()&amp;nbsp;&lt;/pre&gt;&lt;p&gt;搞清楚这个问题后我们再来看下刚刚讨论的那个问题，&lt;/p&gt;&lt;pre style=&quot;line-height: 1.42857;&quot;&gt;var a = 1;&lt;br&gt;function&amp;nbsp; fn() {&lt;br&gt;    console.log(a) // undefinde&lt;br&gt;    var a = 2;&lt;br&gt;}&lt;br&gt;fn()&amp;nbsp;&lt;/pre&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;为什么会输出undefined呢，而不是1呢？因为我们刚刚说了js在编译期的时候会把变量声明提升到当前作用域的顶部。而在fn函数内部（即当前作用域）我们有声明变量a,所以它会被提示到fn函数内部的顶部，编译时代码是这样的：&lt;/p&gt;&lt;pre style=&quot;line-height: 1.42857;&quot;&gt;var a = 1;&lt;br&gt;function&amp;nbsp; fn() {&lt;br&gt;    var a&lt;br&gt;    console.log(a) // undefined&lt;br&gt;&amp;nbsp; &amp;nbsp; a = 2;&lt;br&gt;}&lt;br&gt;fn()&amp;nbsp;&lt;/pre&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;作用域链是什么？&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;因为作用域它是一个包含的关系，即作用域里面可以有子作用域、孙子作用域等等以此类推。我们可以把全局作用域当成是最顶级的作用域A，它里面可以定义函数，函数内部也是一个作用域B，这个作用域我们可以理解外全局作用域的子作用域，而函数内部我们又可以定义一个函数，此时该函数内部的作用域C可以理解成是B作用域的子作用域，是A作用域的孙子作用域。&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;img src=&quot;/upload/article/20190804/1c42dc6d2391a096af17df01205fba7b.png&quot; data-filename=&quot;img&quot; style=&quot;width: 565px;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;而这样的作用域包含关系，它有一个特点就是下级作用域可以向它的上级作用域拿取它想要的值（也就是说C作用域想获取一个变量a的值，但是在该作用域没有找到想要的值它会向上一级去找，上一级没有会接着往上一级的上一级找，直到找到为止，但是如果在顶级作用域还没有找到的话就会抛出错误提示），&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;img src=&quot;/upload/article/20190804/fcdbc5c44a315cb8b2bdff45cc97d2d1.png&quot; data-filename=&quot;img&quot; style=&quot;width: 548px;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;同时我们还需要知道的是，上级作用域的所有值对于下级作用域来说都是可见的，即下级作用域可以访问到上级作用域的变量。&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;但是上级作用域是不能访问到下级作用域的值的&amp;nbsp; ，可以理解成冒泡只能向上冒不能向下冒&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;根据作用域的特点，我们这里引入一个新的js特性就是：&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;闭包&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;我们首先知道闭包有3个特性：&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;①函数嵌套函数&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;②函数内部可以引用函数外部的参数和变量&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;③参数和变量不会被垃圾回收机制回收&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;注：同级作用域内部的数据是不能相互访问的。&lt;br&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;根据作用域链的特点，我们要想在外部作用域访问到内部的作用域即（A访问B内部的数据或则 C内部的数），怎么办呢？&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;我们就可以利用闭包来实现：&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;匿名函数作为闭包函数来返回值&lt;/p&gt;&lt;pre style=&quot;line-height: 1.42857;&quot;&gt;function&amp;nbsp; fn() {&lt;br&gt;    var a = 1;&lt;br&gt;    return function() {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;return a;&lt;br&gt;    }&lt;br&gt;}&lt;br&gt;var b = fn();&lt;br&gt;console.log(b()) // 1     这样我们就可以在外部获取到fn作用域的值&lt;/pre&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;闭包还有一个作用就是局部变量常驻内存&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;我们都知道js变量生命周期是，当函数运行完后，内部的变量就是被销毁，但是我们利用闭包就可以实现局部变量常驻内存，但同时也消耗了内存&lt;/p&gt;&lt;pre style=&quot;line-height: 1.42857;&quot;&gt;function&amp;nbsp; fn() {&lt;br&gt;   var a = 1;&amp;nbsp;&amp;nbsp;&lt;br&gt;   return function() {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;var&amp;nbsp; a2 = 0;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;console.log(++a)&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;console.log(++a2)&lt;br&gt;   }&lt;br&gt;}&lt;br&gt;var b = fn();&lt;br&gt;b() // 2&amp;nbsp; 1&lt;br&gt;b() // 3&amp;nbsp; 1&lt;/pre&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;我们调用fn()返回一个闭包函数 赋值给b,此时b相当于：&lt;/p&gt;&lt;pre style=&quot;line-height: 1.42857;&quot;&gt;var b = function() {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;    var&amp;nbsp; a2 = 0;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;    console.log(++a)&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;    console.log(++a2)&lt;br&gt;       }&lt;/pre&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;这样我们调用b()每次执行的时候都是执行闭包函数内部的程序，此时的a不会被销毁。&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;闭包函数有好处也有坏，所以需要谨慎使用。&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                            ',0,'2019-08-04 00:00:00','22',104),(193,1,'如何生成SSH公钥 id_rsa? ','','\n                                &lt;p&gt;&amp;nbsp;有时候我们连接FTP登入服务端时，需要客户端提供ssh的公钥id_rsa,我们可以借用git客户端通过命令来生成，首先确保本地电脑已经安装过git&lt;/p&gt;&lt;p&gt;第一步：打开git命令窗口&lt;/p&gt;&lt;p&gt;输入命令：&lt;/p&gt;&lt;pre&gt;ssh-keygen -t rsa -C &quot;12*****41@qq.com&quot;&lt;/pre&gt;&lt;div&gt;然后一直回车enter就可以&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190805/e395f593d9a46b6dfee2e8c048b7df7e.png&quot; data-filename=&quot;img&quot; style=&quot;width: 543px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;然后默认会在C盘的 /c/Users/ftswj/.ssh/目录下生成id_rsa&amp;nbsp; 和 id_rsa.pub&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgba(0, 0, 0, 0.75); font-family: &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, Roboto, Noto, Arial, &amp;quot;PingFang SC&amp;quot;, sans-serif; font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;将客户端的公钥文件id_rsa中的内容添加到linux的&amp;nbsp;&lt;/span&gt;&lt;code style=&quot;outline: 0px; margin: 0px; font-family: &amp;quot;Source Code Pro&amp;quot;, &amp;quot;DejaVu Sans Mono&amp;quot;, &amp;quot;Ubuntu Mono&amp;quot;, &amp;quot;Anonymous Pro&amp;quot;, &amp;quot;Droid Sans Mono&amp;quot;, Menlo, Monaco, Consolas, Inconsolata, Courier, monospace, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, sans-serif; font-size: 14px; line-height: 22px; border-radius: 2px; overflow-wrap: break-word; font-variant-ligatures: common-ligatures; white-space: normal;&quot;&gt;vim /root/.ssh/authorized_keys&lt;/code&gt;&lt;span style=&quot;color: rgba(0, 0, 0, 0.75); font-family: &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, Roboto, Noto, Arial, &amp;quot;PingFang SC&amp;quot;, sans-serif; font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgba(0, 0, 0, 0.75); font-family: &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, Roboto, Noto, Arial, &amp;quot;PingFang SC&amp;quot;, sans-serif; font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;然后在修改一下配置文件&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgba(0, 0, 0, 0.75); font-family: &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, Roboto, Noto, Arial, &amp;quot;PingFang SC&amp;quot;, sans-serif; font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;vim /etc/ssh/sshd_config&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;color: rgba(0, 0, 0, 0.75); font-family: &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, Roboto, Noto, Arial, &amp;quot;PingFang SC&amp;quot;, sans-serif; font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgba(0, 0, 0, 0.75); font-family: &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, Roboto, Noto, Arial, &amp;quot;PingFang SC&amp;quot;, sans-serif; font-size: 16px; font-variant-ligatures: common-ligatures;&quot;&gt;把PubkeyAuthentication这一配置设为 yes 表示允许使用基于密钥认证的方式登录。&lt;/span&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                            ',0,'2018-02-01 00:00:00','32',48),(194,1,'Visual Studio Code安装ftp插件，连接远程服务器','','\n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Visual Studio Code 可以说是目前最受欢迎的轻量级代码编辑器了。而且有各种插件可以使用，安装起来很方便。&lt;/div&gt;&lt;div&gt;通过vscode安装ftp扩展，我们可以很容易的实现，本地文件同步到远程服务器上。这样的话极大的方便了我们可以在本地开发，然后同步到linux服务器进行测试。&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;1.首先打开编辑器的应用商店，搜索sftp (目前下载的人数最多)，直接点击安装即可；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2. 通过快捷键 Ctrl+Shift+p 调出搜索框，输入 &amp;gt;SFTP:Config 回车打开配置文件 sftp.json ；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;该文件一般在当前导入的项目文件夹中.vscode文件夹中自动生成的文件&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;color: rgb(248, 248, 242); background-color: rgb(39, 40, 34); font-family: Consolas, &amp;quot;Courier New&amp;quot;, monospace; font-size: 14px; line-height: 19px; white-space: pre;&quot;&gt;&lt;div&gt;{&lt;/div&gt;&lt;div&gt;    &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span style=&quot;color: #cfcfc2;&quot;&gt;&quot;aliyun Server&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div&gt;    &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;&quot;host&quot;&lt;/span&gt;: &lt;span style=&quot;color: #cfcfc2;&quot;&gt;&quot;*****&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div&gt;    &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;&quot;protocol&quot;&lt;/span&gt;: &lt;span style=&quot;color: #cfcfc2;&quot;&gt;&quot;sftp&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div&gt;    &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;&quot;port&quot;&lt;/span&gt;: &lt;span style=&quot;color: #ae81ff;&quot;&gt;22&lt;/span&gt;,&lt;/div&gt;&lt;div&gt;    &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;&quot;username&quot;&lt;/span&gt;: &lt;span style=&quot;color: #cfcfc2;&quot;&gt;&quot;***&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div&gt;    &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;&quot;password&quot;&lt;/span&gt;: &lt;span style=&quot;color: #cfcfc2;&quot;&gt;&quot;****&quot;&lt;/span&gt;,&lt;/div&gt;&lt;br&gt;&lt;div&gt;    &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;&quot;remotePath&quot;&lt;/span&gt;: &lt;span style=&quot;color: #cfcfc2;&quot;&gt;&quot;/home/ftpuser&quot;&lt;/span&gt;,  &lt;/div&gt;&lt;div&gt;    &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;&quot;uploadOnSave&quot;&lt;/span&gt;: &lt;span style=&quot;color: #ae81ff;&quot;&gt;false&lt;/span&gt;,&lt;/div&gt;&lt;br&gt;&lt;div&gt;    &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;&quot;watcher&quot;&lt;/span&gt;: {&lt;/div&gt;&lt;div&gt;        &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;&quot;files&quot;&lt;/span&gt;: &lt;span style=&quot;color: #cfcfc2;&quot;&gt;&quot;**/*&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div&gt;        &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;&quot;autoUpload&quot;&lt;/span&gt;: &lt;span style=&quot;color: #ae81ff;&quot;&gt;false&lt;/span&gt;,&lt;/div&gt;&lt;div&gt;        &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;&quot;autoDelete&quot;&lt;/span&gt;: &lt;span style=&quot;color: #ae81ff;&quot;&gt;false&lt;/span&gt;&lt;/div&gt;&lt;div&gt;    },&lt;/div&gt;&lt;br&gt;&lt;div&gt;    &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;&quot;ignore&quot;&lt;/span&gt;: [  &lt;/div&gt;&lt;div&gt;        &lt;span style=&quot;color: #cfcfc2;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #ae81ff;&quot;&gt;\\\\&lt;/span&gt;&lt;span style=&quot;color: #cfcfc2;&quot;&gt;.vscode&quot;&lt;/span&gt;, &lt;/div&gt;&lt;div&gt;        &lt;span style=&quot;color: #cfcfc2;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #ae81ff;&quot;&gt;\\\\&lt;/span&gt;&lt;span style=&quot;color: #cfcfc2;&quot;&gt;.idea&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div&gt;        &lt;span style=&quot;color: #cfcfc2;&quot;&gt;&quot;&lt;/span&gt;&lt;span style=&quot;color: #ae81ff;&quot;&gt;\\\\&lt;/span&gt;&lt;span style=&quot;color: #cfcfc2;&quot;&gt;.git&quot;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;    ]&lt;/div&gt;&lt;div&gt;}&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;参数解释：&lt;/div&gt;&lt;div&gt;&lt;pre&gt;{&lt;br&gt;&amp;nbsp; &amp;nbsp; &quot;name&quot;: &quot;aliyun Server&quot;,&amp;nbsp; // 服务器名，自定义&lt;br&gt;&amp;nbsp; &amp;nbsp; &quot;host&quot;: &quot;4*.**.**.1*5&quot;,&amp;nbsp; &amp;nbsp;// 服务器IP&lt;br&gt;&amp;nbsp; &amp;nbsp; &quot;protocol&quot;: &quot;sftp&quot;,&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// 默认sftp&lt;br&gt;&amp;nbsp; &amp;nbsp; &quot;port&quot;: 22,&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// 默认 22&lt;br&gt;&amp;nbsp; &amp;nbsp; &quot;username&quot;: &quot;xxx&quot;,&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 登入ftp的帐号&lt;br&gt;&amp;nbsp; &amp;nbsp; &quot;password&quot;: &quot;xxxx&quot;,&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// 登入ftp的密码&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &quot;remotePath&quot;: &quot;/home/ftpuser&quot;,&amp;nbsp; // 需要关联的服务器路径 （上面的帐号必须拥有访问该目录的权限）&lt;br&gt;&amp;nbsp; &amp;nbsp; &quot;uploadOnSave&quot;: false,&amp;nbsp; &amp;nbsp; //&amp;nbsp; 是否开启保存文件后，自动同步到服务器 false关闭（可以通过右键点击当前文件然后upload手动上传）&lt;br&gt;&amp;nbsp; &amp;nbsp; // 当前工程目录下所有文件都不要自动上传和删除&lt;br&gt;&amp;nbsp; &amp;nbsp; &quot;watcher&quot;: {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;files&quot;: &quot;**/*&quot;,&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;autoUpload&quot;: false,&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;autoDelete&quot;: false&lt;br&gt;&amp;nbsp; &amp;nbsp; },&lt;br&gt;&amp;nbsp; &amp;nbsp; // 忽略当前工程目录下哪些子文件夹不需要上传&lt;br&gt;&amp;nbsp; &amp;nbsp; &quot;ignore&quot;: [&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;\\\\.vscode&quot;,&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;\\\\.idea&quot;,&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;\\\\.git&quot;&lt;br&gt;&amp;nbsp; &amp;nbsp; ]&lt;br&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;然后Ctrl+s保存文件&lt;/div&gt;\n                                                                                        ',0,'2018-03-03 00:00:00','36',41),(195,1,'thinkphp5.1 + vue-cli3 脚手架项目 代码部署','','\n                                &lt;p&gt;thinkphp5.1处理前后端分离整合vue打包文件的配置方式&lt;/p&gt;&lt;p&gt;思路：将vue打包的文件夹dist下的文件放在TP5的入口目录/public目录，打包vue打包后的首页文件index.html放在TP5的指定的首页&lt;/p&gt;&lt;p&gt;控制器目录view/index/index.html 并覆盖，简单实现一个站点部署前后端分离项目代码&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;1.配置域名指定TP5的入口&lt;/p&gt;&lt;pre&gt;&amp;lt;VirtualHost *:80&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; DocumentRoot &quot;D:\\phpweb\\PHPTutorial\\WWW\\TP5\\public&quot;&lt;br&gt;&amp;nbsp; &amp;nbsp; ServerName www.vuetp.com&lt;br&gt;&amp;nbsp; &amp;nbsp; ServerAlias vuetp.com&lt;br&gt;&amp;nbsp; &amp;lt;Directory &quot;D:\\phpweb\\PHPTutorial\\WWW\\TP5\\public&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; Options FollowSymLinks ExecCGI&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; AllowOverride All&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; Order allow,deny&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; Allow from all&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; Require all granted&lt;br&gt;&amp;nbsp; &amp;lt;/Directory&amp;gt;&lt;br&gt;&amp;lt;/VirtualHost&amp;gt;&lt;/pre&gt;&lt;p&gt;2.vue项目的打包&lt;/p&gt;&lt;p&gt;由于是使用vue-cli3创建的脚手架项目目录。所以需要在vue.config.js下配置打包后文件的静态资源引入路径&lt;/p&gt;&lt;p&gt;由于我们把打包的文件放在了TP5的public下面，即域名根目录下，所以直接设置 \'/\'&lt;/p&gt;&lt;pre&gt;publicPath: process.env.NODE_ENV === \'production\' ? \'/\' : \'/\',&amp;nbsp;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;然后在vue项目下使用 npm run build 即可在该目录下生成一个dist目录，再把dist目录下的文件复制到TP5的/public下面即可。&lt;/p&gt;&lt;p&gt;最后一步，把打包后的index.html文件覆盖TP5默认的首页视图文件 view/index/index.htm&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                            ',0,'2018-03-02 00:00:00','23,38',48),(196,1,'JavaScript 两种高效的数组去重方式','','\n                                &lt;div style=&quot;color: rgb(248, 248, 242); background-color: rgb(39, 40, 34); font-family: Consolas, &amp;quot;Courier New&amp;quot;, monospace; font-size: 14px; line-height: 19px; white-space: pre;&quot;&gt;&lt;div&gt;    &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;let&lt;/span&gt; a &lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt; [&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;,&lt;span style=&quot;color: #ae81ff;&quot;&gt;3&lt;/span&gt;,&lt;span style=&quot;color: #ae81ff;&quot;&gt;4&lt;/span&gt;,&lt;span style=&quot;color: #ae81ff;&quot;&gt;6&lt;/span&gt;]&lt;/div&gt;&lt;div&gt;    &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;let&lt;/span&gt; b &lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt; [&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;,&lt;span style=&quot;color: #ae81ff;&quot;&gt;3&lt;/span&gt;,&lt;span style=&quot;color: #ae81ff;&quot;&gt;24&lt;/span&gt;,&lt;span style=&quot;color: #ae81ff;&quot;&gt;36&lt;/span&gt;]&lt;/div&gt;&lt;br&gt;&lt;div&gt;    1.利用ES6的set这一数据结构&lt;/div&gt;&lt;br&gt;&lt;div&gt;        &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt; &lt;span style=&quot;color: #a6e22e;&quot;&gt;distinct&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;a&lt;/span&gt;, &lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;b&lt;/span&gt;) {&lt;/div&gt;&lt;div&gt;        &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;Array&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;from&lt;/span&gt;(&lt;span style=&quot;color: #f92672;&quot;&gt;new&lt;/span&gt; Set([&lt;span style=&quot;color: #f92672;&quot;&gt;...&lt;/span&gt;a, &lt;span style=&quot;color: #f92672;&quot;&gt;...&lt;/span&gt;b]))&lt;/div&gt;&lt;div&gt;        }&lt;/div&gt;&lt;br&gt;&lt;div&gt;    知识点：&lt;/div&gt;&lt;div&gt;    &lt;span style=&quot;color: #ae81ff;&quot;&gt;1.1&lt;/span&gt;、array.from 把set转为数组  &lt;/div&gt;&lt;div&gt;    &lt;span style=&quot;color: #ae81ff;&quot;&gt;1.2&lt;/span&gt;、&lt;span style=&quot;color: #f92672;&quot;&gt;new&lt;/span&gt; Set([&lt;span style=&quot;color: #f92672;&quot;&gt;...&lt;/span&gt;a, &lt;span style=&quot;color: #f92672;&quot;&gt;...&lt;/span&gt;b])  把数组转为set集合去重&lt;/div&gt;&lt;br&gt;&lt;div&gt;    2.for&lt;span style=&quot;color: #f92672;&quot;&gt;...of&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;+&lt;/span&gt; &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;Object&lt;/span&gt; 这个是效率最快的数组去重方式&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;div&gt;        &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt; &lt;span style=&quot;color: #a6e22e;&quot;&gt;distinct&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;a&lt;/span&gt;, &lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;b&lt;/span&gt;) {&lt;/div&gt;&lt;div&gt;        &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;let&lt;/span&gt; arr &lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt; a.&lt;span style=&quot;color: #66d9ef;&quot;&gt;concat&lt;/span&gt;(b) &lt;span style=&quot;color: #75715e;&quot;&gt;// 合并数组&lt;/span&gt;&lt;/div&gt;&lt;div&gt;        &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;let&lt;/span&gt; result &lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt; []       &lt;span style=&quot;color: #75715e;&quot;&gt;// 去重后的最终结果数据&lt;/span&gt;&lt;/div&gt;&lt;div&gt;        &lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;let&lt;/span&gt; obj &lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt; {}          &lt;span style=&quot;color: #75715e;&quot;&gt;// 这个对象主要用来判断是否有重复数据&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;        &lt;span style=&quot;color: #f92672;&quot;&gt;for&lt;/span&gt; (&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;let&lt;/span&gt; i &lt;span style=&quot;color: #f92672;&quot;&gt;of&lt;/span&gt; arr) {&lt;/div&gt;&lt;br&gt;&lt;div&gt;            &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #f92672;&quot;&gt;!&lt;/span&gt;obj[i]) { &lt;span style=&quot;color: #75715e;&quot;&gt;// 通过判断key是否存在可以知道是否是重复数据&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;                result.&lt;span style=&quot;color: #66d9ef;&quot;&gt;push&lt;/span&gt;(i)&lt;/div&gt;&lt;br&gt;&lt;div&gt;                obj[i] &lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;  &lt;span style=&quot;color: #75715e;&quot;&gt;// 这里的1是随意的，obj的值为 ：{1:1,3:1,4:1,6:1}这样的形式； &lt;/span&gt;&lt;/div&gt;&lt;div&gt;            }&lt;/div&gt;&lt;div&gt;        }&lt;/div&gt;&lt;br&gt;&lt;div&gt;            &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; result&lt;/div&gt;&lt;div&gt;        }&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 总结： 经测试15W的数据 set只需要57ms; 而 for&lt;span style=&quot;color: rgb(249, 38, 114);&quot;&gt;...of&lt;/span&gt; &lt;span style=&quot;color: rgb(249, 38, 114);&quot;&gt;+&lt;/span&gt; &lt;span style=&quot;color: rgb(102, 217, 239); font-style: italic;&quot;&gt;Object&lt;/span&gt; 只需要16ms &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;所以如果是大数据量的数组去重可以选用  for&lt;span style=&quot;color: rgb(249, 38, 114);&quot;&gt;...of&lt;/span&gt; &lt;span style=&quot;color: rgb(249, 38, 114);&quot;&gt;+&lt;/span&gt; &lt;span style=&quot;color: rgb(102, 217, 239); font-style: italic;&quot;&gt;Object&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;\n                                                                                        ',0,'2019-09-05 00:00:00','22',51),(197,1,'js实现复制粘贴图片上传功能','','\n                                &lt;pre&gt;&amp;lt;div id=&quot;test&quot; contenteditable=&quot;true&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;&lt;p&gt;&lt;b&gt;1.复制图片&lt;/b&gt;&lt;/p&gt;&lt;pre&gt;       /**&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt; * 注：图片复制粘贴只能是用剪切工具如：QQ截图或者是网页右键复制图片，粘贴功能有效，&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt; * 在系统文件夹复制的图片不能粘贴&lt;br&gt;&amp;nbsp; &amp;nbsp;     */&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;document.querySelector(&quot;#test&quot;).addEventListener(\'paste\', function (event) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; var items = event.clipboardData &amp;amp;&amp;amp; event.clipboardData.items;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; var file = null;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; if (items &amp;amp;&amp;amp; items.length) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 检索剪切板items&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for (var i = 0; i &amp;lt; items.length; i++) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (items[i].type.indexOf(\'image\') !== -1) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;// 获取二进制的file对象，与我们平时用的&amp;lt;input type=&quot;file&quot;/&amp;gt; 获取到的对象是一样的，&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; file = items[i].getAsFile();&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; break;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; // 此时file就是剪切板中的图片文件&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; console.log(file)&lt;br&gt;&amp;nbsp; &amp;nbsp; });&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.上传图片&lt;/b&gt;&lt;/p&gt;&lt;pre&gt;        //通过上面获取到的file对象， 利用ajax异步上传图片&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;var formData = new FormData(); // 通过FormData 传输file二进制文件数据&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;formData.append(\'file\', file);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;// ajax上传&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;var xhr = new XMLHttpRequest();&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;// 上传结束&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;xhr.onload = function () {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; var json = JSON.parse(xhr.responseText);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; // ... 这里处理返回的json数据&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;};&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;xhr.open(\'POST\', \'./upload.php\', true);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;xhr.send(formData);&lt;/pre&gt;&lt;p&gt;通过获取到的file对象我们可以实现图片上传预览功能 参考：&amp;nbsp;&lt;a href=&quot;http://www.liuzaichun.cn/index/index/articledetail.html?article_id=9&quot; target=&quot;_blank&quot;&gt;http://www.liuzaichun.cn/index/index/articledetail.html?article_id=9&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                            ',0,'2019-09-19 00:00:00','22',61),(198,1,'js实现图片拖拽上传预览功能','','&lt;p&gt;实现此功能主要利用两个事件&amp;nbsp;ondragover 和&amp;nbsp;ondrop&lt;/p&gt;&lt;pre&gt;var box=document.getElementById(\'box\');&lt;br&gt;// ondragover 事件可以用来监听把图片拖拽到指定区域上传&lt;br&gt;box.ondragover=function (e){&lt;br&gt;&amp;nbsp; &amp;nbsp;e.preventDefault();&lt;br&gt;&amp;nbsp; &amp;nbsp;console.log(&quot;已进入图片拖拽上传区域&quot;)&lt;br&gt;}&lt;br&gt;// ondrop 用来监听鼠标松开拖拽图片，并获取图片的数据&lt;br&gt;box.ondrop=function (e){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt; e.preventDefault();//&amp;nbsp;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt; var f=e.dataTransfer.files[0];//获取拖拽图片的二进制对象数据&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt; var fr=new FileReader();//实例FileReader对象&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt; fr.readAsDataURL(f);&amp;nbsp; &amp;nbsp;//把二进制文件转base64,实现图片预览功能&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt; fr.onload=function (e){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; // var Url=e.target.result;//上传文件的URL&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; var Url=this.result;//上传文件的URL&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; box.innerHTML+=\'&amp;lt;img src=&quot;\'+Url+\'&quot; alt=&quot;&quot;&amp;gt;\'; // 通过img标签显示&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;',0,'2019-09-19 00:00:00','22',32),(199,1,'JavaScript引擎的运行原理','','\n                                \n                                &lt;div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;我们都知道js是单线程执行了，意味着同一时间只能完成一件事情。但是这也给js的运行带来了一些不好的体验，比如主线程在执行一条很耗时的语句时&lt;/div&gt;&lt;div&gt;后面所有的语句都会处于等待状态，造成主线程的阻塞。所以为了解决这个问题js引入了同步任务和异步任务的概念。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;JavaScript引擎在执行的时候，涉及到几个概念：调用栈、任务队列、事件轮训、web API；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;执行代码的时候&lt;/div&gt;&lt;div&gt;1.同步任务会首先被推入到调用栈栈顶执行相关的代码，执行完后会从调用栈中移除，当遇到异步任务时，js引擎会把异步回调函数放入到“任务队列”（先进先出）里等待执行；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.当调用栈把所有同步任务的代码都执行完毕后，js引擎会通过事件轮询机制把“任务队列”里的回调函数推入到调用栈栈顶执行相关代码，直到“任务队列”所有的任务都执行完毕，JavaScript的整个执行过程才算完成；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;注：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;1.什么样任务才会被放到“任务队列”呢？请记住setTimeout不是JS引擎的一部分，它是Web Api的一部分。属于web Api部分的还有DOM事件（如：点击事件click）这些都会被放到“任务队列”里等待执行。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 2.事件轮询的作用就是时刻监听调用栈是否为空，为空说明所有的同步任务都已经执行完了，这个时候JavaScript引擎才会去“任务队列”取出任务推入到调用栈执行&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 3.Web Api的作用就是监听属于异步任务的代码，并把他们放入到“任务队列”中&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20190920/3d4fce8183e9f626ce0a72bdea00501b.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 678px;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;阻塞是什么?&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 以一下代码会以同步的方式进行 例如：&lt;/div&gt;&lt;pre&gt;&amp;nbsp; &amp;nbsp; const processImage = (image) =&amp;gt; {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; /**&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; * doing some operations on image&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; **/&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; console.log(\'Image processed\');&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;const networkRequest = (url) =&amp;gt; {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; /**&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; * requesting network resource&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; **/&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; return someData;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;const greeting = () =&amp;gt; {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; console.log(\'Hello World\');&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;processImage(logo.jpg);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;networkRequest(\'www.somerandomurl.com\');&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;greeting();&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; 做图像处理和网络请求需要时间，当processImage()函数被调用时，它会根据图像的大小花费一些时间。&lt;/p&gt;&lt;p&gt;processImage() 函数完成后，将从堆栈中删除它。然后调用 networkRequest() 函数并将其推入堆栈。同样，它也需要一些时间来完成执行。&lt;/p&gt;&lt;p&gt;最后，当networkRequest()函数完成时，调用greeting()函数。&lt;/p&gt;&lt;p&gt;因此，咱们必须等待函数如processImage()或networkRequest()完成。这意味着这些函数阻塞了调用堆栈或主线程。因此，在执行上述代码时，咱们不能执行任何其他操作，这是不理想的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;解决办法是什么?&lt;/b&gt;&lt;/p&gt;&lt;p&gt;最简单的解决方案是异步回调，各位使用异步回调使代码非阻塞。例如:&lt;/p&gt;&lt;pre&gt;onst networkRequest = () =&amp;gt; {&lt;br&gt;&amp;nbsp; setTimeout(() =&amp;gt; {&lt;br&gt;&amp;nbsp; &amp;nbsp; console.log(\'Async Code\');&lt;br&gt;&amp;nbsp; }, 2000);&lt;br&gt;};&lt;br&gt;console.log(\'Hello World\');&lt;br&gt;networkRequest();&lt;br&gt;console.log(\'The End\');&lt;/pre&gt;&lt;p&gt;当上述代码在浏览器中加载时，console.log(\' Hello World \') 被推送到堆栈中，并在完成后弹出堆栈。接下来，将遇到对 networkRequest() 的调用，因此将它推到堆栈的顶部。&lt;/p&gt;&lt;p&gt;下一个 setTimeout() 函数被调用，因此它被推到堆栈的顶部。setTimeout()有两个参数:回调 和 以毫秒(ms)为单位的时间。&lt;/p&gt;&lt;p&gt;setTimeout() 方法在web api环境中启动一个2s的计时器。此时，setTimeout()已经完成，并从堆栈中弹出。cosole.log(“the end”) 被推送到堆栈中，在完成后执行并从堆栈中删除。&lt;/p&gt;&lt;p&gt;同时，计时器已经过期，现在回调被推送到消息队列。但是回调不会立即执行，这就是事件轮询开始的地方。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;\n                                                                                                                    ',0,'2019-09-20 00:00:00','22',32),(200,1,'利用Set集合提高数组判断效率以及使用array_filter 实现实时模糊查询','','\n                                &lt;p&gt;1 利用Set集合高效的判断数组是否存在某个值，有则删除 无则添加；这种方式比起我们平时利用indexOf或includes方法判断。然后在通过&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp;array.splice 进行添加或删除要快得多&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre&gt;&amp;nbsp; &amp;nbsp; let arr =&amp;nbsp; [1, 2, 4, 5, 6, 9, 10, 15];&lt;br&gt;&amp;nbsp; &amp;nbsp; let setArr&amp;nbsp; = new Set(arr) // 把数组转为Set集合&lt;br&gt;&amp;nbsp; &amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; if( !setArr.has(value) ) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; setArr.add(value)&amp;nbsp; &amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; }else{&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; setArr.delete(value)&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; 2.使用array_filter 实现输入框实时模糊查询；有时候需要实现在input框输入关键字实时显示搜索结果&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; 思路：给input框绑定input事件，记住是input事件而不是change事件；&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; 代码：&lt;/p&gt;&lt;pre&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;let users =&amp;nbsp; [&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;{name:&quot;张三&quot;,firstchar:\'ZS\'},&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;{name:&quot;李四&quot;,firstchar:\'LS\'},&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;{name:&quot;王五&quot;,firstchar:\'WW\'},&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;];&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; let searchUser = users.filter(function(item){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;return item.name.indexOf(keyword) &amp;gt; -1 || item.firstchar.indexOf(keyword.toUpperCase()) &amp;gt; -1 ? true :false&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; })&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 由于当keyword 为空（即：&quot;&quot;）时，str.indexOf() 总是会返回0，所以array.filter()总是返回true。这样的话当我们按回退键到input框为&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 空时，就达到了返回所有数据的目的&lt;/pre&gt;&lt;p&gt;注意：监听input事件时。为了减少频繁的执行过滤操作，当我们输入文字时应该屏蔽拼音状态，涉及到compositionstart 和compositionend 两个事件&lt;br&gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                            ',0,'2019-09-23 00:00:00','22',69),(201,1,'简单理解 promise 和 async、await的作用','','\n                                &lt;div&gt;这里我们先简单的了解一下什么是同步操作和异步操作&lt;/div&gt;&lt;ul&gt;&lt;li&gt;&amp;nbsp; 同步：后面的程序需要等待前面的程序执行完，才能往下执行&lt;/li&gt;&lt;li&gt;&amp;nbsp; 异步：后面的程序不需要等待前面的程序执行完返回结果，而是同时执行 （这根我们现实生活的理解是不一样的）&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; 所以异步操作带来的一个问题就是，如果后面的程序需要拿到前面程序的返回结果，根据结果来处理后续的操作的话，这个就会很难做到，因为异步操作是&lt;/div&gt;&lt;div&gt;&amp;nbsp; 同时执行的；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; 所以为了解决这个问题，才有了promise的出现&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;1.promise是异步编程的一种解决方案。它的出现解决了回调地狱的写法（简单理解就是回调函数嵌套回调函数，多层嵌套造成代码复杂）&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; Promise 状态：&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 只要是 Promise 对象都可以使用 then 方法来接收promise返回的异步操作信息，并且then方法接收两个函数作为参数，第一个参数是 Promise 执行成功时的回调，第二个参数是 Promise 执行失败时的回调，两个函数只会有一个被调用。&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;color: rgb(248, 248, 242); background-color: rgb(39, 40, 34); font-family: Consolas, &amp;quot;Courier New&amp;quot;, monospace; font-size: 14px; line-height: 19px; white-space: pre;&quot;&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;const&lt;/span&gt;&amp;nbsp;p&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;new&lt;/span&gt;&amp;nbsp;Promise(&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;resolve&lt;/span&gt;,&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;reject&lt;/span&gt;){&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;&quot;&gt;resolve&lt;/span&gt;(&lt;span style=&quot;color: #e6db74;&quot;&gt;\'success\'&lt;/span&gt;);&amp;nbsp;&lt;span style=&quot;color: #75715e;&quot;&gt;//&amp;nbsp;调用resolve&amp;nbsp;触发&amp;nbsp;then&amp;nbsp;第一个参数函数&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;&quot;&gt;reject&lt;/span&gt;(&lt;span style=&quot;color: #e6db74;&quot;&gt;\'error\'&lt;/span&gt;);&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #75715e;&quot;&gt;//&amp;nbsp;调用reject&amp;nbsp;触发&amp;nbsp;then&amp;nbsp;第二个参数函数&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;通过then接收 resolve(\'success\')返回的信息&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;color: rgb(248, 248, 242); background-color: rgb(39, 40, 34); font-family: Consolas, &amp;quot;Courier New&amp;quot;, monospace; font-size: 14px; line-height: 19px; white-space: pre;&quot;&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;p.&lt;span style=&quot;color: #66d9ef;&quot;&gt;then&lt;/span&gt;(&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;res&lt;/span&gt;){&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;console&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;log&lt;/span&gt;(res)&amp;nbsp;&lt;span style=&quot;color: #75715e;&quot;&gt;//&amp;nbsp;success&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;},&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;err&lt;/span&gt;){&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;console&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;log&lt;/span&gt;(err)&amp;nbsp;&lt;span style=&quot;color: #75715e;&quot;&gt;//&amp;nbsp;error&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}).&lt;span style=&quot;color: #66d9ef;&quot;&gt;catch&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;error&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;=&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;console&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;log&lt;/span&gt;(error))&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;一般我们在使用promise的时候then只写一个参数函数&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;p.&lt;span style=&quot;color: #66d9ef;&quot;&gt;then&lt;/span&gt;(&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;res&lt;/span&gt;){&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;console&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;log&lt;/span&gt;(res)&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}).&lt;span style=&quot;color: #66d9ef;&quot;&gt;catch&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;error&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;=&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;console&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;log&lt;/span&gt;(error))&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;注意：大多数浏览器中不能终止的 Promise 链里的 rejection，建议后面都跟上 .catch(error =&amp;gt; console.log(error));&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&amp;nbsp;以前我们处理这样一个业务，调用一个接口A，需要等到A接口返回数据后，把拿到的数据再去调用接口B，这时我们会这么写&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;JQ演示代码：&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;color: rgb(248, 248, 242); background-color: rgb(39, 40, 34); font-family: Consolas, &amp;quot;Courier New&amp;quot;, monospace; font-size: 14px; line-height: 19px; white-space: pre;&quot;&gt;&lt;div&gt;&amp;nbsp;$.&lt;span style=&quot;color: #66d9ef;&quot;&gt;post&lt;/span&gt;(apiA,&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;da&lt;/span&gt;){&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt;(da.code&lt;span style=&quot;color: #f92672;&quot;&gt;==&lt;/span&gt;&lt;span style=&quot;color: #ae81ff;&quot;&gt;200&lt;/span&gt;){&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$.&lt;span style=&quot;color: #66d9ef;&quot;&gt;post&lt;/span&gt;(apiB,&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;db&lt;/span&gt;){&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt;(db.code&lt;span style=&quot;color: #f92672;&quot;&gt;==&lt;/span&gt;&lt;span style=&quot;color: #ae81ff;&quot;&gt;200&lt;/span&gt;){&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;})&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;})&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;以上代码要是在继续嵌套的话，就形成了所谓的回调地狱的写法，这样的代码看起来复杂不易维护。阅读起来更不友好&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&lt;/div&gt;&lt;div&gt; 但是使用promise改写上面的代码就会简洁清晰很多：&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;color: rgb(248, 248, 242); background-color: rgb(39, 40, 34); font-family: Consolas, &amp;quot;Courier New&amp;quot;, monospace; font-size: 14px; line-height: 19px; white-space: pre;&quot;&gt;&lt;div&gt;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;const&lt;/span&gt;&amp;nbsp;p&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;new&lt;/span&gt;&amp;nbsp;Promise(&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;resolve&lt;/span&gt;,&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;reject&lt;/span&gt;){&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;let&lt;/span&gt;&amp;nbsp;res&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt;&amp;nbsp;$.http.&lt;span style=&quot;color: #66d9ef;&quot;&gt;apiA&lt;/span&gt;()&lt;span style=&quot;color: #75715e;&quot;&gt;//&amp;nbsp;模拟接口调用&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;&quot;&gt;resolve&lt;/span&gt;(res);&amp;nbsp;&lt;span style=&quot;color: #75715e;&quot;&gt;//&amp;nbsp;调用resolve&amp;nbsp;触发&amp;nbsp;then&amp;nbsp;第一个参数函数&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过then链式回调&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;p.&lt;span style=&quot;color: #66d9ef;&quot;&gt;then&lt;/span&gt;(&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;res&lt;/span&gt;){&amp;nbsp;&lt;span style=&quot;color: #75715e;&quot;&gt;//&amp;nbsp;res是上面返回的接口数据&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;let&lt;/span&gt;&amp;nbsp;res&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt;&amp;nbsp;$.http.&lt;span style=&quot;color: #66d9ef;&quot;&gt;apiB&lt;/span&gt;()&lt;span style=&quot;color: #75715e;&quot;&gt;//&amp;nbsp;模拟接口调用&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;}).&lt;span style=&quot;color: #66d9ef;&quot;&gt;catch&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;error&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;=&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;console&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;log&lt;/span&gt;(error))&amp;nbsp;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;then可以通过链式写法添加多个回调函数，它们会按照插入顺序并且独立运行。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;color: rgb(248, 248, 242); background-color: rgb(39, 40, 34); font-family: Consolas, &amp;quot;Courier New&amp;quot;, monospace; font-size: 14px; line-height: 19px; white-space: pre;&quot;&gt;&lt;div&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;const&lt;/span&gt;&amp;nbsp;p&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;new&lt;/span&gt;&amp;nbsp;Promise(&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;resolve&lt;/span&gt;,&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;reject&lt;/span&gt;){&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;&quot;&gt;resolve&lt;/span&gt;(&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}).&lt;span style=&quot;color: #66d9ef;&quot;&gt;then&lt;/span&gt;(&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;value&lt;/span&gt;){&amp;nbsp;&lt;span style=&quot;color: #75715e;&quot;&gt;//&amp;nbsp;第一个then&amp;nbsp;//&amp;nbsp;1&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;console&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;log&lt;/span&gt;(value);&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt;&amp;nbsp;value&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;*&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #ae81ff;&quot;&gt;2&lt;/span&gt;;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #75715e;&quot;&gt;//&amp;nbsp;then的回调函数&amp;nbsp;通过&amp;nbsp;return返回的数据会传给下一个then的回调函数接收&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}).&lt;span style=&quot;color: #66d9ef;&quot;&gt;then&lt;/span&gt;(&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;value&lt;/span&gt;){&amp;nbsp;&lt;span style=&quot;color: #75715e;&quot;&gt;//&amp;nbsp;第二个then&amp;nbsp;//&amp;nbsp;2&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;console&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;log&lt;/span&gt;(value);&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}).&lt;span style=&quot;color: #66d9ef;&quot;&gt;then&lt;/span&gt;(&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;value&lt;/span&gt;){&amp;nbsp;&lt;span style=&quot;color: #75715e;&quot;&gt;//&amp;nbsp;第三个then&amp;nbsp;//&amp;nbsp;undefined&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;console&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;log&lt;/span&gt;(value);&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;Promise&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;resolve&lt;/span&gt;(&lt;span style=&quot;color: #e6db74;&quot;&gt;\'resolve\'&lt;/span&gt;);&amp;nbsp;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}).&lt;span style=&quot;color: #66d9ef;&quot;&gt;then&lt;/span&gt;(&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;value&lt;/span&gt;){&amp;nbsp;&lt;span style=&quot;color: #75715e;&quot;&gt;//&amp;nbsp;第四个then&amp;nbsp;//&amp;nbsp;resolve&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;console&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;log&lt;/span&gt;(value);&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;Promise&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;reject&lt;/span&gt;(&lt;span style=&quot;color: #e6db74;&quot;&gt;\'reject\'&lt;/span&gt;);&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}).&lt;span style=&quot;color: #66d9ef;&quot;&gt;then&lt;/span&gt;(&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;value&lt;/span&gt;){&amp;nbsp;&lt;span style=&quot;color: #75715e;&quot;&gt;//&amp;nbsp;第五个then&amp;nbsp;//reject:reject&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;console&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;log&lt;/span&gt;(&lt;span style=&quot;color: #e6db74;&quot;&gt;\'resolve:\'&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;+&lt;/span&gt;&amp;nbsp;value);&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;},&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;err&lt;/span&gt;)&amp;nbsp;{&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;console&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;log&lt;/span&gt;(&lt;span style=&quot;color: #e6db74;&quot;&gt;\'reject:\'&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;+&lt;/span&gt;&amp;nbsp;err);&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;2.async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;async 可以理解是一个语法糖，在Promise的基础上让异步编程操作更加的简洁&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;语法：&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;async function name([param[, param[, ... param]]]) { statements }&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;定义函数时，在函数前面使用 async 进行标记&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;返回值&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;async&amp;nbsp; 函数返回一个 Promise 对象，所以可以使用 then 方法添加回调函数。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;async function helloAsync(){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; return &quot;helloAsync&quot;;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}&lt;br&gt;&amp;nbsp;&amp;nbsp;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;console.log(helloAsync())&amp;nbsp; // Promise {&amp;lt;resolved&amp;gt;: &quot;helloAsync&quot;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;helloAsync().then(v=&amp;gt;{&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp;console.log(v);&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// helloAsync&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;})&lt;/pre&gt;&lt;p&gt;&amp;nbsp;一般我们在使用async时，都会在函数里使用await表达式，await 操作符用于等待一个 Promise 对象;如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。 正常情况下，await 命令后面是一个 Promise 对象，它也可以跟其他值，如字符串，布尔值，数值以及普通函数。&lt;/p&gt;&lt;div style=&quot;color: rgb(248, 248, 242); background-color: rgb(39, 40, 34); font-family: Consolas, &amp;quot;Courier New&amp;quot;, monospace; font-size: 14px; line-height: 19px; white-space: pre;&quot;&gt;&lt;div&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #a6e22e;&quot;&gt;testAwait&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;x&lt;/span&gt;,&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;time&lt;/span&gt;)&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;new&lt;/span&gt;&amp;nbsp;Promise(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;resolve&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;=&amp;gt;&lt;/span&gt;&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;&quot;&gt;setTimeout&lt;/span&gt;(()&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;=&amp;gt;&lt;/span&gt;&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;&quot;&gt;resolve&lt;/span&gt;(x);&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;},&amp;nbsp;time);&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;async&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #a6e22e;&quot;&gt;helloAsync&lt;/span&gt;()&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;var&lt;/span&gt;&amp;nbsp;x&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;await&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;&quot;&gt;testAwait&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;hello&amp;nbsp;world&quot;&lt;/span&gt;,&lt;span style=&quot;color: #ae81ff;&quot;&gt;1000&lt;/span&gt;);&amp;nbsp;&lt;span style=&quot;color: #75715e;&quot;&gt;//&amp;nbsp;等待&amp;nbsp;Promise对象返回resolve后，才会执行&amp;nbsp;&amp;nbsp;console.log(x);&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;console&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;log&lt;/span&gt;(x);&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #75715e;&quot;&gt;//&amp;nbsp;hello&amp;nbsp;world&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;&quot;&gt;helloAsync&lt;/span&gt;&amp;nbsp;();&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;为什么说 async 在Promise的基础上让异步编程操作更加的简洁呢？比如我们需要操作多个Promise对象，并且然它们按顺序依次执行,使用async 会比单纯的使用Promise更加简洁&lt;/p&gt;&lt;div style=&quot;color: rgb(248, 248, 242); background-color: rgb(39, 40, 34); font-family: Consolas, &amp;quot;Courier New&amp;quot;, monospace; font-size: 14px; line-height: 19px; white-space: pre;&quot;&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #a6e22e;&quot;&gt;testAwait&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;x&lt;/span&gt;,&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;time&lt;/span&gt;)&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;new&lt;/span&gt;&amp;nbsp;Promise(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;resolve&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;=&amp;gt;&lt;/span&gt;&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;&quot;&gt;setTimeout&lt;/span&gt;(()&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;=&amp;gt;&lt;/span&gt;&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;&quot;&gt;resolve&lt;/span&gt;(x);&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;},&amp;nbsp;time);&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #75715e;&quot;&gt;//&amp;nbsp;这种方式比起Promise的then链式调用要简便的多&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;async&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #a6e22e;&quot;&gt;helloAsync&lt;/span&gt;()&amp;nbsp;{&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;var&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;await&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;&quot;&gt;testAwait&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;hello&amp;nbsp;world&quot;&lt;/span&gt;,&lt;span style=&quot;color: #ae81ff;&quot;&gt;3000&lt;/span&gt;);&amp;nbsp;&lt;span style=&quot;color: #75715e;&quot;&gt;//&amp;nbsp;这里会先等待testAwait执行完了才会往下执行&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;console&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;log&lt;/span&gt;(a);&amp;nbsp;&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;var&lt;/span&gt;&amp;nbsp;b&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;await&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;&quot;&gt;testAwait&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;hello&amp;nbsp;async&quot;&lt;/span&gt;,&lt;span style=&quot;color: #ae81ff;&quot;&gt;2000&lt;/span&gt;);&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;console&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;log&lt;/span&gt;(b);&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;&quot;&gt;helloAsync&lt;/span&gt;&amp;nbsp;();&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;\n                                                                                        ',0,'2019-09-24 00:00:00','22',63),(202,1,'vue中父组件与子组件、子组件与子组件间的传值','','\n                                \n                                \n                                &lt;div&gt;&lt;b&gt;父向子传值--&amp;gt;props&amp;nbsp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;1.props静态传值&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;color: rgb(248, 248, 242); background-color: rgb(39, 40, 34); font-family: Consolas, &amp;quot;Courier New&amp;quot;, monospace; font-size: 14px; line-height: 19px; white-space: pre;&quot;&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;var&lt;/span&gt;&amp;nbsp;childComponent&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt;&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template:&amp;nbsp;&lt;span style=&quot;color: #e6db74;&quot;&gt;`&amp;nbsp;&amp;lt;div&amp;gt;{{childValue}}&amp;lt;/div&amp;gt;`&lt;/span&gt;,&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;props:&amp;nbsp;[&lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;child-value&quot;&lt;/span&gt;],&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;var&lt;/span&gt;&amp;nbsp;parentComponent&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt;&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template:&amp;nbsp;&lt;span style=&quot;color: #e6db74;&quot;&gt;`&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #e6db74;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;div&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #e6db74;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;child&amp;nbsp;child-value=&quot;this&amp;nbsp;for&amp;nbsp;child&amp;nbsp;value&quot;&amp;gt;&amp;lt;/child&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #e6db74;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #e6db74;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`&lt;/span&gt;,&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;components:&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;child:&amp;nbsp;childComponent&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;new&lt;/span&gt;&amp;nbsp;Vue({&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;el:&amp;nbsp;&lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;#example&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;components:&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;parent:&amp;nbsp;parentComponent&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&lt;span style=&quot;color: #f92672;&quot;&gt;div&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #a6e22e;&quot;&gt;id&lt;/span&gt;&lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;example&quot;&lt;/span&gt;&amp;gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&lt;span style=&quot;color: #f92672;&quot;&gt;parent&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&quot;color: #f92672;&quot;&gt;parent&lt;/span&gt;&amp;gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;/&lt;span style=&quot;color: #f92672;&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;命名规范&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;对于 props 声明的属性，在父组件的 template 模板中，属性名需要使用中划线写法；&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;子组件 props 属性声明时，使用小驼峰或者中划线写法都可以；而子组件的模板使用从父组件传来的变量时，需要使用对应的小驼峰写法&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;2.props动态传值&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;div&gt;在模板中，要动态地绑定父组件的数据到子组件模板的 props，和绑定 Html 标签特性一样，使用v-bind绑定；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;基于上述静态 props 的代码，这次只需要改动父组件：&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;color: rgb(248, 248, 242); background-color: rgb(39, 40, 34); font-family: Consolas, &amp;quot;Courier New&amp;quot;, monospace; font-size: 14px; line-height: 19px; white-space: pre;&quot;&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;var&lt;/span&gt;&amp;nbsp;parentComponent&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt;&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template:&amp;nbsp;&lt;span style=&quot;color: #e6db74;&quot;&gt;`&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #e6db74;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;div&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #e6db74;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;child&amp;nbsp;:child-value=&quot;childValue&quot;&amp;gt;&amp;lt;/child&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #e6db74;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #e6db74;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`&lt;/span&gt;,&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;components:&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;child:&amp;nbsp;childComponent&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;},&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #a6e22e;&quot;&gt;data&lt;/span&gt;(){&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;childValue:&amp;nbsp;&lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;this&amp;nbsp;for&amp;nbsp;child&amp;nbsp;value&quot;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;单向数据流&lt;/b&gt;&lt;/div&gt;&lt;div&gt;props 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件五一修改父组件的状态。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;所以不应该在子组件中修改 props 中的值，Vue 会报出警告。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;修改 props 数据&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;有时候我们需要把父组件传递过来的props数据修改后才显示在模板中。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这里我们通常的做法就是在子组件data里定义一个数据，然后通过watch或者computed来监听做一些修改操作&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;color: rgb(248, 248, 242); background-color: rgb(39, 40, 34); font-family: Consolas, &amp;quot;Courier New&amp;quot;, monospace; font-size: 14px; line-height: 19px; white-space: pre;&quot;&gt;&lt;div&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;var&lt;/span&gt;&amp;nbsp;childComponent&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt;&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template:&amp;nbsp;&lt;span style=&quot;color: #e6db74;&quot;&gt;`&amp;nbsp;&amp;lt;div&amp;gt;{{childValue}}&amp;lt;/div&amp;gt;`&lt;/span&gt;,&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;props:&amp;nbsp;[&lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;child-value&quot;&lt;/span&gt;],&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #a6e22e;&quot;&gt;data&lt;/span&gt;()&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt;&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ownChildValue:&amp;nbsp;&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;this&lt;/span&gt;.childValue&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;},&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;watch:&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #a6e22e;&quot;&gt;ownChildValue&lt;/span&gt;()&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;this&lt;/span&gt;.ownChildValue&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;this&lt;/span&gt;.childValue;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;子向父传值--&amp;gt;子组件绑定事件回调定义在父组件，子组件触发此事件。因不推荐子组件内直接修改父组件传入的props，需使用自定义事件。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;color: rgb(248, 248, 242); background-color: rgb(39, 40, 34); font-family: Consolas, &amp;quot;Courier New&amp;quot;, monospace; font-size: 14px; line-height: 19px; white-space: pre;&quot;&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;var&lt;/span&gt;&amp;nbsp;parentComponent&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt;&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template:&amp;nbsp;&lt;span style=&quot;color: #e6db74;&quot;&gt;`&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #e6db74;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;div&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #e6db74;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;child&amp;nbsp;:for-child-value=&quot;childValue&quot;&amp;nbsp;@sendForParent=&quot;getFromChildValue&quot;&amp;gt;&amp;lt;/child&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #e6db74;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #e6db74;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`&lt;/span&gt;,&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;components:&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;child:&amp;nbsp;childComponent&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;},&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #a6e22e;&quot;&gt;data&lt;/span&gt;(){&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;childValue:&amp;nbsp;&lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;this&amp;nbsp;for&amp;nbsp;child&amp;nbsp;value&quot;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;},&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;method:{&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #a6e22e;&quot;&gt;getFromChildValue&lt;/span&gt;(&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;value&lt;/span&gt;){&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;console&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;log&lt;/span&gt;(&lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;来自子组件的value：&quot;&lt;/span&gt;&lt;span style=&quot;color: #f92672;&quot;&gt;+&lt;/span&gt;value)&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;var&lt;/span&gt;&amp;nbsp;childComponent&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt;&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;template:&amp;nbsp;&lt;span style=&quot;color: #e6db74;&quot;&gt;`&amp;nbsp;&amp;lt;div&amp;gt;{{childValue}}&amp;lt;/div&amp;gt;`&lt;/span&gt;,&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;props:&amp;nbsp;[&lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;child-value&quot;&lt;/span&gt;],&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #a6e22e;&quot;&gt;data&lt;/span&gt;()&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt;&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ownChildValue:&amp;nbsp;&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;this&lt;/span&gt;.childValue&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;},&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;method:&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #a6e22e;&quot;&gt;sendParentValue&lt;/span&gt;()&amp;nbsp;{&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #fd971f;font-style: italic;&quot;&gt;this&lt;/span&gt;.&lt;span style=&quot;color: #66d9ef;&quot;&gt;$emit&lt;/span&gt;(&lt;span style=&quot;color: #e6db74;&quot;&gt;\'sendForParent\'&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color: #e6db74;&quot;&gt;\'this&amp;nbsp;for&amp;nbsp;parent&amp;nbsp;value\'&lt;/span&gt;);&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #75715e;&quot;&gt;//&amp;nbsp;发送在父组件中定义的事件&amp;nbsp;sendForParent&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;子组件与子组件的传值&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;其实vue 中没有指定的子组件与子组件的传值方式，我们可以通过 vuex、eventBus方式来实现。&lt;/div&gt;&lt;div style=&quot;&quot;&gt;其中，vuex相对比较复杂，这里我们可以通过使用eventBus方式来实现传值，该方式适用于所有组件间的数据传递，&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;定义&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;pre style=&quot;&quot;&gt;新建 eventBus.js文件 到src/下的某个文件夹下  这里我们把它建在 src/utils/eventBus.js&lt;br&gt;import Vue from \'Vue\'&lt;br&gt;export default new Vue&lt;br&gt;&lt;br&gt;&lt;/pre&gt;&lt;div style=&quot;&quot;&gt;eventBus中我们只创建了一个新的Vue实例，以后它就承担起了组件之间通信的桥梁了，也就是中央事件总线。&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;div&gt;&lt;b&gt;使用方式：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;在需要传递数据的各个组件文件中首先需要引入eventBus&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;a组件向b组件传递数据&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;a.component&lt;br&gt;import bus from @/utils/eventBus&lt;br&gt;// 可以通过method的方法来触发这条语句&lt;br&gt;bus.$emit(&quot;sendValue&quot;,&quot;this is value from a&quot;) // 通过$emit发送事件&amp;nbsp;&lt;br&gt;&lt;br&gt;b.component&lt;br&gt;import bus from @/utils/eventBus&lt;br&gt;// 可以通过mounted 钩子函数触发这条语句&lt;br&gt;bus.$on(&quot;sendValue&quot;,res=&amp;gt;{&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;console.log(&quot;来自a组件传递的数据：&quot;+res)&lt;br&gt;}) // 通过$on监听事件&lt;/pre&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;注：如果我们在路由跳转的时候使用了上面这种方式传递数据到路由后的组件中的话，会有一个问题就是，路由跳转后，第一次是不会触发&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;bus.$on 监听的事件的，当重复上一步路由跳转操作后，bus.$on监听的事件才会被触发，并且重复多次路由跳转，bus.$on也会触发多次&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;问题&lt;/div&gt;&lt;div&gt;1.$emit时，必须已经$on，否则将无法监听到事件，也就是说对组件是有一定的同时存在的要求的。(&amp;nbsp;&lt;/div&gt;&lt;div&gt;注：路由切换时，新路由组件先created，旧路由组件再destoryed，部分情况可以分别写入这两个生命周期，见此问题)。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.$on在组件销毁后不会自动解除绑定，若同一组件多次生成则会多次绑定事件，则会一次$emit，多次响应，需额外处理。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.数据非“长效”数据，无法保存，只在$emit后生效。（通过$emit传递的数据不会在内存中保存，只会在传递的过程中有效）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;特殊的eventBus&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;新建 eventBus.js文件 到src/下的某个文件夹下&amp;nbsp; 这里我们把它建在 src/utils/eventBus.js&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;import Vue from \'Vue\'&lt;br&gt;const bus = new Vue({&lt;br&gt;&amp;nbsp; data () {&lt;br&gt;&amp;nbsp; &amp;nbsp; return {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // 定义变量用于保存传递的数据&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; sendValue: \'\'&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; },&lt;br&gt;&amp;nbsp; created () {&lt;br&gt;&amp;nbsp; &amp;nbsp; // 监听来自$emit发送的事件，达到了触发$emit时，先$on的目的，这样就不会出现上面的情况，第一次不会触发$on的事件&lt;br&gt;&amp;nbsp; &amp;nbsp; this.$on(\'updateData1\', (val)=&amp;gt;{&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; this.sendValue = val&lt;br&gt;&amp;nbsp; &amp;nbsp; })&lt;br&gt;&amp;nbsp; }&lt;br&gt;})&lt;br&gt;export default bus&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;上面我们可以看到创建eventBus实例时，我们用到了Vue的data和created属性。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;使用方式：&lt;/div&gt;&lt;pre&gt;&lt;br&gt;a.component&lt;br&gt;import bus from @/utils/eventBus&lt;br&gt;//我们在 $emit时，eventBus已经通过created钩子函数事先 $on需要监听的事件了&lt;br&gt;bus.$emit(&quot;sendValue&quot;,&quot;this is value from a&quot;)&amp;nbsp;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;当我们$emit发送事件时，此时在eventBus实例中，触发了$on事件，并把传递的数据保存在了 sendValue 这个变量中&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;在b.component中获取到a.component传递的数据&lt;br&gt;import bus from @/utils/eventBus&lt;br&gt;&amp;nbsp;data(){&lt;br&gt;&amp;nbsp; &amp;nbsp; value :bus.sendValue // 直接通过 bus.sendValue获取值。避免了上面出现的各种问题&lt;br&gt;&amp;nbsp;}&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;不同&lt;/div&gt;&lt;div&gt;1.正统的eventBus只是用来绑定和触发事件，并不关心数据，不与数据发生交集。而这个方案多一步将数据直接添加在bus实例上。且事件监听与数据添加需提前定义好。&lt;/div&gt;&lt;div&gt;2.数据接收方不再使用$on来得知数据变化，而是通过计算属性的特征被动接收。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;解决的问题&lt;/div&gt;&lt;div&gt;1.通信组件需同时存在？数据在bus上存储，所以没有要求。&lt;/div&gt;&lt;div&gt;2.多次绑定？绑定监听都在bus上，不会重复绑定。&lt;/div&gt;&lt;div&gt;3.数据只在$emit后可用？使用计算属性直接读取存在bus上的值，不需要再次触发事件。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n                                                                                                                                                ',0,'2019-10-11 00:00:00','22,38',62),(203,1,'php正则匹配img中src值并替换','','&lt;div&gt;有时候需要把一段内容中的图片地址替换掉，则我们可以通过&amp;nbsp; preg_replace_callback 函数&lt;/div&gt;&lt;pre&gt;&lt;br&gt;$preg = \'/&amp;lt;img.*?src=[\\&quot;|\\\']?(.*?)[\\&quot;|\\\']?\\s.*?&amp;gt;/i\';&lt;br&gt;$content = &quot;内容...[省略]&quot;&lt;br&gt;$content =&amp;nbsp; preg_replace_callback($preg,function($matches){&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; //&amp;nbsp; $matches[1] 为匹配到的src中的图片地址&lt;br&gt;&amp;nbsp; &amp;nbsp; return \'&amp;lt;img style=&quot;max-width:100%;object-fit:contain;&quot; src=&quot;http://xxx.com\'.$matches[1].\'&quot;/&amp;gt;\';&lt;br&gt;},$content);&lt;/pre&gt;\n                                                            ',0,'2017-03-08 00:00:00','23',7),(204,1,'关于前后端分离项目权限该怎么设计','','\n                                \n &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;最近做了一个项目使用vue+ springboot2.0开发的一个前后端分离的后台管理项目；在这里总结一下我的一个权限设计思路，权限设计是基于RBAC来设计的&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;我们都知道做一个后台管理系统最重要的就是权限设计这块。在之前的开发模式中（前后端混合开发），权限这块我们只需要在后端判断即可，因为前后端混合开发中，我们都是一个页面对应一个控制器，每次切换页面时，都会请求到控制器层，所以我们在做权限设计时，只需要在后端判断即可；但是现如今很多的项目都开始采用前后端分离模式开发了，这就给权限设计这块带来了一些变化，不仅需要在后端判断权限还需要在前端判断权限。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;权限分为两部分：后端API权限和前端路由权限&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;由于是前后端分离项目，所以前端所有的数据都是通过调用后端API接口获取的，而前端路由切换是由前端（vue）路由来控制，并不是请求到后端控制器层；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;数据库表结构设计：&lt;/div&gt;&lt;pre&gt;（用户表）&lt;br&gt;CREATE TABLE `cpms_user` (&lt;br&gt;&amp;nbsp; `user_id` int(11) unsigned NOT NULL AUTO_INCREMENT,&lt;br&gt;&amp;nbsp; `user_name` varchar(50) NOT NULL DEFAULT \'\' COMMENT \'用户名\',&lt;br&gt;&amp;nbsp; `user_password` varchar(35) NOT NULL DEFAULT \'\' COMMENT \'用户密码\',&lt;br&gt;&amp;nbsp; `create_time` datetime NOT NULL COMMENT \'用户创建时间\',&lt;br&gt;&amp;nbsp; `last_login_time` datetime NOT NULL COMMENT \'最后登陆时间\',&lt;br&gt;&amp;nbsp; `status` tinyint(3) NOT NULL DEFAULT \'0\' COMMENT \'0:正常 -1：删除\',&lt;br&gt;&amp;nbsp; PRIMARY KEY (`user_id`)&lt;br&gt;) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8mb4&lt;br&gt;&lt;br&gt;（角色表）&lt;br&gt;CREATE TABLE `cpms_role` (&lt;br&gt;&amp;nbsp; `role_id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT \'角色id\',&lt;br&gt;&amp;nbsp; `role_name` varchar(50) NOT NULL DEFAULT \'\' COMMENT \'角色名\',&lt;br&gt;&amp;nbsp; `role_descript` varchar(500) NOT NULL DEFAULT \'\' COMMENT \'角色描述\',&lt;br&gt;&amp;nbsp; PRIMARY KEY (`role_id`)&lt;br&gt;) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4&lt;br&gt;&lt;br&gt;（用户角色表）&lt;br&gt;CREATE TABLE `cpms_user_role` (&lt;br&gt;&amp;nbsp; `user_id` int(11) NOT NULL DEFAULT \'0\' COMMENT \'用户表user_id\',&lt;br&gt;&amp;nbsp; `role_id` int(11) NOT NULL DEFAULT \'0\' COMMENT \'角色表role_id\',&lt;br&gt;&amp;nbsp; KEY `user_id` (`user_id`)&lt;br&gt;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4&lt;br&gt;&lt;br&gt;（角色权限表）&lt;br&gt;CREATE TABLE `cpms_role_permission` (&lt;br&gt;&amp;nbsp; `role_id` int(11) NOT NULL DEFAULT \'0\' COMMENT \'角色表role_id\',&lt;br&gt;&amp;nbsp; `page_permission` text NOT NULL COMMENT \'页面权限URL\',&lt;br&gt;&amp;nbsp; `handle_permission` text NOT NULL COMMENT \'操作权限URL即增删改查接口URL\',&lt;br&gt;&amp;nbsp; KEY `role_id` (`role_id`)&lt;br&gt;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4&lt;/pre&gt;&lt;div&gt;&lt;div&gt;前端路由配置：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;// 需要授权的全部路由数据&lt;br&gt;export const permitRoutes = [&lt;br&gt;{&lt;br&gt;&amp;nbsp; &amp;nbsp; path: \'/userRole\',&lt;br&gt;&amp;nbsp; &amp;nbsp; component: Layout,&lt;br&gt;&amp;nbsp; &amp;nbsp; redirect: \'/userRole/user\',&lt;br&gt;&amp;nbsp; &amp;nbsp; name: \'userRole\',&lt;br&gt;&amp;nbsp; &amp;nbsp; meta: { title: \'用户角色\', icon: \'peoples\' },&lt;br&gt;&amp;nbsp; &amp;nbsp; menuUrl:\'/userRole\',&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; children: [&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; path: \'user\',&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; name: \'user\',&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; component: () =&amp;gt; import(\'@/views/userRole/user\'),&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; meta: { title: \'用户管理\' },&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; menuUrl:\'/userRole/user\',&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; permit:[&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {name:\'查看用户列表\',\'url\':\'/user/allUser/**\'},&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {name:\'添加用户\',\'url\':\'/user/add/**,/role/allRole/**\'},&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {name:\'编辑用户\',\'url\':\'/user/edit/**,/role/allRole/**\'},&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {name:\'删除用户\',\'url\':\'/user/delete/**\'},&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ]&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; },&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; path: \'role\',&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; name: \'role\',&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; component: () =&amp;gt; import(\'@/views/userRole/role\'),&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; meta: { title: \'角色管理\' },&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; menuUrl:\'/userRole/role\',&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; permit:[&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {name:\'查看角色列表\',\'url\':\'/role/allRole/**\'},&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {name:\'添加角色\',\'url\':\'/role/add/**\'},&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {name:\'编辑角色\',\'url\':\'/role/edit/**\'},&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {name:\'删除角色\',\'url\':\'/role/delete/**\'}&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ]&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; ]&lt;br&gt;&amp;nbsp; },&lt;br&gt;&amp;nbsp; // 把path: \'*\' 放在路由列表的最后&amp;nbsp;&lt;br&gt;&amp;nbsp; { path: \'*\', redirect: \'/404\', hidden: true }&lt;br&gt;]&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;在权限路由的配置中，我添加了两个字段：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;menuUrl : 用于数据库记录角色拥有菜单的权限（即路由页面的权限）&amp;nbsp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;permit：&amp;nbsp; 用于数据库记录角色拥有页面操作的权限（后端api权限）&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;由于权限粒度做的比较细，这里有一个权限依赖的概念，比如：添加用户的操作，需要选择角色信息，所以需要有获取角色列表的权限。&lt;/div&gt;&lt;div&gt;记录形式为：&lt;/div&gt;&lt;div&gt;permit:[{name:\'添加用户\',\'url\':\'/user/add/**,/role/allRole/**\'}],&amp;nbsp;&lt;/div&gt;&lt;div&gt;表示添加用户的权限，绑定了角色列表权限，也就同时有了获取角色列表的权限&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;由于需要配合后端进行restful api 风格的权限判断，所以记录操作权限的url需要在后面加上 &quot; /** &quot;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;后续的业务就是把 permitRoutes 的数据渲染在页面上，通过CheckBox多选框选择角色对应的权限保存入库&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191016/953493cac5c12b57b0e3ca8952780103.png&quot; data-filename=&quot;img&quot; style=&quot;width: 782px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;权限判断：&lt;/div&gt;&lt;div&gt;一般我们做权限判断只是单纯的控制页面操作按钮的显示，很显然这样做权限判断是不严谨的，假如别人知道数据接口URL，还是可以发起请求数据；&lt;/div&gt;&lt;div&gt;严谨的权限判断规则应该是前端页面控制操作按钮的显示（目的是减少对后端服务的不必要请求），后端才是真正的权限判断处理&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(36, 41, 46); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Segoe UI&amp;quot;, Helvetica, Arial, sans-serif, &amp;quot;Apple Color Emoji&amp;quot;, &amp;quot;Segoe UI Emoji&amp;quot;; font-size: 16px;&quot;&gt;后端代码：&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;https://github.com/gulang12/cpms-java-springboot&quot;&gt;https://github.com/gulang12/cpms-java-springboot&lt;/a&gt;&lt;a href=&quot;https://github.com/gulang12/cpms-java-springboot&quot; title=&quot;https://github.com/gulang12/cpms-java-springboot&quot; style=&quot;background-color: rgb(255, 255, 255); color: rgb(3, 102, 214); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Segoe UI&amp;quot;, Helvetica, Arial, sans-serif, &amp;quot;Apple Color Emoji&amp;quot;, &amp;quot;Segoe UI Emoji&amp;quot;; font-size: 16px;&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(36, 41, 46); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Segoe UI&amp;quot;, Helvetica, Arial, sans-serif, &amp;quot;Apple Color Emoji&amp;quot;, &amp;quot;Segoe UI Emoji&amp;quot;; font-size: 16px;&quot;&gt;前端代码：&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;https://github.com/gulang12/cpms-java-vue&quot;&gt;https://github.com/gulang12/cpms-java-vue&lt;/a&gt;&lt;a href=&quot;https://github.com/gulang12/cpms-java-vue&quot; title=&quot;https://github.com/gulang12/cpms-java-vue&quot; style=&quot;background-color: rgb(255, 255, 255); color: rgb(3, 102, 214); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Segoe UI&amp;quot;, Helvetica, Arial, sans-serif, &amp;quot;Apple Color Emoji&amp;quot;, &amp;quot;Segoe UI Emoji&amp;quot;; font-size: 16px;&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;\n                                                                                                                                                                                                                                    ',0,'2019-10-16 00:00:00','38',37),(205,1,'为什么要使用Docker？','','\n                                &lt;p&gt;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。&lt;/p&gt;&lt;p&gt;Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p&gt;&lt;p&gt;容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。&lt;/p&gt;&lt;p&gt;说白了就是docker可以让我们的开发和生产部署环境时，更加的方便快捷。比如我们在本地测试环境使用docker搭建的lnmp环境,我们完全可以把它们打包成镜像文件，移植到生产环境中来运行线上的项目；这样极大的节省了我们需要在生产环境中还需要部署同样的lnmp环境的时间&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Docker的应用场景在哪？？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;本地依赖(Local Dependency)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;你需要在本地系统快速尝试 Magento，或者为一个项目使用 MySQL？还是希望尝试大部分开源项目？那就使用 Docker 吧，它将帮你节省大量时间。Docker 能提升开发者的开发效率，让我们快速搭建开发环境。 开发环境的机器通常内存比较小，此前使用虚拟的时候，经常需要为开发环境的机器加内存，而通过 Docker 可以轻易的让几十个服务在 Docker 中跑起来。&lt;/p&gt;&lt;p&gt;&lt;b&gt;搭建环境(Build Environment)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果你希望构建源码，但发现没有准备好合适的环境。 那么使用 Docker是一个值得考虑的方案。毕竟如果使用传统的方法一个一个地安装软件，一大堆软件安装下来确实十分费时间，使用容器技术省时省力，何乐而不为？它能让你将运行环境和配置放在代码中然后部署，同一个 Docker 的配置可以在不同的环境中使用，这样就降低了硬件要求和应用环境之间耦合度。这里有一个值得一看的例子： docker golang builder。&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;微服务(Microservices)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;你在使用微服务吗？微服务架构将一个整体式的应用拆分成松耦合的单个服务。 那不妨考虑一下 Docker，你可以将每个服务打包为一个docker镜像并使用docker-compose 来模拟生产环境(checkout docker networks)。最开始实践的时候可能会比较费时费力，但长远地来看，最终将产生巨大的生产力。&lt;/p&gt;&lt;p&gt;等等...&lt;/p&gt;&lt;p&gt;centos的官方发行版本从6.5以上就内核支持docker了，可以直接运行命令安装docker。&lt;/p&gt;&lt;h2 style=&quot;border: 0px; margin: 2px 0px; padding: 0px; font-size: 1.8em; line-height: 1.8em; color: rgb(51, 51, 51); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, sans-serif;&quot;&gt;前提条件&lt;/h2&gt;&lt;p style=&quot;border: 0px; margin-bottom: 0px; padding: 0px; line-height: 2em; overflow-wrap: break-word; word-break: break-all; font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, sans-serif; color: rgb(51, 51, 51);&quot;&gt;目前，CentOS 仅发行版本中的内核支持 Docker。&lt;/p&gt;&lt;p style=&quot;border: 0px; margin-bottom: 0px; padding: 0px; line-height: 2em; overflow-wrap: break-word; word-break: break-all; font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, sans-serif; color: rgb(51, 51, 51);&quot;&gt;Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。&lt;/p&gt;&lt;p style=&quot;border: 0px; margin-bottom: 0px; padding: 0px; line-height: 2em; overflow-wrap: break-word; word-break: break-all; font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, sans-serif; color: rgb(51, 51, 51);&quot;&gt;Docker 运行在&amp;nbsp;CentOS-6.5&amp;nbsp;或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。&lt;/p&gt;&lt;p style=&quot;border: 0px; margin-bottom: 0px; padding: 0px; line-height: 2em; overflow-wrap: break-word; word-break: break-all; font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, sans-serif; color: rgb(51, 51, 51);&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p style=&quot;border: 0px; margin-bottom: 0px; padding: 0px; line-height: 2em; overflow-wrap: break-word; word-break: break-all; font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, sans-serif; color: rgb(51, 51, 51);&quot;&gt;从 2017 年 3 月开始 docker 在原来的基础上分为两个分支版本: Docker CE 和 Docker EE。&lt;/p&gt;&lt;p style=&quot;border: 0px; margin-bottom: 0px; padding: 0px; line-height: 2em; overflow-wrap: break-word; word-break: break-all; font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Noto Sans CJK SC&amp;quot;, &amp;quot;WenQuanYi Micro Hei&amp;quot;, Arial, sans-serif; color: rgb(51, 51, 51);&quot;&gt;Docker CE 即社区免费版，Docker EE 即企业版，强调安全，但需付费使用。&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                            ',0,'2018-03-02 00:00:00','35',45),(206,1,'java中字符串常量池详解','','&lt;div&gt;字符串常量池会用来存放字符串，也就是说常量池中的文本字符串会在类加载时进入字符串常量池。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;那字符串常量池和运行时常量池是什么关系呢？上面我们说常量池中的字面量会在类加载后进入运行时常量池，其中字面量中有包括文本字符串，显然从这段文字我们可以知道字符串常量池存在于运行时常量池中。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;字符串对象创建的过程&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;String t = new String(&quot;str&quot;);&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;由于”str”属于字面量，那么它会在类加载之后存在于字符串常量池中，也就是说，在 String t = new String(“str”)这句代码执行之前，字符串常量池就已经创建了”str”这个字符串对象了，我们都知道，new这个关键字会在堆中创建一个对象。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;所以，这段代码创建了两个对象。一个在堆中，一个在字符串常量池中。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;String t1 = new String(&quot;str&quot;);&lt;br&gt;String t2 = new String(&quot;str&quot;);&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这个过程程序创建了三个对象，&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;首先String t1 = new String(&quot;str&quot;);执行时会在字符串常量池中创建“str”对象，然后news时会在堆中创建一个“str”对象，并将堆中的引用地址赋值给t1;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;由于字符串常量池中只会保存一份同样的字符串，所以&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;String t2 = new String(&quot;str&quot;);&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在执行时，字符串常量池中不会创建“str”对象，new时会在堆中创建一个“str”对象，并将堆中的引用地址赋值给t2;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;String t = &quot;str&quot;;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;上面代码创建一个对象，在这段代码执行之前，字符串常量池已经创建了一个”str”的对象，但由于这行代码并非用new的方法，所以虚拟机会在字符串常量池中寻找是否有内容为”str”的字符串对象，如果有，则直接返回这个字符串的引用，所以最终结果只创建了一个对象。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;String 的intern方法&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;例如我们调用了t.intern()。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在JDK1.6的时候，调用了这个方法之后，虚拟机会在字符串常量池在查找是否有内容与”str”相等的对象，如果有，则返回这个对象，如果没有，则会在字符串常量池中添加这个对象。注意，是把这个对象添加到字符串常量池。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;到了JDK1.7之后，如果调用了intern这个方法，虚拟机会在字符串常量池在查找是否有内容与”str”相等的对象，如果有，则返回这个对象，如果没有。则会在堆中创建这个对象并把引用复制添加到字符串常量池中。注意，这个时候创建的对象是在堆中的引用。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;（注：调用t.intern()方法，如果常量池存在该字符串对象，并不会做任何事，也就是不会对t产生任何影响）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;现在开始来分析问题中的代码&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;t1 = new String(“1”)。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这句代码执行之前，字符串常量池中已经有”t”这个对象，执行之后会在堆中也创建一个”t”的对象，此时t1指向的是堆中的对象。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;t1.intern();&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这句代码执行之后，会在字符串常量池寻早内容为”t”的对象，字符串常量池已经存在这个对象了，把这个对象返回(不过返回之后并没有变量来接收)。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;t2 = “1”。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这句执行后会在字符串常量池查找内容为”t”的对象，字符串常量池已经有这个对象了，返回给t2，此时t2指向的是常量池中的对象。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;一个是常量池中的对象，一个是在堆中的对象，两者能相等吗？因此&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;t1 与 t2不相等。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;t3 = new String(“2”) + new String(“2”);&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这段代码调用之前，字符串常量池有一个”2”的对象，执行之后，实际上会调用StringBuilder的append()方法类进行拼接，最后在堆中创建一个”22”的对象，注意，此时字面量并没有”22”这个字符串，也就是说在字符串常量池并没有”22”这个对象。此时t3指向堆中”22”这个对象&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;t3.intern();&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;执行这个方法之后&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在JDK1.6的时候，它在字符串常量池中并没有找到内容为”22”的对象，所以这个时候会在字符串常量池中创建“22”这个对象，并把这个对象返回(此时并没有变量来接收这个返回的对象)。注意是在常量池中创建了对象，而不是把堆中的“22”对象的引用添加到常量池中。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;t4 = “22”。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这句代码执行后，会返回字符串常量池中内容为”22”对象，此时t4指向的是字符串常量池中的对象。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;显然，一个对象在字符串常量池，一个在堆中，两个对象并非是同一个对象，因此在JDK1.6的时候，t3与t4不相等。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;但是在JDK1.7的时候&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;t3.intern()执行之后，由于在字符串常量池在并没有内容为”22”的对象，所以会把堆中的“22”对象的引用赋值到字符串常量池。注意此时字符串常量池保存的是堆中这个对象的引用。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;t4 = “22”。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;执行这句代码之后，从字符串常量池返回给t4的是堆中对象的引用。此时t4指向的实际上是堆中对象的引用，也就是说，t3和t4指向的是同一个对象。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;因此t3与t4相等。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;除了字符串常量池，在java中还有基本类型的封装类常量池，包括：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;Byte, Short, Integer, Long, Character, Boolean。需要注意的是，Float和Double这两个类并没有对应的常量池。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;注：&lt;/div&gt;&lt;div&gt;1.上面5种整型的包装类也只是在对象数值在-128~127才可以使用这些常量池。&lt;/div&gt;&lt;div&gt;2.在周志明的那本虚拟机中有这样一句话：包装类的&lt;/div&gt;&lt;div&gt;“\\==”运行符在不遇到算术运算的情况下不会自动拆箱，以及他们的equals()方法不处理数据类型的关系，可以推断出如果遇到“==”两边有算术运算是话就会自动拆箱和进行数据类型转换处理。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.Long的equals方法会先判断是否是Long类型。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;4.无论是Integer还是Long，他们的equals方法比较的是数值。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;(注：基本数据类型比较的是数值，封装类型比较的是对象)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;代码：&lt;/div&gt;&lt;pre&gt;&amp;nbsp; &amp;nbsp; Integer a = 1;&lt;br&gt;&amp;nbsp; &amp;nbsp; Integer b = 2;&lt;br&gt;&amp;nbsp; &amp;nbsp; Integer c = 3;&lt;br&gt;&amp;nbsp; &amp;nbsp; Integer d = 3;&lt;br&gt;&amp;nbsp; &amp;nbsp; Integer e = 321;&lt;br&gt;&amp;nbsp; &amp;nbsp; Integer f = 321;&lt;br&gt;&amp;nbsp; &amp;nbsp; Long g = 3L;&lt;br&gt;&amp;nbsp; &amp;nbsp; System.out.println(c == d);&amp;nbsp; // true&lt;br&gt;&amp;nbsp; &amp;nbsp; System.out.Println(e == f);&amp;nbsp; // false&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; System.out.println(c == (a + b));&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; System.out.println(c.equals(a+b));&lt;br&gt;&amp;nbsp; &amp;nbsp; System.out.println(g == (a + b));&lt;br&gt;&amp;nbsp; &amp;nbsp; System.out.println(g.equals(a + b));&lt;br&gt;    System.out.println(c == d)。&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;由于常量池的作用，c与d指向的是同一个对象(注意此时的==比较的是对象，也就是地址，而不是数值)。因此为true&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;System.out.println(e == f)。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;由于321超过了127，因此常量池失去了作用，所以e和f数值虽然相同，但不是同一个对象，以此为false。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;System.out.println(c == (a+b))。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;此时==两边有算术运算，会进行拆箱，因此此时比较的是数值，而并非对象。因此为true。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;System.out.println(c.equals(a+b))&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;c与a+b的数值相等，为true。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;System.out.pirnln(g == (a + b))&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;由于==两边有算术运算，所以比较的是数值，因此为true。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;System.out.println(g.equals(a+b))。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Long类型的equal在比较是时候，会先判断a+b是否为Long类型，显然a+b不是，因此false&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n                                                            ',0,'2019-10-18 00:00:00','34',60),(207,1,'centos7安装docker','','\n &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;目前，CentOS 仅发行版本中的内核支持 Docker。&lt;/p&gt;&lt;p&gt;Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。&lt;/p&gt;&lt;p&gt;Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。&lt;/p&gt;&lt;p&gt;从 2017 年 3 月开始 docker 在原来的基础上分为两个分支版本: Docker CE 和 Docker EE。&lt;/p&gt;&lt;p&gt;Docker CE 即社区免费版，Docker EE 即企业版，强调安全，但需付费使用。&lt;/p&gt;&lt;p&gt;本文介绍 Docker CE 的安装使用。&lt;/p&gt;&lt;p&gt;以下所有的命令都是使用root用户操作，非root 请在前面加 sudo&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;1.可以通过命令 uname -r&amp;nbsp; 查看 centos 内核版本&lt;/p&gt;&lt;p&gt;2.确保 yum 包更新到最新。&lt;/p&gt;&lt;pre&gt;yum update&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;3.移除旧的版本（如果有旧版的这执行这步）&lt;/p&gt;&lt;pre&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; yum remove docker \\&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; docker-client \\&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; docker-client-latest \\&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; docker-common \\&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; docker-latest \\&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; docker-latest-logrotate \\&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; docker-logrotate \\&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; docker-selinux \\&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; docker-engine-selinux \\&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; docker-engine&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;4.安装一些必要的系统工具：yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的&lt;/p&gt;&lt;pre&gt;yum install -y yum-utils device-mapper-persistent-data lvm2&lt;/pre&gt;&lt;p&gt;这一步是什么意思呢&amp;nbsp; 官方这么解释&lt;/p&gt;&lt;p&gt;Before you install Docker CE for the first time on a new host machine, you need to set up the Docker repository. Afterward, you can install and update Docker from the repository.(首次在新主机上安装Docker CE之前，需要设置Docker存储库。之后，您可以从存储库安装和更新Docker)&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;5.设置yum源 （这里使用阿里云的镜像）&lt;/p&gt;&lt;pre&gt;yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo&lt;/pre&gt;&lt;p&gt;Use the following command to set up the stable repository. You always need the stable repository, even if you want to install builds from the edgeor test repositories as well(使用以下命令设置稳定的存储库。即使您想从边缘或测试存储库安装构建，也总是需要稳定的存储库)&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;6、可以查看所有仓库中所有docker版本，并选择特定版本安装&lt;/p&gt;&lt;pre&gt;yum list docker-ce --showduplicates | sort -r&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;7.安装 Docker-ce&lt;/p&gt;&lt;pre&gt;yum install docker-ce&amp;nbsp; #由于repo中默认只开启stable仓库，故这里安装的是docker最新稳定版&lt;/pre&gt;&lt;p&gt;&amp;nbsp; 或&lt;/p&gt;&lt;pre&gt;yum install &amp;lt;指定docker版本&amp;gt;&amp;nbsp; # 例如：sudo yum install docker-ce-17.12.0.ce&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;8.启动 Docker 后台服务&lt;/p&gt;&lt;pre&gt;systemctl start docker&lt;/pre&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp;或开启开机启动&lt;/p&gt;&lt;pre&gt;systemctl enable docker&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)&lt;/p&gt;&lt;pre&gt;docker version&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;修改镜像源地址&lt;/b&gt;&lt;/p&gt;&lt;p&gt;鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：http://hub-mirror.c.163.com。&lt;/p&gt;&lt;p&gt;新版的 Docker 使用 /etc/docker/daemon.json（Linux） 或者 %programdata%\\docker\\config\\daemon.json（Windows） 来配置 Daemon。&lt;/p&gt;&lt;p&gt;请在该配置文件中加入（没有该文件的话，请先建一个）：&lt;/p&gt;&lt;pre&gt;{&lt;br&gt;&amp;nbsp; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&lt;b&gt;重新加载并重启docker&lt;/b&gt;&lt;/p&gt;&lt;pre&gt;[root@foundation19 docker]# systemctl daemon-reload&lt;br&gt;[root@foundation19 docker]# systemctl restart docker&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;10.测试运行 hello-world&amp;nbsp;&lt;/p&gt;&lt;pre style=&quot;line-height: 1.42857;&quot;&gt;docker run hello-world #由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器内运行。&lt;/pre&gt;&lt;p&gt;（运行时可能会超时，多运行几次）&lt;/p&gt;&lt;pre&gt;[root@localhost docker]# docker run hello-world&lt;br&gt;Unable to find image \'hello-world:latest\' locally&lt;br&gt;latest: Pulling from library/hello-world&lt;br&gt;1b930d010525: Pulling fs layer&amp;nbsp;&lt;br&gt;latest: Pulling from library/hello-world&lt;br&gt;1b930d010525: Pull complete&amp;nbsp;&lt;br&gt;Digest: sha256:c3b4ada4687bbaa170745b3e4dd8ac3f194ca95b2d0518b417fb47e5879d9b5f&lt;br&gt;Status: Downloaded newer image for hello-world:latest&lt;br&gt;Hello from Docker!&lt;br&gt;This message shows that your installation appears to be working correctly.&lt;br&gt;To generate this message, Docker took the following steps:&lt;br&gt;&amp;nbsp;1. The Docker client contacted the Docker daemon.&lt;br&gt;&amp;nbsp;2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.&lt;br&gt;&amp;nbsp; &amp;nbsp; (amd64)&lt;br&gt;&amp;nbsp;3. The Docker daemon created a new container from that image which runs the&lt;br&gt;&amp;nbsp; &amp;nbsp; executable that produces the output you are currently reading.&lt;br&gt;&amp;nbsp;4. The Docker daemon streamed that output to the Docker client, which sent it&lt;br&gt;&amp;nbsp; &amp;nbsp; to your terminal.&lt;br&gt;To try something more ambitious, you can run an Ubuntu container with:&lt;br&gt;&amp;nbsp;$ docker run -it ubuntu bash&lt;br&gt;Share images, automate workflows, and more with a free Docker ID:&lt;br&gt;&amp;nbsp;https://hub.docker.com/&lt;br&gt;For more examples and ideas, visit:&lt;br&gt;&amp;nbsp;https://docs.docker.com/get-started/&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;删除 Docker CE&lt;/b&gt;&lt;/p&gt;&lt;p&gt;执行以下命令来删除 Docker CE：&lt;/p&gt;&lt;pre&gt;yum remove docker-ce&lt;br&gt;rm -rf /var/lib/docker&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                                                                                                                                                                        ',0,'2018-06-06 00:00:00','35',54),(208,1,'详解Java的自动装箱与拆箱','','\n                                &lt;div&gt;简单一点说，装箱就是自动将基本数据类型转换为包装类型（包装类型是有一个对象可以调用方法）；拆箱就是自动将包装类型转换为基本数据类型。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;下面我们来看看需要装箱拆箱的类型有哪些：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191021/b442b5da9bb372e99446b17ae505f543.png&quot; data-filename=&quot;img&quot; style=&quot;width: 278px;&quot;&gt;&lt;/div&gt;&lt;pre&gt;&amp;nbsp;//自动装箱&lt;br&gt;&amp;nbsp; Integer total = 10;&lt;br&gt;&amp;nbsp; //自定拆箱&lt;br&gt;&amp;nbsp; int totalprim = total;&lt;/pre&gt;&lt;div&gt;&lt;pre&gt;Integer total = 10;&amp;nbsp;&lt;br&gt;执行上面那句代码的时候，系统为我们执行了：&amp;nbsp;&lt;br&gt;Integer total = Integer.valueOf(10);&lt;br&gt;int totalprim = total;&amp;nbsp;&lt;br&gt;执行上面那句代码的时候，系统为我们执行了：&amp;nbsp;&lt;br&gt;int totalprim = total.intValue();&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们现在就以Integer为例，来分析一下它的源码：&amp;nbsp;&lt;/p&gt;&lt;p&gt;1、首先来看看Integer.valueOf函数&lt;/p&gt;&lt;pre&gt;public static Integer valueOf(int i) {&lt;br&gt;     return&amp;nbsp; i &amp;gt;= 128 || i &amp;lt; -128 ? new Integer(i) : SMALL_VALUES[i + 128];&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&lt;b&gt;上面的源码表示，数值在大于等于128这个区间或则是小于等于-128这个区间的数值，自动装箱时返回一个新的对象，否则会在SMALL_VALUES数组里得到同一个对象&lt;/b&gt;&lt;/p&gt;&lt;p&gt;下面代码：&lt;/p&gt;&lt;pre&gt;Integer i1 = 100;&lt;br&gt;Integer i2 = 100;&lt;br&gt;Integer i3 = 200;&lt;br&gt;Integer i4 = 200;&lt;br&gt;System.out.println(i1==i2);&amp;nbsp; //true&lt;br&gt;System.out.println(i3==i4);&amp;nbsp; //false&lt;/pre&gt;&lt;p&gt;由于上面数据都是装箱类型，所以 == 比较的是对象，而不是数值；&lt;/p&gt;&lt;p&gt;又因为&lt;/p&gt;&lt;p&gt;100：不在 i &amp;gt;= 128 || i &amp;lt; -128&amp;nbsp; 这个区间，所以它是在SMALL_VALUES数组里获取同一个对象&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;200：在 i &amp;gt;= 128 || i &amp;lt; -128&amp;nbsp; 这个区间，自动装箱它会创建新的对象&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;Double i1 = 100.0;&lt;br&gt;Double i2 = 100.0;&lt;br&gt;Double i3 = 200.0;&lt;br&gt;Double i4 = 200.0;&lt;br&gt;System.out.println(i1==i2); //false&lt;br&gt;System.out.println(i3==i4); //false&lt;/pre&gt;&lt;p&gt;对于Double类型来说，我们就不能这样做，因为它在这个范围内个数是无限的。 所以在Double里面的做法很直接，就是直接创建一个对象，所以每次创建的对象都不一样。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;下面我们进行一个归类：&amp;nbsp;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Integer派别：Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。&amp;nbsp;&lt;/p&gt;&lt;p&gt;Double派别：Double、Float的valueOf方法的实现是类似的。每次都返回不同的对象。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;1.等号 == 两边有包装类和基本数据类型，会自动拆箱，所以比较的是值&amp;nbsp;&lt;/p&gt;&lt;pre&gt;Integer num1 = 400;&amp;nbsp;&amp;nbsp;&lt;br&gt;int num2 = 400;&amp;nbsp;&amp;nbsp;&lt;br&gt;System.out.println(num1 == num2); //true&lt;/pre&gt;&lt;p&gt;注：当一个基础数据类型与封装类进行==、+、-、*、/运算时，会将封装类进行拆箱，对基础数据类型进行运算。&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;\n                                                                                        ',0,'2019-10-21 00:00:00','34',37),(209,1,'多线程下的线程安全问题的产生','','\n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;定义：线程安全是多线程编程下,多条线程并行执行对共享数据进行操作时，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;问题分析：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;既然是线程安全问题，那么毫无疑问所有的隐患都是出现在多个线程访问的情况下产生的，也就是我们要确保在多条线程访问的时候，我们的程序还能按照我们预期的行为去执行，我们看一下下面的代码。&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;background-color:#272822;color:#ffffff;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public class &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;MyThread &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;implements  &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Runnable&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;{&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public static  int &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;count &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;20&lt;/span&gt;; &lt;span style=&quot;color:#74715e;&quot;&gt;// 票数&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Object &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;objLock &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Object&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;() &lt;/span&gt;;&lt;br&gt;    &lt;span style=&quot;color:#d9e577;&quot;&gt;@Override&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#d9e577;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public void &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;run&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;() {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;while&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;count&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;) {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;try &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;{&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;                &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#cfbfad;&quot;&gt;sleep&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;200&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;            &lt;span style=&quot;color:#f9faf4;&quot;&gt;} &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;catch &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;InterruptedException &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;e&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;) {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;                &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;e&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;printStackTrace&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;;&lt;br&gt;            &lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;sale&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    }&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public  void  &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;sale&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(){&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;System&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;out&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;println&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#cfbfad;&quot;&gt;currentThread&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;getName&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;-卖出第:&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;20 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;- &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;count &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;))&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;count&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;--&lt;/span&gt;;&lt;br&gt;    &lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public static void &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;String&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;[] &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;args&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;) {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;MyThread &lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;thread &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;MyThread&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread &lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;mThread1 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;thread&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;售票窗口01&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread &lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;mThread2 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;thread&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;售票窗口02&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread &lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;mThread3 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;thread&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;售票窗口03&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;font-weight:bold;&quot;&gt;mThread1&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;start&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;font-weight:bold;&quot;&gt;mThread2&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;start&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;font-weight:bold;&quot;&gt;mThread3&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;start&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;;&lt;br&gt;    &lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;售票窗口02-卖出第:1&lt;/div&gt;&lt;div&gt;售票窗口01-卖出第:1&lt;/div&gt;&lt;div&gt;售票窗口03-卖出第:1&lt;/div&gt;&lt;div&gt;售票窗口01-卖出第:4&lt;/div&gt;&lt;div&gt;售票窗口03-卖出第:5&lt;/div&gt;&lt;div&gt;售票窗口02-卖出第:6&lt;/div&gt;&lt;div&gt;售票窗口01-卖出第:7&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;由运行结果可以看出三个售票口同时卖出了第一张票，这从逻辑上是有问题的&lt;/div&gt;&lt;div&gt;&lt;div&gt;这是由于程序并发带来的问题，在售卖第一张票时两个线程同时进入了售票的方法，&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;当第一个进来的线程还没来得及进行 count-- 操作，其它的线程已经执行了&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;System.out.println(Thread.currentThread().getName()+&quot;-卖出第:&quot;+(20 - count +1));&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;所以出现了上面的情况&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;总结：在多线程编程中，这种存在竞争的线程就会出现线程安全问题&lt;/b&gt;&lt;/div&gt;&lt;/div&gt;\n                                                                                        ',0,'2019-10-22 00:00:00','34',54),(210,1,'java 线程安全的解决方案','','\n                                \n                                &lt;div&gt;&lt;div style=&quot;&quot;&gt;多线程的数据安全性问题分为三种：原子性、可见性和有序性。&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;原子性:&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;是指我们的一系列操作要么全部都做，要么全部不做。&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;div&gt;&lt;b&gt;可见性&lt;/b&gt;&lt;/div&gt;&lt;div&gt;java内存模型规定，每个java线程可以有自己的工作内存，工作内存是线程私有的，而共享内存（主存）是线程共享的。线程工作内存中会有共享变量的副本，当线程对一个共享变量进行写入时，会先写入线程私有的工作内存，然后再刷新到主存中。&lt;/div&gt;&lt;div&gt;这样就可能会产生一个问题：线程1改变了共享变量的值，在还未刷新到主存时候，线程2去读取这个变量，此时线程2将看不到线程1对这个变量所做的修改。这就是多线程并发带来的数据可见性问题。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;img src=&quot;/upload/article/20191022/ee6f1062ae25199f54719577739ec0b8.png&quot; data-filename=&quot;img&quot; style=&quot;width: 600px;&quot;&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;div&gt;java中可以通过申明一个变量为volatile来解决可见性问题。线程读取一个volatile变量时JMM会强制要求线程从主内存中读取，写一个volatile变量时JMM会要求立马刷新到主内存中。java中通过synchronized加锁后的写入也可以保证数据的可见性。&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;volatile能够解决可见性和有序性但是不能保证原子性&lt;/span&gt;，如果需要保证原子性则需要加锁。这里有一点需要注意的是：volatile类型的long，double变量的读取是原子读取，而非volatile的long，double类型变量读取是非原子读取，所以也可以说volatile在一定程度上解决了原子性问题。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;有序性:&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;如果在本线程内观察，所有操作都是有序的，但是如果在一个线程观察另一个线程，所有的操作都是无序的。产生这种问题的根本原因在于&quot;指令重排序&quot;和&quot;工作内存和主内存同步延迟&quot;。java中volatile变量通过内存屏障来防止指令重排序从而保证有序。&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;为了解决多线程的数据安全性问题，java中引入了锁，锁是为了防止在多线程同时读写一个共享内存时出现的并发数据安全性问题。Java中的锁大体分为两类：&quot;synchronized&quot;关键字锁和&quot;JUC&quot;(java.util.concurrent包)中的locks包和atomic中提供的锁。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;1.创建线程的两种方式\n&lt;/b&gt;&lt;br class=&quot;Apple-interchange-newline&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;01.继承Thread类。&lt;/div&gt;&lt;div&gt;02.实现Runnable接口。（这种方式较为常用）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;2.实现Runnable接口的好处&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;01.将线程的任务从线程的子类中分离出来，进行了单独的封装。按照面向对象的思想将任务的封装成对象。&lt;/div&gt;&lt;div&gt;02.避免了java单继承的局限性。&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;产生线程安全的原因：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;多个线程在操作共享的数据。&lt;/li&gt;&lt;li&gt;操作共享数据的线程代码有多条。&lt;/li&gt;&lt;li&gt;当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算。就会导致线程安全问题的产生。&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;解决思路:&lt;/b&gt;&lt;/div&gt;&lt;div&gt;就是将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程时不可以参与运算的。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算。在java中，用同步代码块就可以解决这个问题。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;synchronized&lt;/b&gt; 同步代码块的格式&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;synchronized(对象)&lt;br&gt;{&lt;br&gt;     需要被同步的代码;&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;同步的好处：解决了线程的安全问题。&lt;/p&gt;&lt;p&gt;同步的弊端：相对降低了效率，因为同步外的线程的都会判断同步锁。&lt;/p&gt;&lt;p&gt;同步的前提：同步中必须有多个线程并使用同一个锁。&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;background-color:#272822;color:#ffffff;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public class &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;MyThread &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;implements  &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Runnable&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;{&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public static  int &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;count &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;10&lt;/span&gt;; &lt;span style=&quot;color:#74715e;&quot;&gt;// 票数&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Object &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;objLock &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Object&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;() &lt;/span&gt;;&lt;br&gt;    &lt;span style=&quot;color:#d9e577;&quot;&gt;@Override&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#d9e577;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public void &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;run&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;() {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;while&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;count&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;) {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;try &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;{&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;                &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#cfbfad;&quot;&gt;sleep&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;200&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;            &lt;span style=&quot;color:#f9faf4;&quot;&gt;} &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;catch &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;InterruptedException &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;e&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;) {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;                &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;e&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;printStackTrace&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;;&lt;br&gt;            &lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;sale&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    }&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public  void  &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;sale&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(){&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#74715e;font-style:italic;&quot;&gt;/**&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;font-style:italic;&quot;&gt;         *  使用synchronized 给对象加锁，只有拿到这个对象锁的线程才能进入到内部进行程序操作，拿到锁的线程执行完&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;font-style:italic;&quot;&gt;         *  内部的程序后，会自动释放对象锁，进行一下次的锁竞争中&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;font-style:italic;&quot;&gt;         */&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;font-style:italic;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;synchronized&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;objLock&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;){&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;count &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;) {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;                &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;System&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;out&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;println&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#cfbfad;&quot;&gt;currentThread&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;getName&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;-卖出第:&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;20 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;- &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;count &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;))&lt;/span&gt;;&lt;br&gt;                &lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;count&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;--&lt;/span&gt;;&lt;br&gt;            &lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        }&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    }&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public static void &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;String&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;[] &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;args&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;) {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;MyThread &lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;thread &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;MyThread&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread &lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;mThread1 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;thread&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;售票窗口01&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread &lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;mThread2 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;thread&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;售票窗口02&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread &lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;mThread3 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;thread&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;售票窗口03&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;font-weight:bold;&quot;&gt;mThread1&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;start&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;font-weight:bold;&quot;&gt;mThread2&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;start&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;font-weight:bold;&quot;&gt;mThread3&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;start&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;;&lt;br&gt;    &lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;售票窗口02-卖出第:1&lt;/div&gt;&lt;div&gt;售票窗口03-卖出第:2&lt;/div&gt;&lt;div&gt;售票窗口01-卖出第:3&lt;/div&gt;&lt;div&gt;售票窗口02-卖出第:4&lt;/div&gt;&lt;div&gt;售票窗口03-卖出第:5&lt;/div&gt;&lt;div&gt;售票窗口01-卖出第:6&lt;/div&gt;&lt;div&gt;售票窗口02-卖出第:7&lt;/div&gt;&lt;div&gt;售票窗口03-卖出第:8&lt;/div&gt;&lt;div&gt;售票窗口01-卖出第:9&lt;/div&gt;&lt;div&gt;售票窗口02-卖出第:10&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这个方案只是最基本的解决方案&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: 700; color: rgb(51, 51, 51); font-family: -apple-system, system-ui, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px;&quot;&gt;注意点&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, system-ui, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px;&quot;&gt;：虽然加synchronized关键字可以让我们的线程变的安全，但是我们在用的时候也要注意缩小synchronized的使用范围，如果随意使用时很影响程序的性能，&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, system-ui, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;-apple-system, system-ui, BlinkMacSystemFont, Helvetica Neue, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 15px;&quot;&gt;&lt;b&gt;Lock&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;-apple-system, system-ui, BlinkMacSystemFont, Helvetica Neue, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 15px;&quot;&gt;先来说说它跟synchronized有什么区别吧，Lock是在Java1.6被引入进来的，Lock的引入让锁有了可操作性，什么意思？就是我们在需要的时候去手动的获取锁和释放锁，甚至我们还可以中断获取以及超时获取的同步特性，但是从使用上说Lock明显没有synchronized使用起来方便快捷。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, system-ui, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px;&quot;&gt;&lt;pre style=&quot;background-color:#272822;color:#ffffff;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public class &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;MyThread &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;implements  &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Runnable&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;{&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public static  int &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;count &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;0&lt;/span&gt;;&lt;br&gt;    &lt;span style=&quot;color:#f92772;&quot;&gt;private &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Lock &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;lock &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;ReentrantLock&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;; &lt;span style=&quot;color:#74715e;&quot;&gt;// ReentrantLock是Lock的子类&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#d9e577;&quot;&gt;@Override&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#d9e577;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public void &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;run&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;() {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;method&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;;&lt;br&gt;    &lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;private void &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;method&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(){&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;lock&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;lock&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;; &lt;span style=&quot;color:#74715e;&quot;&gt;// 获取锁对象&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;try &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;{&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;System&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;out&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;println&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;线程名：&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#cfbfad;&quot;&gt;currentThread&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;getName&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;() &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+ &lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;获得了锁&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;            &lt;span style=&quot;color:#a7e22e;&quot;&gt;System&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;out&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;println&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;count:&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;count&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;++&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;             &lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#cfbfad;&quot;&gt;sleep&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;2000&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;catch&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Exception &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;e&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;){&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;e&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;printStackTrace&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;color:#f9faf4;&quot;&gt;} &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;finally &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;{&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;System&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;out&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;println&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;线程名：&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#cfbfad;&quot;&gt;currentThread&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;getName&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;() &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;+ &lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;释放了锁&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;            &lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;lock&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;unlock&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;; &lt;span style=&quot;color:#74715e;&quot;&gt;// 释放锁对象&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    }&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public static void &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;String&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;[] &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;args&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;) {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;MyThread &lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;thread &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;MyThread&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread &lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;mThread1 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;thread&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;线程01&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread &lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;mThread2 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;thread&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;线程02&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread &lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;mThread3 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Thread&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;thread&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;,&lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;线程03&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;font-weight:bold;&quot;&gt;mThread1&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;start&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;font-weight:bold;&quot;&gt;mThread2&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;start&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;font-weight:bold;&quot;&gt;mThread3&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;start&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()&lt;/span&gt;;&lt;br&gt;    &lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;div style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, system-ui, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px;&quot;&gt;线程名：线程01获得了锁&lt;/div&gt;&lt;div style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, system-ui, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px;&quot;&gt;count:0&lt;/div&gt;&lt;div style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, system-ui, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px;&quot;&gt;线程名：线程01释放了锁&lt;/div&gt;&lt;div style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, system-ui, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px;&quot;&gt;线程名：线程02获得了锁&lt;/div&gt;&lt;div style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, system-ui, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px;&quot;&gt;count:1&lt;/div&gt;&lt;div style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, system-ui, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px;&quot;&gt;线程名：线程02释放了锁&lt;/div&gt;&lt;div style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, system-ui, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px;&quot;&gt;线程名：线程03获得了锁&lt;/div&gt;&lt;div style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, system-ui, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px;&quot;&gt;count:2&lt;/div&gt;&lt;div style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, system-ui, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px;&quot;&gt;线程名：线程03释放了锁&lt;/div&gt;&lt;div style=&quot;color: rgb(51, 51, 51); font-family: -apple-system, system-ui, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; font-size: 15px;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;-apple-system, system-ui, BlinkMacSystemFont, Helvetica Neue, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 15px;&quot;&gt;进入方法我们首先要获取到锁，然后去执行我们业务代码，这里跟synchronized不同的是，Lock获取的所对象需要我们亲自去进行释放，为了防止我们代码出现异常，所以我们的释放锁操作放在finally中，因为finally中的代码无论如何都是会执行的。&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;-apple-system, system-ui, BlinkMacSystemFont, Helvetica Neue, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 15px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;-apple-system, system-ui, BlinkMacSystemFont, Helvetica Neue, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Arial, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 15px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;\n                                                                                                                    ',0,'2019-10-22 00:00:00','34',28),(211,1,'java基本类型和包装类型的区别','','&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;01.&lt;b&gt;包装类型可以为 null，而基本类型不可以&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;包装类型可以应用于 POJO 中，而基本类型则不行。比如我们在使用spring的时候定义的实体类属性我们就用包装类型&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;class User{&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;private Integer age;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;private String name;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;public Integer getAge() {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;return age;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;public void setAge(Integer age) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;this.age = age;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;public String getName() {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;return name;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;public void setName(String name) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;this.name = name;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;《阿里巴巴 Java 开发手册》上有详细的说明&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;数据库的查询结果可能是 null，如果使用基本类型的话，就会抛出 NullPointerException 的异常。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;02、包装类型可用于泛型，而基本类型不可以&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;List&amp;lt;int&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); // 提示 Syntax error, insert &quot;Dimensions&quot; to complete ReferenceType&lt;br&gt;List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;03、&lt;b&gt;基本类型比包装类型更高效&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用。&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191022/1263dc1147a39fabc436983e493dca90.png&quot; data-filename=&quot;img&quot; style=&quot;width: 448px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;很显然，相比较于基本类型而言，包装类型需要占用更多的内存空间。假如没有基本类型的话，对于数值这类经常使用到的数据来说，每次都要通过 new 一个包装类型就显得非常笨重。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;03、&lt;b&gt;两个包装类型的值可以相同，但却不相等&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;Integer chenmo = new Integer(10);&lt;br&gt;Integer wanger = new Integer(10);&lt;br&gt;System.out.println(chenmo == wanger); // false&lt;br&gt;System.out.println(chenmo.equals(wanger )); // true&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;“==”两边比较的是对象，所以为false，而equals回自动拆箱，比较的是数值&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\n                                                            ',0,'2019-10-22 00:00:00','34',49),(212,1,'重写equals()方法的同时必须要重写hashcode()方法？','','\n                                \n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;== ：主要用于基本类型之间的比较（char、Boolean、byte、short、int、long、float、dobule），也可以用于比较对象&lt;br&gt;&lt;/div&gt;&lt;div&gt;equals: 对象之间的比较（基本类型的包装器类型，string，自己定义的对象等）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;基本类型的包装器类型、string已经帮我们重写了equals方法，所有他们比较的是值。但是我们自定义的对象比较还是集成了Object的equals方法&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;所以不重写equals方法比较是没有意义的；因为它们始终比较的值对象的引用地址。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;对于一个对象student来说，如果我们不重写它的equals方法，那么和==符号一样比较的是对象的引用而不是内容&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;background-color:#272822;color:#ffffff;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public class &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Student &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;{&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;private int &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;id&lt;/span&gt;;&lt;br&gt;    &lt;span style=&quot;color:#f92772;&quot;&gt;private &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;String &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;name&lt;/span&gt;;&lt;br&gt;    &lt;span style=&quot;color:#f92772;&quot;&gt;private &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;String &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;password&lt;/span&gt;;&lt;br&gt;&lt;br&gt;&lt;br&gt;    &lt;span style=&quot;color:#f92772;&quot;&gt;public &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;font-weight:bold;&quot;&gt;Student&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;int &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;id&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;String &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;name&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;String &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;password&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;) {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;this.&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;id &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;id&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;color:#f92772;&quot;&gt;this.&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;name &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;name&lt;/span&gt;;&lt;br&gt;        &lt;span style=&quot;color:#f92772;&quot;&gt;this.&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;password &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;password&lt;/span&gt;;&lt;br&gt;    &lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;background-color:#272822;color:#ffffff;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Student &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;s1 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Student&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;A&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;123456&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Student &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;s2 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Student&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;B&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;123456&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;&lt;br&gt;System&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;out&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;println&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;s1 &lt;span style=&quot;color:#f92772;&quot;&gt;== &lt;/span&gt;s2&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;span style=&quot;color:#74715e;&quot;&gt;//false&lt;br&gt;&lt;/span&gt;System&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;out&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;println&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;s1&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;equals&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;s2&lt;span style=&quot;color:#f9faf4;&quot;&gt;))&lt;/span&gt;;&lt;span style=&quot;color:#74715e;&quot;&gt;//false&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;上面两个对象s1和s2不相等，因为他们指向的是两个不同的对象，所以引用不同，但是我们的目的是要达到如果id,name,password都相同，那么就是同一个对象，所以需要重写equals()方法&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;background-color:#272822;color:#ffffff;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#d9e577;&quot;&gt;@Override&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public boolean &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;equals&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Object &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;o&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;) {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;this == &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;o&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;return true&lt;/span&gt;;&lt;br&gt;    &lt;span style=&quot;color:#f92772;&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;o &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;== null || &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;getClass&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;() &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;!= &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;o&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;getClass&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;()) &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;return false&lt;/span&gt;;&lt;br&gt;&lt;br&gt;    &lt;span style=&quot;color:#a7e22e;&quot;&gt;Student &lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;student &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Student&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;o&lt;/span&gt;;&lt;br&gt;&lt;br&gt;    &lt;span style=&quot;color:#f92772;&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;id &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;!= &lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;student&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;id&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;return false&lt;/span&gt;;&lt;br&gt;    &lt;span style=&quot;color:#f92772;&quot;&gt;if &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;name &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;!= null ? !&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;name&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;equals&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;student&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;name&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;student&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;name &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;!= null&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;return false&lt;/span&gt;;&lt;br&gt;    &lt;span style=&quot;color:#f92772;&quot;&gt;return &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;password &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;!= null ? &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;password&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;equals&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;student&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;password&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;student&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;password &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;== null&lt;/span&gt;;&lt;br&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;这个时候：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;background-color:#272822;color:#ffffff;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Student &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;s1 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Student&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;A&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;123456&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Student &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;s2 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Student&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;B&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;123456&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;&lt;br&gt;System&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;out&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;println&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;s1 &lt;span style=&quot;color:#f92772;&quot;&gt;== &lt;/span&gt;s2&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;span style=&quot;color:#74715e;&quot;&gt;//false&lt;br&gt;&lt;/span&gt;System&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;out&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;println&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;s1&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;equals&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;s2&lt;span style=&quot;color:#f9faf4;&quot;&gt;))&lt;/span&gt;;&lt;span style=&quot;color:#74715e;&quot;&gt;//true&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;讨论一下重写equals()方法的同时必须要重写hashcode()方法吗&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;​&amp;nbsp; 首先我们重写equals()的目的就是为了让内容相同的对象让它们相等，而不是单单只比较对象的引用地址，如果是比较地址那两个对象永远不可能相等；也就是尽管这两个对象的引用地址不同，但是只要它们的内容（所有的属性值）相同，我们调用equals方法的时候仍然返回true。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;那么这个时候我们为什么又要重写hashcode方法呢，hashcode()返回的是对象的地址，是一个散列值，那么如果我们通过equals()方法得到这两个对象相同，尽管他们在堆中的内存地址不一样，但是我们希望他们的哈希值是一样的，这样如果存入map的话，就能定位到相同的索引&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;&lt;div&gt;&lt;b&gt;同时Java标准中对hashcode有如下的规定：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;在java应用程序执行期间，如果在equals方法比较中所用的信息没有被修改，那么在同一个对象上多次调用hashCode方法时必须一致地返回相同的整数。如果多次执行同一个应用时，不要求该整数必须相同。&lt;/li&gt;&lt;li&gt;如果两个对象通过调用equals方法是相等的，那么这两个对象调用hashCode方法必须返回相同的整数。&lt;/li&gt;&lt;li&gt;如果两个对象通过调用equals方法是不相等的，不要求这两个对象调用hashCode方法必须返回不同的整数。&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果我们不重写student的hashcode()方法，那么就会默认调用object的hashcode()方法：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;background-color:#272822;color:#ffffff;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public static void &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;String&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;[] &lt;/span&gt;&lt;span style=&quot;color:#fe9720;&quot;&gt;args&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;) {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Student &lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;s1 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Student&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;A&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;123456&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;    &lt;span style=&quot;color:#a7e22e;&quot;&gt;Student &lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;s2 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Student&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;B&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;123456&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;    &lt;span style=&quot;color:#a7e22e;&quot;&gt;System&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;out&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;println&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;s1 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;== &lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;s2&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;span style=&quot;color:#74715e;&quot;&gt;//false&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;System&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;out&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;println&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;s1&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;equals&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;s2&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;))&lt;/span&gt;;&lt;span style=&quot;color:#74715e;&quot;&gt;//true&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;System&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;out&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;println&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;s1&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;hashCode&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;())&lt;/span&gt;;&lt;span style=&quot;color:#74715e;&quot;&gt;//356573597&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#74715e;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;System&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;font-style:italic;&quot;&gt;out&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;println&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;font-weight:bold;&quot;&gt;s2&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;hashCode&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;())&lt;/span&gt;;&lt;span style=&quot;color:#74715e;&quot;&gt;//1735600054&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;我们可以看到以上的运行结果违背了hashcode的规定：如果equals()返回true，那么hashcode方法必须返回相同的整数&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;所以我们需要对student对象的hashcode方法进行重写&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;background-color:#272822;color:#ffffff;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#d9e577;&quot;&gt;@Override&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;public int &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;hashCode&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;() {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;int &lt;/span&gt;result &lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;id&lt;/span&gt;;&lt;br&gt;    result &lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;31 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;* &lt;/span&gt;result &lt;span style=&quot;color:#f92772;&quot;&gt;+ &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;name &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;!= null ? &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;name&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;hashCode&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;() &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;    result &lt;span style=&quot;color:#f92772;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;31 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;* &lt;/span&gt;result &lt;span style=&quot;color:#f92772;&quot;&gt;+ &lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;password &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;!= null ? &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;password&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;hashCode&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;() &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;    &lt;span style=&quot;color:#f92772;&quot;&gt;return &lt;/span&gt;result;&lt;br&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;通过重写hashcode()让其与对象的属性关联起来，那么就能够达到equals()为true，那么hashcode的值也相等。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;现在我们已经知道了重写equals()方法的同时需要重写对象的hashcode()方法，让其满足hashcode的标准条件。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;为什么hashcode需要这样定义标准呢，&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这样做到底有什么好处呢，这里我们就需要提到map类了，我们知道hashmap的结构是一个数组加链表组成的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;它的存储原理就是通过存入的value值对象的hashcode % capacity 计算该value在hashmap数组中的索引，然后将该(key,value)放入该索引对应的链表里面;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;background-color:#272822;color:#ffffff;font-family:\'宋体\';font-size:12.0pt;&quot;&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Student &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;s1 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Student&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;A&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;123456&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;br&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Student &lt;/span&gt;&lt;span style=&quot;color:#66d9ee;font-weight:bold;&quot;&gt;s2 &lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;= new &lt;/span&gt;&lt;span style=&quot;color:#a7e22e;&quot;&gt;Student&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#ae81ff;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;B&quot;&lt;/span&gt;&lt;span style=&quot;color:#f92772;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#e6da74;&quot;&gt;&quot;123456&quot;&lt;/span&gt;&lt;span style=&quot;color:#f9faf4;&quot;&gt;)&lt;/span&gt;;&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;对于s1和s2两个对象，如果我们我们已经将s1存入一个map对象，那么我们再存入s2时，我们希望的是这是不能再插入map了，因为此时map中已经存在小王这个对象了，那么如何才能做到呢&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;首先我们通过s1的hashcode % capacity 得到了一个数组索引，然后将s1这个对象存入map,那么我们再插入s2的时候同样也需要计算它的hashcode，然后定位到相同的数组索引，然后判断该链表中是否存在小王这样一个对象，如果存在就不put&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;所以我们需要得到的s1和s2的hashcode相同，才能避免同一个对象被put进入map中多次，所以我们才需要在重写equals()方法的同时重写hashcode()方法，让两个相等的对象具有相同的hashcode&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n                                                                                                                    ',0,'2019-10-20 00:00:00','34',42),(213,1,'ThreadLocal ，ThreadLocalMap 和Thread 的关系','','&lt;div&gt;Thread 中持有一个ThreadLocalMap ，这里你可以简单理解为就是持有一个数组，这个数组是Entry 类型的。&lt;/div&gt;&lt;div&gt;Entry 的key 是ThreadLocal 类型的，value 是Object 类型。也就是一个ThreadLocalMap 可以持有多个ThreadLocal。&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191023/52ce34eecdd8694cbe3dc1afb96afec6.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 622px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;为什么ThreadLocalMap 设计为ThreadLocal 内部类&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191023/75cf836f3448f34f61e080c6b16f58e5.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 648px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;ThreadLocalMap 是一个线程本地的值，它所有的方法都是private 的，也就意味着除了ThreadLocal 这个类，其他类是不能操作ThreadLocalMap 中的任何方法的，这样就可以对其他类是透明的。同时这个类的权限是包级别的，也就意味着只有同一个包下面的类才能引用ThreadLocalMap 这个类，这也是Thread 为什么可以引用ThreadLocalMap 的原因，因为他们在同一个包下面。&lt;/div&gt;&lt;div&gt;虽然Thread 可以引用ThreadLocalMap，但是不能调用任何ThreadLocalMap 中的方法。这也就是我们平时都是通过ThreadLocal 来获取值和设置值，看下以下代码&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;ThreadLocal&amp;lt;String&amp;gt; local = new ThreadLocal&amp;lt;&amp;gt;();&lt;br&gt;local.set(&quot;hello word&quot;);&lt;br&gt;System.out.println(local.get());&lt;/pre&gt;&lt;p&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;ThreadLocal与ThreadLdocalMap的关系&lt;/b&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;但我们调用ThreadLocal 的get 方法的时候，其实我们最后是通过调用ThreadLdocalMap 来获取值的&lt;/p&gt;&lt;pre&gt;public T get() {&lt;br&gt;&amp;nbsp; &amp;nbsp; //这里通过获取当前的线程&lt;br&gt;&amp;nbsp; &amp;nbsp; Thread t = Thread.currentThread();&lt;br&gt;&amp;nbsp; &amp;nbsp; //通过线程来获取ThreadLocalMap ，还记得我们上面说的Thread 里面有一个ThreadLocalMap 属性吗？就是这里用上了&lt;br&gt;&amp;nbsp; &amp;nbsp; ThreadLocalMap map = getMap(t);&lt;br&gt;&amp;nbsp; &amp;nbsp; if (map != null) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ThreadLocalMap.Entry e = map.getEntry(this);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (e != null) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; @SuppressWarnings(&quot;unchecked&quot;)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; T result = (T)e.value;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return result;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; return setInitialValue();&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;我们一值使用的都是ThreadLocal，其实ThreadLdocalMap 对使用者来说是透明的&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;ThreadLdocalMap 什么时候开始和Thread 进行绑定的呢&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在第一次调用ThreadLocal set() 方法的时候开始绑定的，来我们看下set 方法的源码&lt;/p&gt;&lt;pre&gt;public void set(T value) {&lt;br&gt;&amp;nbsp; &amp;nbsp; Thread t = Thread.currentThread();&lt;br&gt;&amp;nbsp; &amp;nbsp; ThreadLocalMap map = getMap(t);&lt;br&gt;&amp;nbsp; &amp;nbsp; if (map != null)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; map.set(this, value);&lt;br&gt;&amp;nbsp; &amp;nbsp; else&lt;br&gt;&amp;nbsp; &amp;nbsp; //第一次的时候进来这里，因为ThreadLocalMap 还没和Thread 绑定&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; createMap(t, value);&lt;br&gt;}&lt;br&gt;//这个时候开始创建一个新的ThreadLocalMap 赋值给Thread 进行绑定&lt;br&gt;void createMap(Thread t, T firstValue) {&lt;br&gt;&amp;nbsp; &amp;nbsp; t.threadLocals = new ThreadLocalMap(this, firstValue);&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;\n                                                            ',0,'2019-10-23 00:00:00','34',40),(214,1,'String、StringBuffer、StringBuilder的区别','','\n                                &lt;div&gt;&lt;b&gt;String字符串常量&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;需要注意的是，String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，这样不仅效率低下，而且大量浪费有限的内存空间。我们来看一下这张对String操作时内存变化的图：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191023/7be5d7b2a497a43f53cddb6e2b6d9e0b.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 728px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;我们可以看到，初始String值为“hello”，然后在这个字符串后面加上新的字符串“world”，这个过程是需要重新在栈堆内存中开辟内存空间的，最终得到了“hello world”字符串也相应的需要开辟内存空间，这样短短的两个字符串，却需要开辟三次内存空间，不得不说这是对内存空间的极大浪费。为了应对经常性的字符串相关的操作，谷歌引入了两个新的类——StringBuffer类和StringBuild类来对此种变化字符串进行处理。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;StringBuffer 字符串变量、StringBuilder字符串变量&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;StringBuffer是线程安全的，而StringBuilder是非线程安全的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191023/b1aad0a7f0b26586881f9403d085a307.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 502px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;小结：（1）如果要操作少量的数据用 String；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;（2）多线程操作字符串缓冲区下操作大量数据 StringBuffer；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;（3）单线程操作字符串缓冲区下操作大量数据 StringBuilder。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;注：&lt;b&gt;StringBuffer之所以是线程安全的是因为StringBuffer中的方法都加了synchronized关键字&lt;/b&gt;&lt;br&gt;&lt;/div&gt;\n                                                                                        ',0,'2019-10-23 00:00:00','34',34),(215,1,'HashMap底层原理解析','','\n                                &lt;div&gt;&lt;div&gt;HashMap概述&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 在JDK1.8之前，HashMap采用数组+链表实现，即使用链表处理冲突，也就是说同一hash值的节点都存储在哈希数组同一下标下的一个链表里。但是当一个链表太长（元素较多）时，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;下图中代表jdk1.8之前的hashmap结构，左边部分即代表哈希数组，数组的每个元素都是链表中的一个节点，链表是用来解决冲突的，也就是说不同的key可能hash(key)的值相同，即它们在哈希数组中的下标相同，就将其放入单链表中。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191024/a9a7085634e9afd7c468e706feb8b44a.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 659px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;jdk1.8之前的hashmap都采用上图的结构，都是基于一个数组和多个单链表，hash值冲突的时候，就将对应节点以链表的形式存储。如果在一个链表中查找其中一个节点时，将会花费O（n）的查找时间，会有很大的性能损失。到了jdk1.8，当同一个链表的节点数大于等于8时，不再采用单链表形式存储，而是采用红黑树，如下图所示。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191024/e19cc3fdccb516b1784be3c580ba50e5.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 385px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;说明：上图很形象的展示了HashMap的数据结构（数组+链表+红黑树），桶中的结构可能是链表，也可能是红黑树，红黑树的引入是为了提高效率。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;HashMap的存储原理&lt;/b&gt;：首先每个元素（key,value）都是哈希数组下标中链表的一个节点，当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的索引位置，但是可能由于hash值相同，某个数组下标中已经有其它节点数据了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，这样就形成了链表，所以说数组存放的是链表。而当链表长度太长时（大于等于8）时，链表就转换为红黑树，这样大大提高了查找的效率。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;HashMap 的源码分析&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;public class HashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; implements Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;//所能容纳的key-value对极限&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;int threshold;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;//负载因子&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;final float loadFactor;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;//记录修改次数&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;int modCount;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;//实际存在的键值对数量&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;int size;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;//哈希桶数组&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;transient Node&amp;lt;K,V&amp;gt;[] table;&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&lt;b&gt;主要有 5 个关键参数：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;threshold：表示容器所能容纳的 key-value 对极限。&lt;/p&gt;&lt;p&gt;loadFactor：负载因子。&lt;/p&gt;&lt;p&gt;modCount：记录修改次数。&lt;/p&gt;&lt;p&gt;size：表示实际存在的键值对数量。&lt;/p&gt;&lt;p&gt;table：一个哈希桶数组，键值对就存放在里面。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接着来看看Node这个类，Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)&lt;/p&gt;&lt;pre&gt;static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; final int hash;//hash值&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; final K key;//k键&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; V value;//value值&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Node&amp;lt;K,V&amp;gt; next;//链表中下一个元素&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&lt;b&gt;在 HashMap 的数据结构中，有两个参数可以影响 HashMap 的性能：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;初始容量（inital capacity）和负载因子（load factor）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;初始容量&lt;/b&gt;（inital capacity）是指 table 的初始长度 length（默认值是 16）；&lt;/p&gt;&lt;p&gt;&lt;b&gt;负载因子&lt;/b&gt;（load factor）用指自动扩容的临界值（默认值是 0.75）；&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;threshold是HashMap所能容纳的最大数据量的Node(键值对)个数，计算公式threshold = capacity * Load factor。&lt;/p&gt;&lt;p&gt;当 Node的数量超过capacity*load_factor时，容器将自动扩容并重新哈希，扩容后的HashMap容量是之前容量的两倍，所以数组的长度总是 2 的 n 次方。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;初始容量和负载因子也可以修改，具体实现方式，可以在对象初始化的时候，指定参数，比如：&lt;/p&gt;&lt;pre&gt;Map map = new HashMap(int initialCapacity, float loadFactor);&lt;/pre&gt;&lt;p&gt;但是，默认的负载因子 0.75 是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子 Load factor 的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子 loadFactor 的值，这个值可以大于 1。同时，对于插入元素较多的场景，可以将初始容量设大，减少重新哈希的次数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;HashMap 的内部功能实现有很多，本文主要从以下几点，进行逐步分析。&lt;/p&gt;&lt;p&gt;通过 K 获取数组下标；&lt;/p&gt;&lt;p&gt;put 方法的详细执行；&lt;/p&gt;&lt;p&gt;resize 扩容过程；&lt;/p&gt;&lt;p&gt;get 方法获取参数值；&lt;/p&gt;&lt;p&gt;remove 删除元素；&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;通过 K 获取数组下标&lt;/b&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;不管增加、删除还是查找键值对，定位到数组的位置都是很关键的第一步，打开 hashMap 的任意一个增加、删除、查找方法，从源码可以看出，通过key（我们保存数据的(key，value)中的key）获取数组下标，主要做了 3 步操作，其中length指的是容器数组的大小。&lt;/p&gt;&lt;pre&gt;/**获取hash值方法*/&lt;br&gt;static final int hash(Object key) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;int h;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;// h = key.hashCode() 为第一步 取hashCode值（jdk1.7）&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;// h ^ (h &amp;gt;&amp;gt;&amp;gt; 16)&amp;nbsp; 为第二步 高位参与运算（jdk1.7）&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);//jdk1.8&lt;br&gt;}&lt;br&gt;/**获取数组下标方法*/&lt;br&gt;static int indexFor(int h, int length) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;return h &amp;amp; (length-1);&amp;nbsp; //第三步 取模运算&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&lt;b&gt;put 方法的详细执行&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20191024/13473892ec158fad08c468022ece64f3.png&quot; data-filename=&quot;img&quot; style=&quot;width: 801px;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;1、判断键值对数组 哈希table是否为空或为 null，否则执行 resize()进行扩容；&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2、根据键值 key 计算 hash 值得到插入的数组索引 i，如果 table[i]==null，直接新建节点添加；&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;3、当 table[i]不为空，判断 table[i]的首个元素是否和传入的 key 一样，如果相同直接覆盖 value；&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;4、判断 table[i] 是否为 treeNode（红黑树），如果是红黑树，则直接在树中插入键值对；&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;5、遍历 table[i]，判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可；&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;6、插入成功后，判断实际存在的键值对数量 size 是否超多了最大容量 threshold，如果超过，进行扩容操作；&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;br&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;&lt;strong style=&quot;margin: 0px; padding: 0px;&quot;&gt;resize方法&lt;/strong&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;①.在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;②.每次扩展的时候，都是扩展2倍；&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;&lt;b&gt;get 方法获取参数值&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;get(Object key)方法根据指定的 key 值返回对应的 value，getNode(hash(key), key))得到相应的 Node 对象 e，然后返回 e.value。因此 getNode()是算法的核心。&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;img src=&quot;/upload/article/20191024/78e8bb5248e9b117e980baa7a8cbcd3c.png&quot; data-filename=&quot;img&quot; style=&quot;width: 506px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;get 方法，首先通过 hash()函数得到对应数组下标，然后依次判断。&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;1、判断第一个元素与 key 是否匹配，如果匹配就返回参数值；&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;2、判断链表是否红黑树，如果是红黑树，就进入红黑树方法获取参数值；&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;3、如果不是红黑树结构，直接循环判断，直到获取参数为止；&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;&lt;b&gt;remove 删除元素&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;remove(Object key)的作用是删除 key 值对应的 Node，该方法的具体逻辑是在removeNode(hash(key), key, null, false, true)里实现的。&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;img src=&quot;/upload/article/20191024/419b931b4ae0570649bc42b80a1ed2e9.png&quot; data-filename=&quot;img&quot; style=&quot;width: 535px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;jdk1.8 的删除逻辑实现比较复杂，相比 jdk1.7 而言，多了红黑树节点删除和调整：&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;1、默认判断链表第一个元素是否是要删除的元素；&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;2、如果第一个不是，就继续判断当前冲突链表是否是红黑树，如果是，就进入红黑树里面去找；&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;3、如果当前冲突链表不是红黑树，就直接在链表中循环判断，直到找到为止；&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;4、将找到的节点，删除掉，如果是红黑树结构，会进行颜色转换、左旋、右旋调整，直到满足红黑树特性为止；&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;1、如果 key 是一个对象，记得在对象实体类里面，要重写 equals 和 hashCode 方法，不然在查询的时候，无法通过对象 key 来获取参数值！&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;2、相比 JDK1.7，JDK1.8 引入红黑树设计，当链表长度大于 8 的时候，链表会转化为红黑树结构，发生冲突的链表如果很长，红黑树的实现很大程度优化了 HashMap 的性能，使查询效率比 JDK1.7 要快一倍！&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;3、对于大数组的情况，可以提前给 Map 初始化一个容量，避免在插入的时候，频繁的扩容，因为扩容本身就比较消耗性能！&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;线程不安全的HashMap&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;margin-top: 10px; margin-right: auto; margin-left: auto; padding: 0px;&quot;&gt;&lt;font face=&quot;Verdana, Arial, Helvetica, sans-serif&quot;&gt;&lt;span style=&quot;font-size: 14px;&quot;&gt;&amp;nbsp; &amp;nbsp; 因为多线程环境下，使用Hashmap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;\n                                                                                                                                                                                                                                    ',0,'2019-10-24 00:00:00','34',23),(216,1,'TreeSet/HashSet 区别','','&lt;div&gt;&lt;b&gt;HashSet&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;HashSet背后是HashMap，key是无序的(这里无序是指存入元素的先后顺序与输出元素的先后顺序不一致)，可以接受null值&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;HashSet中保证集合中元素是唯一的方法：通过对象的hashCode和equals方法来完成对象唯一性的判断。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果对象的hashCode值不同，则不用判断equals方法，就直接存到HashSet中。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果对象的hashCode值相同，需要用equals方法进行比较，如果结果为true，则视为相同元素，不存，如果结果为false，视为不同元素，进行存储。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;TreeSet&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;TreeSet背后的结构是TreeMap，也就是红黑树（TreeNode），能够实现自动排序;不可以接受null值&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;TreeSet中保证集合中元素是唯一的方法：它通过equals方法或者compareTo方法进行内容的比较。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\n                                                            ',0,'2019-10-24 00:00:00','34',13),(217,1,'CPA理论解析','','\n                                \n                                \n                                &lt;div&gt;CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;一致性（C）&lt;/b&gt;：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;可用性（A）&lt;/b&gt;：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;分区容忍性（P）&lt;/b&gt;：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况(也就是存在了分区容忍性（P）)，所以剩下的只能在当前操作中的C和A之间做出选择。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于网络硬件肯定会出现延迟丢包等问题，所以分区容错性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡，&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;三个指标解释：&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;分区容错&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;img src=&quot;/upload/article/20191024/5b10c51f896965b5678cf9118f2cc37c.png&quot; data-filename=&quot;img&quot; style=&quot;width: 397px;&quot;&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;div&gt;上图中，G1 和 G2 是两台跨区的服务器。G1 向 G2 发送一条消息，G2 可能无法收到。系统设计的时候，必须考虑到这种情况。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;一般来说，分区容错无法避免（没有任何办法能保证各个服务之间传输数据时不出错），因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;一致性&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;写操作之后的读操作，必须返回该值。举例来说，&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;1.某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;2.接下来，用户的读操作就会得到 v1。这就叫一致性。&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;3.问题是，用户有可能向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;4.为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。（这中设计就是数据的主从模式）&lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;可用性&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;意思是服务器只要收到用户的请求，就必须给出回应。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;用户可以选择向 G1 或 G2 发起读操作。不管是哪台服务器，只要收到请求，就必须告诉用户，不管读取到的是 v0 还是 v1，否则就不满足可用性。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;一致性和可用性的矛盾&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;一致性和可用性，为什么不可能同时成立？答案很简单，因为可能通信失败（即出现分区容错）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，也就是用户向G2服务器发起请求时不能立马得到结果，也就没有可用性。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\n                                                                                                                                                ',0,'2019-03-13 00:00:00','33',40),(218,1,'接口幂等性解决方案','','&lt;div&gt;什么是幂等&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;其任意多次执行所产生的影响均与一次执行的影响相同。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;方案：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;1.比如查询某条数据id=1,不管执行多少次查询结果还是一样的（在这条数据没有改变前提下）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;2.删除操作：删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个) ；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.对于Post请求，我一般在请求成功后，强制跳转到其他页面，避免刷新提交。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;4.提交前向服务器申请一个token,提交数据时把token带上，服务器接收到token后校验有效性同时删除token&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;5.悲观锁——获取数据的时候加锁获取。select * from table_xxx where id=\'xxx\' for update; 注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用；&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;6.乐观锁——乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。乐观锁的实现方式多种多样可以通过version或者其他状态条件&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;要做到幂等性就是要保证同一条数据只能被消费一次&lt;/div&gt;\n                                                            ',0,'2017-06-06 00:00:00','23,34',14),(219,1,'java深入理解线程和线程池','','\n                                &lt;div&gt;什么是线程&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;线程，程序执行流的最小执行单位，是行程中的实际运作单位，经常容易和进程这个概念混淆。那么，线程和进程究竟有什么区别呢？首先，进程是一个动态的过程，是一个活动的实体。简单来说，一个应用程序的运行就可以被看做是一个进程，而线程，是运行中的实际的任务执行者。可以说，进程中至少包含了一个运行的线程。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;线程的生命周期&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191024/5adaa70fb65412835ed9fdb69453d268.png&quot; data-filename=&quot;img&quot; style=&quot;width: 816px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;第一步：是用new Thread()的方法新建一个线程，在线程创建完成之后，线程不会立即执行，而是进入了就绪（Runnable）状态，此时创建出来的线程进入抢占CPU执行权的状态，&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;第二步：当线程抢到了CPU的执行权之后，线程就进入了运行状态（Running），当该线程的任务执行完成之后或者是非常态的调用的stop（）方法之后，线程就进入了死亡状态。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;其它状态：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;当我们的线程在执行开始到结束中间这个过程，会出现以下几种造成当前线程失去CPU执行权&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;第一种&lt;/b&gt;，当线程主动调用了sleep（）方法时，线程会进入则阻塞状态，除此之外，当线程中主动调用了阻塞时的IO方法时，这个方法有一个返回参数，当参数返回之前，线程也会进入阻塞状态，失去CPU执行权。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;第二种&lt;/b&gt;，当线程进入正在等待wait()某个通知时，会进入阻塞状态，失去CPU执行权。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;第三种&lt;/b&gt;，我们都知道,CPU的资源是十分宝贵的，所以，当线程正在进行某种不确定时长的任务时，Java就会收回CPU的执行权，当前线程则又进入就绪状态，从而合理应用CPU的资源。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;第四种&lt;/b&gt;，当遇到锁的时候，当前线程会进入同步阻塞状态，失去CPU执行权；阻塞结束后进入就绪状态&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;我们根据图可以看出，不管是线程在阻塞过程结束之后还是正在运行的线程CPU执行权被回收，它们都会重新进入就绪状态，重新抢夺CPU资源。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;如何跳出阻塞过程呢?&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;从以上几种可能造成线程阻塞的情况来看，都是存在一个时间限制的，&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;第一种：当sleep()方法的睡眠时长过去后，线程就自动跳出了阻塞状态，&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;第二种：当调用wait()方法时，在获取到了等待的notify()通知时，就自动跳出了线程的阻塞过程&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;什么是单线程和多线程？&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;单线程，顾名思义即是只有一条线程在执行任务&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;多线程，创建多条线程&quot;同时&quot;执行任务;但是，在多线程的使用过程中，还有许多需要我们了解的概念。比如，在理解上并行和并发的区别，以及在实际应用的过程中多线程的安全问题，对此，我们需要进行详细的了解。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;并行和并发&lt;/b&gt;：在我们看来，都是可以同时执行多种任务，那么，到底他们二者有什么区别呢？&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;并发&lt;/b&gt;，从宏观方面来说，并发就是同时进行多种时间，实际上，并不是同时进行的，而是交替进行的，只有获取到CPU的执行权的线程，才有资格执行任务；由于CPU的运算速度非常的快，会造成我们的一种错觉，就是在同一时间内进行了多种事情&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;什么时候会产生并发：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;比如同一时刻有多个客户端（多个线程）同时请求服务端并访问同一资源会产生并发问题。&lt;/div&gt;&lt;div&gt;&amp;nbsp;银行两个工作人员同时操作同一账户就是典型的例子。比如A、B操作员同时读取一余额为1000元的账户，A操作员为该账户增加100元，B操作员同时为该账户减去50元，A先提交，B后提交。 最后实际账户余额为1000-50=950元，但本该为 1000+100-50=1050。这就是典型的并发问题。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;并发产生原因：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;由于CPU的时间是按时间片分的，而不是一个时间点，并发问题是由于CPU线程切换导致的（只有获取到CPU执行权的线程才能执行操作任务）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;假设有一段代码&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;//增加现金&lt;br&gt;increaseCash(){&lt;br&gt;    A工作人员读取账户的余额为1000元 // -------01&lt;br&gt;    执行增加操作，为账户增加100元&amp;nbsp; &amp;nbsp;// -------02&lt;br&gt;}&amp;nbsp;&lt;br&gt;// 扣除现金&lt;br&gt;deductionCash() {&lt;br&gt;&amp;nbsp; &amp;nbsp;B工作人员读取账户的余额为1000 // --------01&lt;br&gt;&amp;nbsp; &amp;nbsp;执行扣除操作，为账户减少50元&amp;nbsp; &amp;nbsp;// -------02&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;当A，B俩个工作人员（A,B线程）同时请求服务器执行操作时，假设A线程先被CPU调度，然而A线程在increaseCash()操作中，程序只执行到了01这一步&lt;/div&gt;&lt;div&gt;，时间片到期了（即失去了CPU的执行权），此时A线程的代码并没有执行完，但是CPU此时会调度B线程，并不会管A线程是不是执行完了increaseCash()里所有的操作。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　再接着当B线程在执行deductionCash()操作时，程序也只执行到了01这一步，此时CPU 现在又会调度A线程（B线程此时失去了CPU执行权），并且A线程从increaseCash()操作的01处继续执行(注意不是重新执行，CPU切换的时候保存了线程的上下文)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;所以在整个操作过程中，就会账户余额与实际的不符的情况，也就是所谓的并发，造成了多线程下的线程安全问题；&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;并行&lt;/b&gt;，则是真正意义上的同时进行多种事情。这种只可以在多核CPU的基础下完成。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;为什么会造成多线程的安全问题呢？我们可以想象一下，如果多个线程同时执行一个任务，name意味着他们共享同一种资源，由于线程CPU的资源不一定可以被谁抢占到，这是，第一条线程先抢占到CPU资源，他刚刚进行了第一次操作，而此时第二条线程抢占到了CPU的资源，name，共享资源还来不及发生变化，就同时有两条数据使用了同一条资源，具体请参考多线程买票问题。这个问题我们应该如何解决那？&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;由造成问题的原因我们可以看出，这个问题主要的矛盾在于，CPU的使用权抢占和资源的共享发生了冲突，解决时，我们只需要让一条线程战歌了CPU的资源时，阻止第二条线程同时抢占CPU的执行权，在代码中，我们只需要在方法中使用同步代码块即可（可以使用锁）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;线程池&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在一个应用程序中，我们需要多次使用线程，也就意味着，我们需要多次创建并销毁线程。而创建并销毁线程的过程势必会消耗内存。而在Java中，内存资源是及其宝贵的，所以，我们就提出了线程池的概念。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;线程池：Java中开辟出了一种管理线程的概念，这个概念叫做线程池，从概念以及应用场景中，我们可以看出，线程池的好处，就是可以方便的管理线程，也可以减少内存的消耗。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;那么，我们应该如何创建一个线程池那?Java中已经提供了创建线程池的一个类：Executor&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;而我们创建时，一般使用它的子类：ThreadPoolExecutor.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;public ThreadPoolExecutor(int corePoolSize,&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int maximumPoolSize,&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; long keepAliveTime,&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; TimeUnit unit,&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ThreadFactory threadFactory,&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; RejectedExecutionHandler handler)&lt;/pre&gt;&lt;p&gt;这是其中最重要的一个构造方法，这个方法决定了创建出来的线程池的各种属性，下面依靠一张图来更好的理解线程池和这几个参数：&lt;/p&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;corePoolSize&lt;/b&gt;：就是线程池中的核心线程数量，这几个核心线程，即使在没有用即空闲的时候，也不会被回收&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;maximumPoolSize&lt;/b&gt;：就是线程池中可以容纳的最大线程的数量&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;keepAliveTime&lt;/b&gt;：就是线程池中除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;util&lt;/b&gt;：就是计算这个时间的一个单位&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;workQueue&lt;/b&gt;：就是等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFIO原则（先进先出）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;threadFactory&lt;/b&gt;：就是创建线程的线程工厂&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;handler&lt;/b&gt;：是一种拒绝策略，我们可以在任务满了之后，拒绝执行某些任务&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20191025/26aa957e24d000632e5064019048fb9e.png&quot; data-filename=&quot;img&quot; style=&quot;width: 601px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20191025/ba6d87e992f5bb943bf4369851817147.png&quot; data-filename=&quot;img&quot; style=&quot;width: 727px;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;由图我们可以看出线程池执行步骤：&lt;/p&gt;&lt;p&gt;1.任务进来时，首先判断核心线程数是否已满，如果没有满，就创建核心线程执行任务；&lt;/p&gt;&lt;p&gt;2.如果核心线程已满，则判断任务队列是否已满， 如果没有满，就将任务放入任务队列中，等待执行（有可能是核心线程执行也有可能是非核心线程来执行），&lt;/p&gt;&lt;p&gt;3.如果任务队列满了，则判断最大可容纳的线程数，如果没有超出这个数量，就创建非核心线程执行任务，&lt;/p&gt;&lt;p&gt;4.如果超出最大可容纳的线程数了，就调用handler实现拒绝策略。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;handler的拒绝策略：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;有四种：&lt;/p&gt;&lt;p&gt;第一种AbortPolicy:不执行新任务，直接抛出异常，提示线程池已满&lt;/p&gt;&lt;p&gt;第二种DisCardPolicy:不执行新任务，也不抛出异常&lt;/p&gt;&lt;p&gt;第三种DisCardOldSetPolicy:将消息队列中的第一个任务替换为当前新进来的任务执行&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;第四种CallerRunsPolicy:直接调用execute来执行当前任务&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20191025/f911e40ea7fa4e87c8b8362eeeb98ff0.png&quot; data-filename=&quot;img&quot; style=&quot;width: 872.008px; height: 412px;&quot;&gt;&lt;/p&gt;&lt;p&gt;（上图参考线程池执行4个步骤有助理解）&lt;/p&gt;&lt;p&gt;&lt;b&gt;四种常见的线程池：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;CachedThreadPool:可缓存的线程池，该线程池中没有核心线程，非核心线程的数量为Integer.max_value，就是无限大，当有需要时创建线程来执行任务，没有需要时回收线程，适用于耗时少，任务量大的情况。&lt;/p&gt;&lt;p&gt;SecudleThreadPool:周期性执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大。适用于执行周期性的任务。&lt;/p&gt;&lt;p&gt;SingleThreadPool:只有一条线程来执行任务，适用于有顺序的任务的应用场景。&lt;/p&gt;&lt;p&gt;FixedThreadPool:定长的线程池，只有核心线程，核心线程数即为最大的线程数量，没有非核心线程&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n                                                                                        ',0,'2019-10-24 00:00:00','34',28),(220,1,'JAVA8的ConcurrentHashMap为什么放弃了分段锁？','','\n                                \n                                &lt;div&gt;&lt;div&gt;ConcurrentHashMap的分段锁是用来解决多线程下线程安全方案，但是在Java8中该分段锁已被弃用&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;原因有以下几点：&amp;nbsp;&lt;/div&gt;&lt;div&gt;1、加入多个分段锁浪费内存空间。&amp;nbsp;&lt;/div&gt;&lt;div&gt;2、生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。&amp;nbsp;&lt;/div&gt;&lt;div&gt;3、为了提高 GC 的效率&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;既然弃用了分段锁， 那么一定由新的线程安全方案， 我们来看看源码是怎么解决线程安全的呢？CAS&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;CAS&lt;/div&gt;&lt;div&gt;首先通过 hash 找到对应链表过后， 查看是否是链表第一个object， 如果是， 直接用cas原则插入，无需加锁，如果不是链表第一个object， 则直接用链表第一个object加锁，这里加的锁是synchronized，虽然效率不如 ReentrantLock（可重入锁）， 但节约了空间，这里会一直用第一个object为锁， 直到重新计算map大小， 比如扩容或者操作了第一个object为止。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;ConcurrentHashMap(JDK1.8)为什么要使用synchronized而不是如ReentranLock这样的可重入锁？&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;为什么是synchronized，而不是可重入锁&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;减少内存开销&lt;/div&gt;&lt;div&gt;假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承AQS来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。&lt;/div&gt;&lt;div&gt;获得JVM的支持&lt;/div&gt;&lt;div&gt;可重入锁毕竟是API这个级别的，后续的性能优化空间很小。&lt;/div&gt;&lt;div&gt;synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。这就使得synchronized能够随着JDK版本的升级而不改动代码的前提下获得性能上的提升。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\n                                                                                                                    ',0,'2018-03-02 00:00:00','34',18),(221,1,'Java中ArrayList和LinkedList区别','','\n                                &lt;div&gt;一般大家都知道ArrayList和LinkedList的大致区别：&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 （LinkedList是双向链表，有next也有previous）&lt;/div&gt;&lt;div&gt;&amp;nbsp;2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;ArrayList和LinkedList是两个集合类，用于存储一系列的对象引用(references)。例如我们可以用ArrayList来存储一系列的String或者Integer。那么ArrayList和LinkedList在性能上有什么差别呢？什么时候应该用ArrayList什么时候又该用LinkedList呢？&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;ArrayList&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;ArrayList是Java集合常用的数据结构之一，继承自AbstractList，实现了List，RandomAccess、Cloneable、Serializable等一系列接口，支持快速访问，复制和序列化。底层是基于数组实现容量大小动态变化，允许null值存在。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;ArrayList使用一个内置的数组来存储元素，这个数组的起始容量是10.当数组需要增长时，新的容量按如下公式获得：新容量=(旧容量*3)/2+1，也就是说每一次容量大概会增长50%。这就意味着，如果你有一个包含大量元素的ArrayList对象，那么最终将有很大的空间会被浪费掉，这个浪费是由ArrayList的工作方式本身造成的。如果没有足够的空间来存放新的元素，数组将不得不被重新进行分配以便能够增加新的元素。对数组进行重新分配，将会导致性能急剧下降。如果我们知道一个ArrayList将会有多少个元素，我们可以通过构造方法来指定容量。我们还可以通过trimToSize方法在ArrayList分配完毕之后去掉浪费掉的空间。&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191026/b1b55009c5534bc35c239d9cb9dda1f5.png&quot; data-filename=&quot;img&quot; style=&quot;width: 822px; height: 132.349px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;private transient Object[] elementData;&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp;/**&amp;nbsp;&lt;br&gt;&amp;nbsp; * The size of the ArrayList (the number of elements it contains).&amp;nbsp;&lt;br&gt;&amp;nbsp; *&amp;nbsp;&lt;br&gt;&amp;nbsp; * @serial&amp;nbsp;&lt;br&gt;&amp;nbsp; */&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp;private int size;&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;ArrayList类中只定义了两个私有属性，很容易理解，elementData存储ArrayList内的元素，size表示它包含的元素的数量。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191026/8baddbfb1286a178642a18b36efe4ae2.png&quot; data-filename=&quot;img&quot; style=&quot;width: 535px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;ArrayList提供了三个构造函数：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;ArrayList()：默认构造函数，提供初始容量为10的空列表。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;ArrayList(int initialCapacity)：构造一个具有指定初始容量的空列表。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;ArrayList(Collection&amp;lt;? extends E&amp;gt; c)：构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;ArrayList添加元素过程&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;有这么一段代码：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;public static void main(String[] args)&lt;br&gt;{&lt;br&gt;&amp;nbsp; &amp;nbsp; List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();&lt;br&gt;&amp;nbsp; &amp;nbsp; list.add(&quot;000&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; list.add(&quot;111&quot;);&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;看下底层会做什么，进入add方法的源码来看一下：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;public boolean add(E e) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;ensureCapacity(size + 1);&amp;nbsp; // Increments modCount!!&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;elementData[size++] = e;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;return true;&lt;br&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;从上面的源码可以看出，添加元素时，会先判断是否需要扩容，如果需要扩容先扩容，把之前的元素复制到新的&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;elementData数组后，最后才添加新的元素&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191026/5f2ed5cf80dfe033a26f6c6cacc44807.png&quot; data-filename=&quot;img&quot; style=&quot;width: 604px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;扩容处理逻辑&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;我们知道ArrayList默认的构造，底层数组大小是10：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;public ArrayList() {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;this(10);&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;那么当我们进行添加元素的时候，它是怎么扩容的呢？&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在add()这个方法里我们可以看到 有ensureCapacity(size + 1)这么一个方法，这个方法就是用来判断本次添加元素是否需要进行扩容的，源代码：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;public void ensureCapacity(int minCapacity) {&lt;br&gt;&amp;nbsp; &amp;nbsp; modCount++;&lt;br&gt;&amp;nbsp; &amp;nbsp; int oldCapacity = elementData.length;&lt;br&gt;&amp;nbsp; &amp;nbsp; if (minCapacity &amp;gt; oldCapacity) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Object oldData[] = elementData;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int newCapacity = (oldCapacity * 3)/2 + 1;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (newCapacity &amp;lt; minCapacity)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;         newCapacity = minCapacity;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// minCapacity is usually close to size, so this is a win:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;elementData = Arrays.copyOf(elementData, newCapacity);&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;在添加元素时，先计算数组元素个数并加1（size+1），然后作为参数传给ensureCapacity 这个方法；然后再通过（size+1）与 elementData 这个数组的长度做比较来决定是否需要扩容处理；扩容时，会先创建一个新的指定大小的新的数组，然后把之前的元素都复制到新数组里&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;public static &amp;lt;T,U&amp;gt; T[] copyOf(U[] original, int newLength, Class&amp;lt;? extends T[]&amp;gt; newType) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;T[] copy = ((Object)newType == (Object)Object[].class)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;? (T[]) new Object[newLength]&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;: (T[]) Array.newInstance(newType.getComponentType(), newLength);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;System.arraycopy(original, 0, copy, 0,&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Math.min(original.length, newLength));&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;return copy;&lt;br&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191026/1e9a39a2b605876c0f1b275cef32710f.png&quot; data-filename=&quot;img&quot; style=&quot;width: 768px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;看到扩容的时候把元素组大小先乘以3，再除以2，最后加1。可能有些人要问为什么？我们可以想：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、如果一次性扩容扩得太大，必然造成内存空间的浪费&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、如果一次性扩容扩得不够，那么下一次扩容的操作必然比较快地会到来，这会降低程序运行效率，要知道扩容还是比价耗费性能的一个操作&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;所以扩容扩多少，是JDK开发人员在时间、空间上做的一个权衡，提供出来的一个比较合理的数值。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;插入元素&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;看一下ArrayList的插入操作，插入操作调用的也是add方法，比如：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;public static void main(String[] args)&lt;br&gt;{&lt;br&gt;&amp;nbsp; &amp;nbsp; List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();&lt;br&gt;&amp;nbsp; &amp;nbsp; list.add(&quot;111&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; list.add(&quot;222&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; list.add(&quot;333&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; list.add(&quot;444&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; list.add(&quot;555&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; list.add(&quot;666&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; list.add(&quot;777&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; list.add(&quot;888&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; list.add(2, &quot;000&quot;);  // 在指定位置插入元素&lt;br&gt;&amp;nbsp; &amp;nbsp; System.out.println(list);&lt;br&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;运行结果：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;[111, 222, 000, 333, 444, 555, 666, 777, 888]&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;看一下插入的时候做了什么：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;// 将指定的元素插入此列表中的指定位置。&amp;nbsp;&amp;nbsp;&lt;br&gt;// 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。&amp;nbsp;&amp;nbsp;&lt;br&gt;public void add(int index, E element) {&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp;if (index &amp;gt; size || index &amp;lt; 0)&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+&quot;, Size: &quot;+size);&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp;// 如果数组长度不足，将进行扩容。&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp;ensureCapacity(size+1);&amp;nbsp; // Increments modCount!!&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp;// 将 elementData中从Index位置开始、长度为size-index的元素，&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp;// 拷贝到从下标为index+1位置开始的新的elementData数组中。&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp;// 即将当前位于该位置的元素以及所有后续元素右移一个位置。&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp;System.arraycopy(elementData, index, elementData, index + 1, size - index);&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp;elementData[index] = element;&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp;size++;&amp;nbsp;&amp;nbsp;&lt;br&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;从上面代码可以看到，当我们插入的元素（实际就是添加元素）时，只要不是在数组的尾部即调用add()方法只传一个参数添加元素时，也就是说我们在数组中间或者头部添加元素时，从指定插入的位置到后面所有的元素它们的位置都会向右移动一个位置；这也就是为什么ArrayList在添加和删除元素时效率低的原因，这是非常麻烦和耗时的，所以如果指定的数据集合需要进行大量插入（中间插入）操作，推荐使用&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;LinkedList&lt;/span&gt;。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;删除元素&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;接着我们看一下删除的操作。ArrayList支持两种删除方式：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、按照下标删除&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、按照元素删除，这会删除ArrayList中与指定要删除的元素匹配的第一个元素&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;对于ArrayList来说，这两种删除的方法差不多，都是调用的下面一段代码：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;int numMoved = size - index - 1;&lt;br&gt;if (numMoved &amp;gt; 0)&lt;br&gt;&amp;nbsp; &amp;nbsp; System.arraycopy(elementData, index+1, elementData, index,&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;numMoved);&lt;br&gt;elementData[--size] = null; // Let gc do its work&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;其实做的事情就是两件:&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、把指定元素后面位置的所有元素，利用System.arraycopy方法整体向前移动一个位置&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、最后一个位置的元素指定为null，这样让gc可以去回收它&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;ArrayList的优缺点&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;从上面的几个过程总结一下ArrayList的优缺点。ArrayList的优点如下：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、ArrayList底层以数组实现，是一种随机访问模式，再加上它实现了RandomAccess接口，因此查找也就是get的时候非常快。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、ArrayList在顺序添加一个元素的时候非常方便，只是往数组里面添加了一个元素而已。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;不过ArrayList的缺点也十分明显：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、删除元素的时候，从删除位置起后面所有元素都往前移动一个位置，那么就会比较耗费性能。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、插入元素的时候，只要不是顺序插入，而是指定插入元素的位置时，那么从插入位置到后面所有的元素都会往后移动一个位置，那么就会比较耗费性能。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;因此，ArrayList比较适合顺序添加、随机get访问的场景。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;ArrayList是线程非安全的&lt;/span&gt;，这很明显，因为ArrayList中所有的方法都不是同步的，在并发下一定会出现线程安全问题。那么我们想要使用ArrayList并且让它线程安全怎么办？一个方法是用Collections.synchronizedList方法把你的ArrayList变成一个线程安全的List，比如：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;List&amp;lt;String&amp;gt; synchronizedList = Collections.synchronizedList(list);&lt;br&gt;synchronizedList.add(&quot;aaa&quot;);&lt;br&gt;synchronizedList.add(&quot;bbb&quot;);&lt;br&gt;for (int i = 0; i &amp;lt; synchronizedList.size(); i++)&lt;br&gt;{&lt;br&gt;&amp;nbsp; &amp;nbsp; System.out.println(synchronizedList.get(i));&lt;br&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;LinkedList&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;LinkedList 是 Java 集合中比较常用的数据结构，与 ArrayList 一样，实现了 List 接口，只不过 ArrayList 是基于数组实现的，而 LinkedList 是基于链表实现的。所以 LinkedList 插入和删除方面要优于 ArrayList，而随机访问上则 ArrayList 性能更好。&lt;/div&gt;&lt;div&gt;除了 LIst 接口之外，LinkedList 还实现了 Deque，Cloneable，Serializable 三个接口。这说明该数据结构支持队列，克隆和序列化操作的。与 ArrayList 一样，允许 null 元素的存在，且是不支持多线程的。&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;LinkedList是基于链表实现的，所以先讲解一下什么是链表;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;链表&lt;/span&gt;由一些节点组成，物理存储非连续的线性表。其中每个节点都会存储下个节点的指针，由于实际存储空间不连续，对链表插入节点，删除节点可以达到O(1)的复杂度，但是对一个节点的访问需要O(n)的时间。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;单向链表&lt;/span&gt;&lt;/div&gt;&lt;div&gt;单向链表的每个节点有数据项和指针(指向下个节点地址数据)组成，下图为一个单向链表，表头没有数据项，只有指向下一个节点的指针。表尾节点指向下一个节点pNext指针为NULL（空）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191026/4a56ad1673cbf7cda4a8407e98d80db8.png&quot; data-filename=&quot;img&quot; style=&quot;width: 663px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;插入节点操作：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;单向链表中由四个数据节点，数据1，数据2，数据3，数据4，现在数据1和数据2节点间插入数据5，只需把数据1节点的pNext指向新的节点，把新节点的pNext指向数据2节点即可。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191026/1a05c992984730b45b301688c7505975.png&quot; data-filename=&quot;img&quot; style=&quot;width: 659px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;删除节点操作&lt;/span&gt;：&lt;/div&gt;&lt;div&gt;删除节点2，只需把第一个节点的pNext执行数据3节点，同时释放节点2的存储空间即可。&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191026/7f1584db9981fc9f9d219366ca2a8c30.png&quot; data-filename=&quot;img&quot; style=&quot;width: 694px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;所以链表的插入和删除效率是很高的，因为它不需要移动节点的位置，&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;双向链表&lt;/span&gt;&lt;/div&gt;&lt;div&gt;双向链表有别于单向的，每个节点除了数据项外有两个指针分别指向前一个节点和后一个节点，占用空间会大一些，可以实现从头到尾的遍历，又可以从尾到头遍历。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191026/b53e59b4d52542025f33a8b998d8a555.png&quot; data-filename=&quot;img&quot; style=&quot;width: 665px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;插入节点操作：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;节点1与节点2之间插入新节点5，需要把节点1的pNext指向节点5，节点5的pHead指向节点1，节点5的pNext指向节点2，节点2的pHead指向节点5，如下图所示：&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191026/940af2d5d4b55ddf35176b49b6a624aa.png&quot; data-filename=&quot;img&quot; style=&quot;width: 702px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;删除节点操作：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;删除节点2，把节点1的pNext指向节点3，把节点3的pHead指向节点1，同时释放节点2的存储空间即可。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191026/1181434f5fec48bc9a37fbcabe1619a9.png&quot; data-filename=&quot;img&quot; style=&quot;width: 692px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;链表与数组区别&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1.链表存储空间不连续，可以充分利用碎片空间，数组的存储空间是连续的，内存空间要求高，必须要有足够连续的内存空间。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.链表的插入删除元素简单，无需对元素移动，但查询元素会慢，数组对元素的插入删除较复杂，同时使用时要预先指定长度，但数组的查询会很快。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;LinkedList源码分析&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;LinkedList中定义了两个私有属性：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;private transient Entry&amp;lt;E&amp;gt; header = new Entry&amp;lt;E&amp;gt;(null, null, null);&lt;br&gt;private transient int size = 0;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;header是双向链表的头节点，它是双向链表节点所对应的类Entry的实例。Entry中包含成员变量： previous, next,element。其中，previous是该节点的上一个节点，next是该节点的下一个节点，element是该节点所包含的值。&amp;nbsp;&lt;/div&gt;&lt;div&gt;size是双向链表中节点实例的个数。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;首先来了解节点类Entry类的代码。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;private static class Entry&amp;lt;E&amp;gt; {&lt;br&gt;&amp;nbsp; &amp;nbsp; E element;&lt;br&gt;&amp;nbsp; &amp;nbsp; Entry&amp;lt;E&amp;gt; next;&lt;br&gt;&amp;nbsp; &amp;nbsp; Entry&amp;lt;E&amp;gt; previous;&lt;br&gt;&amp;nbsp; &amp;nbsp; Entry(E element, Entry&amp;lt;E&amp;gt; next, Entry&amp;lt;E&amp;gt; previous) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.element = element;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.next = next;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.previous = previous;&lt;br&gt;&amp;nbsp; &amp;nbsp;}&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;看到LinkedList的Entry中的&quot;E element&quot;，就是它真正存储的数据。&quot;Entry&amp;lt;E&amp;gt; next&quot;和&quot;Entry&amp;lt;E&amp;gt; previous&quot;表示的就是这个存储单元的前一个存储单元的引用地址和后一个存储单元的引用地址。用图表示就是：&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191026/1a1c0784a676ce3edf17191eb77bf0de.png&quot; data-filename=&quot;img&quot; style=&quot;width: 306px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;构造函数&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;LinkedList提供了两个构造方法，如下所示：&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;public LinkedList() {&lt;br&gt;&amp;nbsp; &amp;nbsp; header.next = header.previous = header;&lt;br&gt;}&lt;br&gt;public LinkedList(Collection&amp;lt;? extends E&amp;gt; c) {&lt;br&gt;&amp;nbsp; &amp;nbsp; this();&lt;br&gt;&amp;nbsp; &amp;nbsp;addAll(c);&lt;br&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;执行完构造函数后，header实例自身形成一个闭环，如下图所示：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191026/2110f50e17e8fa643e741c736dff5a07.png&quot; data-filename=&quot;img&quot; style=&quot;width: 365px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;第二个构造方法接收一个Collection参数c，调用第一个构造方法构造一个空的链表，之后通过addAll将c中的元素全部添加到链表中。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191026/2c5af4b56b0ea7b6057def898ae00b71.png&quot; data-filename=&quot;img&quot; style=&quot;width: 418px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;添加元素&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;首先看下LinkedList添加一个元素是怎么做的，假如我有一段代码：&lt;/div&gt;&lt;pre&gt;&amp;nbsp;List&amp;lt;String&amp;gt; list = new LinkedList&amp;lt;String&amp;gt;();&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;list.add(&quot;111&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;list.add(&quot;222&quot;);&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;当我们 new LinkedList 时，其实做了几件事情&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;public class LinkedList&amp;lt;E&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; extends AbstractSequentialList&amp;lt;E&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; implements List&amp;lt;E&amp;gt;, Deque&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable&lt;br&gt;{&lt;br&gt;&amp;nbsp; &amp;nbsp; private transient Entry&amp;lt;E&amp;gt; header = new Entry&amp;lt;E&amp;gt;(null, null, null);  // 链表节点&lt;br&gt;&amp;nbsp; &amp;nbsp; private transient int size = 0;&lt;br&gt;&amp;nbsp; &amp;nbsp; /**&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* Constructs an empty list.&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;*/&lt;br&gt;&amp;nbsp; &amp;nbsp; public LinkedList() {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; header.next = header.previous = header;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; ...&lt;br&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;看到，new了一个Entry出来名为header，Entry里面的previous、element、next都为null，执行构造函数的时候，将节点的previous和next的值都设置为header（节点）的引用地址&lt;/div&gt;&lt;/div&gt;&lt;div&gt;那么执行完&quot;List&amp;lt;String&amp;gt; list = new LinkedList&amp;lt;String&amp;gt;()&quot;之后可以这么表示：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191026/2fe266b17a5fb20b730478869a43e9dc.png&quot; data-filename=&quot;img&quot; style=&quot;width: 404px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;接着看第4行add一个字符串&quot;111&quot;做了什么：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;public boolean add(E e) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;addBefore(e, header);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;return true;&lt;br&gt;}&lt;br&gt;private Entry&amp;lt;E&amp;gt; addBefore(E e, Entry&amp;lt;E&amp;gt; entry) {&lt;br&gt;&amp;nbsp; &amp;nbsp; Entry&amp;lt;E&amp;gt; newEntry = new Entry&amp;lt;E&amp;gt;(e, entry, entry.previous);  // 三个参数分别表示 Entry里面的 previous、element、next&lt;br&gt;&amp;nbsp; &amp;nbsp; newEntry.previous.next = newEntry;  //  当前节点的前一个节点的next指针指向 当前节点地址&lt;br&gt;&amp;nbsp; &amp;nbsp; newEntry.next.previous = newEntry;  //  当前节点的下一个节点的previous 指针指向 当前节点地址&lt;br&gt;&amp;nbsp; &amp;nbsp; size++;&lt;br&gt;&amp;nbsp; &amp;nbsp; modCount++;&lt;br&gt;&amp;nbsp; &amp;nbsp; return newEntry;&lt;br&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191026/f28c4352f2c1d9e227f9fb8081cf56f6.png&quot; data-filename=&quot;img&quot; style=&quot;width: 486px;&quot;&gt;&lt;/div&gt;&lt;div&gt;从上图可以看出，双向链表中，一是任意节点都可以向前和向后寻址，二是整个链表头的previous表示的是链表的尾Entry，链表尾的next表示的是链表的头Entry&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;查看元素&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;看一下LinkedList的代码是怎么写的：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;public E get(int index) {&lt;br&gt;&amp;nbsp; &amp;nbsp; return entry(index).element;&lt;br&gt;}&lt;br&gt;// 获取双向链表中指定位置的节点&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;private Entry&amp;lt;E&amp;gt; entry(int index) {&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; if (index &amp;lt; 0 || index &amp;gt;= size)&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;, Size: &quot;+size);&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; Entry&amp;lt;E&amp;gt; e = header;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; // 获取index处的节点。&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; // 若index &amp;lt; 双向链表长度的1/2,则从前向后查找;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; // 否则，从后向前查找。&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; if (index &amp;lt; (size &amp;gt;&amp;gt; 1)) {&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for (int i = 0; i &amp;lt;= index; i++)&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; e = e.next;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; } else {&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for (int i = size; i &amp;gt; index; i--)&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; e = e.previous;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; return e;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;由于LinkedList是双向链表，所以LinkedList既可以向前查找，也可以向后查找，第10行~第16行的作用就是：当index小于数组大小的一半的时候（size &amp;gt;&amp;gt; 1表示size / 2，使用移位运算提升代码运行效率），从前向后查找；否则，从后向前查找。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;删除元素&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;看完了添加元素，我们看一下如何删除一个元素。和ArrayList一样，LinkedList支持按元素删除和按下标删除，前者会删除从头开始匹配的第一个元素。用按下标删除举个例子好了，比方说有这么一段代码：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;public E remove(int index) {&lt;br&gt;&amp;nbsp; &amp;nbsp; return remove(entry(index));&lt;br&gt;}&lt;br&gt;private E remove(Entry&amp;lt;E&amp;gt; e) {&lt;br&gt;&amp;nbsp; &amp;nbsp; if (e == header)&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; throw new NoSuchElementException();&lt;br&gt;&amp;nbsp; &amp;nbsp; // 保留将被移除的节点e的内容&lt;br&gt;&amp;nbsp; &amp;nbsp; E result = e.element;&lt;br&gt;&amp;nbsp; &amp;nbsp; // 将前一节点的next引用赋值为e的下一节点&lt;br&gt;&amp;nbsp; &amp;nbsp; e.previous.next = e.next;&lt;br&gt;&amp;nbsp; &amp;nbsp; // 将e的下一节点的previous赋值为e的上一节点&lt;br&gt;&amp;nbsp; &amp;nbsp; e.next.previous = e.previous;&lt;br&gt;&amp;nbsp; &amp;nbsp; // 上面两条语句的执行已经导致了无法在链表中访问到e节点，而下面解除了e节点对前后节点的引用&lt;br&gt;&amp;nbsp; &amp;nbsp; e.next = e.previous = null;&lt;br&gt;&amp;nbsp; &amp;nbsp; // 将被移除的节点的内容设为null&lt;br&gt;&amp;nbsp; &amp;nbsp; e.element = null;&lt;br&gt;&amp;nbsp; &amp;nbsp; // 修改size大小&lt;br&gt;&amp;nbsp; &amp;nbsp; size--;&lt;br&gt;&amp;nbsp; &amp;nbsp; modCount++;&lt;br&gt;&amp;nbsp; &amp;nbsp; // 返回移除节点e的内容&lt;br&gt;&amp;nbsp; &amp;nbsp; return result;&lt;br&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;清空预删除节点：&lt;/div&gt;&lt;div&gt;e.next = e.previous = null;&lt;/div&gt;&lt;div&gt;e.element = null;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;交给gc完成资源回收，删除操作结束。&lt;/div&gt;&lt;div&gt;与ArrayList比较而言，LinkedList的删除动作不需要“移动”很多数据，从而效率更高。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;总结&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;ArrayList和LinkedList在性能上各有优缺点，都有各自所适用的地方，总的说来可以描述如下：&amp;nbsp;&lt;/div&gt;&lt;div&gt;1．对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是统一的，分配一个内部Entry对象。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2．在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3．LinkedList不支持高效的随机元素访问。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;4．ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;可以这样说：当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能；当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了。&lt;/div&gt;\n                                                                                        ',0,'2019-10-26 00:00:00','34',35),(222,1,'通俗讲解数据库三范式详解','','\n                                &lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;第一范式&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;强调的是列的原子性，即列不能够再分成其他几列。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;比如一张用户表: user_table (姓名,性别,电话)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在实际场景中，一个用户可能有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF（即表的字段还能继续拆分）。要符合 1NF 我们只需把列（电话字段）拆分，即：user_table (姓名,性别,家庭电话,公司电话)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;第二范式&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;保证表中每一行的数据中列对应的数据不出现重复的值。只要数据列中出现数据重复，就要把表拆分开来。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191025/bb25d28b2d1b827e138aa70f8b528775.png&quot; data-filename=&quot;img&quot; style=&quot;width: 488px;&quot;&gt;&lt;/div&gt;&lt;div&gt;一个人同时订几个房间，假如一个房间生成一条数据，某个人订了三个房间，这时数据库会有三条数据，但是这三条数据中，&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;联系人，联系人电话，联系人身份证&amp;nbsp;&lt;/span&gt;都是重复的。这样造成了数据冗余。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191025/fa1b72be41d09997070f42a0ac40a434.png&quot; data-filename=&quot;img&quot; style=&quot;width: 556px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;我们把上面的表进行拆分后，得到两张表：订单表 和联系人表&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;某个人订了三个房间，这时订单表会有三条数据并通过联系人编号与联系人表进行关联，但是联系人表还是记录着某个人的一条数据，同时对表数据的更新维护也更易操作。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;第三范式&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;数据不能存在传递关系，即每个字段都跟主键有直接关系而不是间接关系。像：a--&amp;gt;b--&amp;gt;c&amp;nbsp; 属性之间含有这样的关系，是不符合第三范式的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;比如Student表（学号（主键），姓名，年龄，性别，所在院校，院校地址，院校电话）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这样一个表结构，就存在上述关系。 比如 院校地址，院校电话 它们与学号（主键）没有直接的关系，而是与所在院校有直接的关系&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这样的表结构，我们应该拆开来，如下。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;（学号（主键），姓名，年龄，性别，所在院校）--（所在院校（主键），院校地址，院校电话）&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\n                                                                                        ',0,'2018-02-01 00:00:00','11',47),(223,1,'jvm内存结构详解','','\r\n &lt;div&gt;JVM(Java Virtual Machine，Java虚拟机)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Java程序的跨平台特性主要是指字节码文件可以在任何具有Java虚拟机的计算机或者电子设备上运行，Java虚拟机中的Java解释器负责将字节码文件解释成为特定的机器码进行运行。因此在运行时，Java源程序需要通过编译器编译成为.class文件。众所周知java.exe是java class文件的执行程序，但实际上java.exe程序只是一个执行的外壳，它会装载jvm.dll（windows下，下皆以windows平台为例，linux下和solaris下其实类似，为：libjvm.so），这个动态连接库才是java虚拟机的实际操作处理所在。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;JVM是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。所以，JAVA虚拟机JVM是属于JRE的，而现在我们安装JDK时也附带安装了JRE(当然也可以单独安装JRE)。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;JVM内存结构&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191025/98fa50bada9ac5a7d416218ad3b467ba.png&quot; data-filename=&quot;img&quot; style=&quot;width: 661px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191026/7b16de117a7a4007ed17cb82adae690c.png&quot; data-filename=&quot;img&quot; style=&quot;width: 772.135px; height: 534px;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;方法区和堆是所有线程共享的内存区域；而java栈、本地方法栈和程序计数器是运行是线程私有的内存区域。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;Java堆（Heap）：&lt;/b&gt;是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;方法区（Method Area）&lt;/b&gt;：方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 ；运行时常量池&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern() )都可以将常量放入池中。内存有限，无法申请时抛出 OutOfMemoryError。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;程序计数器（Program Counter Register）：&lt;/b&gt;程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器（也就是保存当前线程执行时的上下文，这也就是为什么线程在获取到CPU执行权时，会接着上次的执行位置接着往下执行的原因）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;JVM栈（JVM Stacks）：&lt;/b&gt;与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。（比如有一个用户class里有一个方法getUserInfo()执行此方法时，里面所使用到的局部变量就会存储在JVM栈中）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;本地方法栈（Native Method Stacks）：&lt;/b&gt;本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;\r\n                                                                                                                                                                            ',0,'2019-10-25 00:00:00','34',25),(225,1,'centost7下使用docker安装nginx','','\n                                \n                                \n                                \n &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;1. 拉取官方最新版本的nginx，默认下载latest版本&lt;br&gt;&lt;/p&gt;&lt;pre&gt;&amp;nbsp; docker pull nginx&amp;nbsp;&amp;nbsp;&lt;/pre&gt;&lt;p&gt;可以指定版本号：&lt;/p&gt;&lt;p&gt;&amp;nbsp; docker pull nginx:1.17.2 下载指定版本的nginx，也可以不指定版本默认下载latest版本,各个软件镜像网站hub.docker.com&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;2.等待下载完成后，我们就可以在本地镜像列表里查到 REPOSITORY 为 nginx 的镜像。&lt;/p&gt;&lt;pre&gt;&amp;nbsp; docker images&amp;nbsp;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20191027/1450c58ca3bc8030767488ad7dee9a11.png&quot; data-filename=&quot;img&quot; style=&quot;width: 867px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;3.以下命令使用 NGINX 默认的配置来启动一个 Nginx 容器实例：&lt;/p&gt;&lt;p&gt;（通过下载下来的nginx镜像创建一个容器并命名，通过这个容器来运行nginx服务）&lt;/p&gt;&lt;pre&gt;&amp;nbsp; docker run --name my-nginx-test -p 8081:80 -d nginx&lt;/pre&gt;&lt;p&gt;（注：不能重复运行&amp;nbsp;&lt;span style=&quot;background-color: rgb(245, 245, 245); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap; color: rgb(255, 0, 0);&quot;&gt;docker run --name my-nginx-test -p 8081:80 -d nginx&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;  第一次运行时已经创建了该容器，如果再次以&lt;/span&gt;my-nginx-test 命名容器的话，docker会提示已存在的错误）&lt;/p&gt;&lt;p&gt;&amp;nbsp; 参数解释：&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 1. --name my-nginx-test 给容器设置一个名称。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;2. -d 设置容器在后台一直运行。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;3. -p 端口进行映射，将本地（windows） 8081 端口映射到docker容器内部的 80 端口。（在windows访问的时候通过8081端口访问）&lt;span style=&quot;white-space: pre;&quot;&gt;	&lt;/span&gt;&lt;/p&gt;&lt;p&gt;执行以上命令会生成一串字符串，类似 6dd4380ba70820bd2acc55ed2b326dd8c0ac7c93f68f0067daecad82aef5f938，这个表示容器的 ID，一般可作为日志的文件名。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;查看所有容器的运行状态&lt;/b&gt;&lt;/p&gt;&lt;pre&gt;docker ps -a&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20191027/68eaa4aeb70fda0387148c828bbcfd2b.png&quot; data-filename=&quot;img&quot; style=&quot;width: 872.006px; height: 59.0565px;&quot;&gt;&lt;/p&gt;&lt;p&gt;可以看到此时&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;my-nginx-test 容器处于退出状态&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;开启和停止指定容器服务&lt;/b&gt;&lt;/p&gt;&lt;p&gt;开启：&lt;/p&gt;&lt;pre&gt;docker start&amp;nbsp; my-nginx-test&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20191027/0b050f63fcc12ef21eafafcf4e8392a6.png&quot; data-filename=&quot;img&quot; style=&quot;width: 869.737px; height: 54.0369px;&quot;&gt;&lt;/p&gt;&lt;p&gt;可以看到此时的&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;my-nginx-test 容器处于运行状态的&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;停止：&lt;/span&gt;&lt;/p&gt;&lt;pre style=&quot;line-height: 1.42857;&quot;&gt;docker stop&amp;nbsp; my-nginx-test&lt;/pre&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;img src=&quot;/upload/article/20191027/5f28f6be5e67d7b12861d903a5b13673.png&quot; data-filename=&quot;img&quot; style=&quot;width: 875.006px; height: 58.9819px;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;可以看到此时的&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;my-nginx-test 容器处于停止状态的&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap; background-color: rgb(245, 245, 245); font-weight: bold;&quot;&gt;重启容器&lt;/span&gt;&lt;/p&gt;&lt;pre style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;docker restart &lt;/span&gt;&lt;/span&gt;my-nginx-test&lt;/pre&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap; background-color: rgb(245, 245, 245); font-weight: bold;&quot;&gt;删除&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap; background-color: rgb(245, 245, 245);&quot;&gt;我们这里的删除有两种情况，第一是指删除image镜像；第二是指删除container容器&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap; background-color: rgb(245, 245, 245);&quot;&gt;这里我们需要注意的是，如果我们想要删除&lt;/span&gt;&lt;span style=&quot;font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap; background-color: rgb(245, 245, 245); color: rgb(255, 0, 0);&quot;&gt;image&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap; background-color: rgb(245, 245, 245);&quot;&gt;镜像的话，那必须先删除使用过该镜像创建的container容器&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap; background-color: rgb(245, 245, 245);&quot;&gt;所以一般的步骤是这样的（以删除nginx镜像为例）&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap; background-color: rgb(245, 245, 245);&quot;&gt;01.先删除container&lt;/span&gt;&lt;/p&gt;&lt;pre style=&quot;outline: 0px; margin-bottom: 24px; padding: 8px; position: relative; line-height: 19px; background-color: rgb(255, 255, 255);&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0); font-family: Consolas, Inconsolata, Courier, monospace; font-size: 14px;&quot;&gt;&lt;span class=&quot;hljs-variable&quot; style=&quot;outline: 0px; margin: 0px; padding: 0px; font-family: &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, Roboto, Noto, Arial, &amp;quot;PingFang SC&amp;quot;, sans-serif; color: rgb(209, 154, 102); word-wrap: break-word;&quot;&gt;docker&lt;/span&gt; rm &lt;/span&gt;&lt;span style=&quot;color: rgb(209, 154, 102); font-family: &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;SF Pro Display&amp;quot;, Roboto, Noto, Arial, &amp;quot;PingFang SC&amp;quot;, sans-serif; font-size: 14px;&quot;&gt;da371fe556b7   # docker rm 容器ID （CONTAINER ID&lt;/span&gt;）  &lt;/pre&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap; background-color: rgb(245, 245, 245);&quot;&gt;02.再删除image&lt;/span&gt;&lt;/p&gt;&lt;pre style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;docker rmi &lt;/span&gt;&lt;/span&gt;5a9061639d0a   # docker rmi 镜像ID（IMAGE ID ）&lt;/pre&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;&lt;b&gt;查看容器IP&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre style=&quot;line-height: 1.42857;&quot;&gt;docker inspect --format=\'{{.NetworkSettings.IPAddress}}\' &lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;容器名称或 id &lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap; background-color: rgb(245, 245, 245);&quot;&gt;&lt;b&gt;访问docker下的刚刚创建的nginx容器服务&lt;/b&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap; background-color: rgb(245, 245, 245);&quot;&gt;由于我是在window上装了虚拟机，然后再虚拟机中安装的docker，所以访问的时候先查看虚拟机的IP地址通过命令：ifconfig查看&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;img src=&quot;/upload/article/20191027/39bca5f81f06f1f3f4081d38e19b3f5b.png&quot; data-filename=&quot;img&quot; style=&quot;width: 711px;&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap; background-color: rgb(245, 245, 245);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap; background-color: rgb(245, 245, 245);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap; background-color: rgb(245, 245, 245);&quot;&gt;通过&lt;/span&gt;&lt;/font&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot; style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt; &lt;/font&gt;http://192.168.72.158:8081/&lt;a href=&quot;http://192.168.72.158:8081/&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;img src=&quot;/upload/article/20191027/5919a0e0189a77b90e5e8d4e29474243.png&quot; data-filename=&quot;img&quot; style=&quot;width: 900.92px; height: 277.531px;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;b&gt;注意：&lt;/b&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;b&gt;在本地（windows）上访问虚拟机上的服务时，要先确定虚拟机防火墙是否开启了相关的服务以及服务对应的端口，比如：nginx需要开启http服务和80端口&lt;/b&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;1.添加&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;http&lt;/span&gt;服务&lt;/p&gt;&lt;pre&gt;&lt;span lang=&quot;EN-US&quot;&gt;firewall-cmd --permanent --add-service=http   #&lt;/span&gt;（&lt;span lang=&quot;EN-US&quot; style=&quot;background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: &amp;quot;open sans&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif;&quot;&gt;--permanent&lt;/span&gt;&lt;span style=&quot;background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: 宋体;&quot;&gt;永久生效，没有此参数重启后失效）&lt;/span&gt;&lt;/pre&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;2.查看防火墙已经开启的服务&lt;/p&gt;&lt;pre style=&quot;line-height: 1.42857;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;firewall-cmd --list-services // &lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;查看防火墙已开启的服务&lt;/span&gt;&lt;/pre&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;img src=&quot;/upload/article/20191027/da136369e4cee725532e131b46b3f431.png&quot; data-filename=&quot;img&quot; style=&quot;width: 492px;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;3.添加http的 80端口&lt;/p&gt;&lt;pre&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;nbsp;firewall-cmd --zone=public --add-port=80/tcp --permanent&amp;nbsp;&amp;nbsp;&amp;nbsp;#&lt;/span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;--permanent&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;永久生效，没有此参数重启后失效）&lt;/span&gt; &lt;/pre&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;4.查看防火墙已经开放的端口&lt;/p&gt;&lt;pre&gt;&lt;span lang=&quot;EN-US&quot;&gt;firewall-cmd --list-ports // &lt;/span&gt;&lt;span style=&quot;font-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin&quot;&gt;查看防火墙已开启的端口&lt;/span&gt;&lt;/pre&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;img src=&quot;/upload/article/20191027/01eca96a8115240448cf0e3fa0eb7f04.png&quot; data-filename=&quot;img&quot; style=&quot;width: 444px;&quot;&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;最后一定要执行&lt;/span&gt; &lt;/span&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;span lang=&quot;EN-US&quot; style=&quot;color:red&quot;&gt;systemctl restart\nfirewalld.service&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;span style=&quot;font-family:宋体;\nmso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin&quot;&gt;重启防火墙就生效了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; (&lt;/span&gt;&lt;span style=&quot;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin&quot;&gt;一定要是重启&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;o:p&gt;&lt;br&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span lang=&quot;EN-US&quot; style=&quot;&quot;&gt;&lt;o:p style=&quot;&quot;&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;docker上启动nginx,并配置修改nginx的配置文件&lt;/span&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span lang=&quot;EN-US&quot; style=&quot;&quot;&gt;&lt;o:p style=&quot;&quot;&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h5&gt;由于我们的nginx是在docker下创建容器运行的，所以虚拟机上没有nginx配置文件，我们需要通过ngixn容器名查看与nginx相关的配置&lt;/h5&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre&gt;docker exec -it my-nginx-test bash  # my-nginx-test 容器&lt;/pre&gt;&lt;p&gt;也可以通过镜像名进入到镜像容器中&lt;/p&gt;&lt;pre&gt;docker run -i -t nginx /bin/bash  # nginx 镜像&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20191027/5f802837c6587c5181f3ea92ca01c15d.png&quot; data-filename=&quot;img&quot; style=&quot;width: 514px;&quot;&gt;&lt;/p&gt;&lt;p&gt;可以看到此时已经进入到了指定的容器目录下。&lt;/p&gt;&lt;p&gt;nginx.conf配置文件在 /etc/nginx/&amp;nbsp; 下面，但是你使用vim nginx.conf 或者vi nginx.conf&lt;/p&gt;&lt;p&gt;会发现vi或者vim命令没有用，解决办法：apt-get&amp;nbsp; update&amp;nbsp; 完成之后 apt-get install vim&lt;/p&gt;&lt;p&gt;但是通过上面的方式编辑配置文件，很不方便的。我们一般的做法就是在linux下创建与nginx的相关目录和文件。然后通过挂载，把创建的文件挂载到nginx容器下对应的文件上去。&lt;/p&gt;&lt;p&gt;我们创建 &lt;span style=&quot;font-weight: bold;&quot;&gt;/docker-container&lt;/span&gt;目录，该目录我们用来专门放通过docker安装的镜像容器&lt;/p&gt;&lt;p&gt;然后我们在该目录下创建&lt;/p&gt;&lt;pre&gt;[root@localhost docker-container]# mkdir -p docker-nginx/{conf,html,logs,conf.d}&lt;/pre&gt;&lt;pre&gt;drwxr-xr-x. 2 root root 24 11月  2 17:15 conf\ndrwxr-xr-x. 2 root root 52 11月  2 17:32 conf.d\ndrwxr-xr-x. 2 root root 41 10月 27 17:37 logs\ndrwxr-xr-x. 2 root root 40 11月  2 16:53 www\n&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;这样我们在&amp;nbsp;&lt;span style=&quot;font-weight: bold;&quot;&gt;/docker-container/&lt;/span&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;docker-nginx 目录下就创建了四个nginx相关的目录&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;www:&lt;/span&gt; 目录将映射为 nginx 容器配置的虚拟目录。\n&lt;span style=&quot;font-weight: bold;&quot;&gt;logs:&lt;/span&gt; 目录将映射为 nginx 容器的日志目录。\n&lt;span style=&quot;font-weight: bold;&quot;&gt;conf: &lt;/span&gt;目录里的配置文件将映射为 nginx 容器的配置文件。&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;conf.d: &lt;/span&gt;目录里的配置文件将映射为nginx容器中的&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;/etc/nginx/conf.d&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245); font-weight: bold;&quot;&gt;配置文件&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245); font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;1.拷贝Nginx&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;镜像&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;的主配置文件&lt;/span&gt;&lt;span style=&quot;color: rgb(255, 0, 0); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;nginx.conf&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;到/docker-container/docker-nginx/conf 目录下（&lt;/span&gt;&lt;span style=&quot;font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap; color: rgb(255, 0, 0);&quot;&gt;主配置文件nginx.conf可以不需要任何改动&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;），容器 ID 可以查看 docker ps 命令输入中的第一列：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;pre&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;docker cp 6dd4380ba708:/etc/nginx/nginx.conf  /docker-container/docker-nginx/conf  # &lt;/span&gt;6dd4380ba708 容器ID&lt;/pre&gt;&lt;p&gt;2.拷贝一份&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;Nginx&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;镜像&lt;/span&gt;&lt;span style=&quot;font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51);&quot;&gt;的默认配置文件&lt;/span&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;default.conf&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51);&quot;&gt;到/docker-container/docker-nginx/conf.d目录下（&lt;/span&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;必须要把&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;default.conf拷贝一份到该目录下&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51);&quot;&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;docker cp fde1b066151d:/etc/nginx/conf.d/default.conf  /docker-container/docker-nginx/conf.d  &lt;/span&gt;&lt;/font&gt; # fde1b066151d 容器ID&lt;/pre&gt;&lt;p&gt;(可以临时创建一个nginx容器，拿到容器ID复制上面的配置文件，再删除临时容器)&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;\\upload\\article\\20191102\\8cdb2222c830c13f4680a3a11251c7b0.png&quot; data-filename=&quot;img&quot; style=&quot;width: 754px;&quot;&gt;&lt;span style=&quot;font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;如何配置多域名站点以及通过域名反向代理访问站点&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;我们在nginx的主配置文件中可以看到&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;&amp;nbsp;include /etc/nginx/conf.d/*.conf&lt;/span&gt;; 此目录下就是配置多站点的配置文件存放目录，所以我们只需要在我们自己创建的&amp;nbsp; /docker-container/docker-nginx/conf.d/ 目录下创建对应的站点配置文件， 比如：www.aa.com.conf&amp;nbsp; &amp;nbsp;www.bb.com.conf&amp;nbsp;站点&lt;/div&gt;&lt;p&gt;&lt;span style=&quot;font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51);&quot;&gt;具体的配置信息为：&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;www.dockertest.com.conf&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;server {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;    listen  80;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;    server_name  www.dockertest.com;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;    location / {&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;        proxy_set_header  Host  $http_host;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;        proxy_set_header  X-Real-IP  $remote_addr;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;        proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;        proxy_pass  http://192.168.72.158:80; // 宿主机的IP:映射的端口&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;    }&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;创建一个nginx镜像容器&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;部署项目&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;\n\n&lt;/span&gt;&lt;pre&gt;docker run  -p 80:80  --name nginx-test-web -v /docker-container/docker-nginx/www:/usr/share/nginx/html -v /docker-container/docker-nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /docker-container/docker-nginx/logs:/var/log/nginx -v /docker-container/docker-nginx/conf.d:/etc/nginx/conf.d  -d nginx&lt;br&gt;&lt;/pre&gt;&lt;div&gt;命令说明：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;-p 80:80&lt;/span&gt;： 将容器的 80 端口映射到宿主机的 80 端口。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;--name nginx-test-web&lt;/span&gt;：将容器命名为 nginx-test-web。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;-v /docker-container/docker-nginx/www:/usr/share/nginx/html&lt;/span&gt;：将我们自己创建的 www 目录挂载到容器的 /usr/share/nginx/html（当容器访问html目录时其实访问的是www目录）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;-v /docker-container/docker-nginx/conf/nginx.conf:/etc/nginx/nginx.conf&lt;/span&gt;：将我们自己创建的 nginx.conf 挂载到容器的 /etc/nginx/nginx.conf。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;-v /docker-container/docker-nginx/logs:/var/log/nginx&lt;/span&gt;：将我们自己创建的 logs 挂载到容器的 /var/log/nginx。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;-v /docker-container/docker-nginx/conf.d:/etc/nginx/conf.d&amp;nbsp; &lt;/span&gt;多站点配置映射&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;-d nginx &lt;/span&gt;： 后台运行nginx镜像服务&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;（比如我们需要把我们的一个PHP项目部署到容器上运行，则只需要把项目代码放在/docker-container/docker-nginx/www 目录下即可，修改域名指向的项目入口文件，可以在对应的www.xxx.com.conf中配置）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold; color: rgb(255, 0, 0);&quot;&gt;注：修改配置文件后必须重启容器&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;\\upload\\article\\20191102\\b658f67600f9ee0dce8c08830563bad7.png&quot; data-filename=&quot;img&quot; style=&quot;width: 551px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;（本地配置域名，注意修改一下windows中的host 配置域名映射，host中域名对应的IP是虚拟机的IP地址 ）&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;p style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                                                                                                                                                                                                                                                            ',0,'2018-06-02 00:00:00','35',62),(224,1,'Java中IO详解','','\r\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;IO 是什么？其实就是Java中的一种输入和输出功能，也可以理解为对文件的读取和写入的操作（比如读取磁盘文件或者更改磁盘文件的内容），只不过Java中对这种操作叫做对流的操作。而流不只是对文件进行读写，还可以对内存，网络，程度操作。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;IO流&lt;/div&gt;&lt;div&gt;Java的IO流是实现输入/输出的基础，它可以方便地实现数据的输入/输出操作，在Java中把不同的输入/输出源抽象表述为&quot;流&quot;。&lt;/div&gt;&lt;div&gt;流是一组有顺序的字节集合，是对数据传输的总称或抽象。&lt;/div&gt;&lt;div&gt;流有输入和输出，输入时是流从数据源流向程序（程序代码读取磁盘文件的过程）。输出时是流从程序传向数据源（程序代码写入内容到磁盘文件的过程），而数据源可以是内存，文件，网络或程序等。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;分类&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;按照流向不同&lt;b&gt;，分为 输入流、输出流&lt;/b&gt;&lt;/div&gt;&lt;div&gt;按照流对象不同，&lt;b&gt;分为 字节流、字符流&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(99, 74, 165);&quot;&gt;字节流可以处理任意类型的数据，而字符只能处理字符类型的数据&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;字节流&lt;/b&gt;&lt;/h2&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Java的流式输入\\输出是建立在四个抽象类的基础上的：InputStream、OutputStream、Reader、Writer。它们用来创建具体的流式子类。尽管程序通过具体子类执行输入/输出操作，但顶层类定义了所有流类的基本通用功能。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;InputStream和OutputStream为字节流设计（读取文件和生成文件），Reader和Writer为字符流设计(读取字符串和者写入字符串)，字节流和字符流形成分离的层次结构。一般来说，处理字符或字符串使用字符流类，处理字节或二进制对象使用字节流。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;操作文件流时，不管是字符流还是字节流，都可以按照以下方式进行：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、使用File类找到一个对象&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、通过File类的对象去实例化字节流或字符流的子类&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3、进行字节（字符）的读、写操作&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;4、关闭文件流&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;OutputStream（字节输出流）&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;OutputStream是定义了Java流式字节输入模式的抽象类&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;FileOutputStream（文件字节输出流）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;FileOutpuStream应该是Java中最常见的字节输出流了（可以在磁盘中创建一个文件，并写入内容），它创建一个可向文件写入字节的类OutputStream，它常用的构造方法如下：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、FileOutputStream(String name)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、FileOutputStream(File file)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3、FileOutputStream(File file, boolean append)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;前两个构造方法类似，前者输入文件的绝对路径，后者输入File的实例对象，和RandomAccessFile一样，推荐后者。第三个构造方法有一点不同，append如果设置为true，文件则以搜索路径模式打开。FileOutputStream的创建不依赖于文件是否存在，在创建对象时，FileOutputSStream会在打开输出文件之前就创建它。这种情况下如果试图打开一个只读文件，会引发IOException。FileOutputStream，写一个例子，现在我的D盘下的Files文件夹里并没有&quot;stream.txt&quot;这个文件：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;package com.demo;&lt;br&gt;import java.io.File;&lt;br&gt;import java.io.FileOutputStream;&lt;br&gt;import java.io.OutputStream;&lt;br&gt;public class FileOutputStreamTest {&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; public static void main(String[] args) throws Exception{&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; File file = new File(&quot;D:/Files/stream.txt&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; OutputStream out = new FileOutputStream(file);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; byte b[] = &quot;Hello World!!!&quot;.getBytes(); //操作字节流，要转换成字节&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; out.write(b);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; out.close();&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;执行上面的代码，在D盘中会生成一个文件名为stream.txt的文件里面内容为：“&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;Hello World!!!&lt;/span&gt;”；&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;InputStream（字节输入流）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;InputStream是定义了Java流式字节输入模式的抽象类；读取磁盘中文件数据的&lt;/p&gt;&lt;p&gt;FileInputStream（文件字节输入流）&lt;/p&gt;&lt;p&gt;FileInputStream应该是Java中最常见的字节输入流了，它创建一个能从文件读取字节的InputStream类，它的两个常用构造方法如下：&lt;/p&gt;&lt;p&gt;1、FileInputStream(String name)&lt;/p&gt;&lt;p&gt;2、FileInputStream(File file)&lt;/p&gt;&lt;p&gt;操作的是上面D盘下的Files文件夹生成的&quot;stream.txt&quot;：&lt;/p&gt;&lt;pre&gt;package com.demo;&lt;br&gt;import java.io.File;&lt;br&gt;import java.io.FileInputStream;&lt;br&gt;import java.io.InputStream;&lt;br&gt;public class FileInputStreamTest {&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; public static void main(String[] args) throws Exception{&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; File file = new File(&quot;D:/Files/stream.txt&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; InputStream in = new FileInputStream(file);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; byte b1[] = new byte[(int)file.length()];&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int i = 0;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; i = in.read(b1);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println(i); // 字节长度&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println(new String(b1, 0, i));  // Hello World!!!&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&lt;b&gt;OutputStream的作用是将内容由Java内存输出到文件中、InputStream是将内容由文件输入到Java内存中&lt;/b&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h3&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;字符流&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; 字节流提供了处理任何类型输入/输出操作的功能（因为对于计算机而言，一切都是0和1，只需把数据以字节形式表示就够了），但它们不可以直接操作Unicode字符，因为一个Unicode字符占用2个字节，而字节流一次只能操作一个字节。既然Java的口号就是&quot;一次编写、处处运行&quot;，那么包含直接的字符输入/输出的支持是必要的。因此就有一些字符输入/输出流，字符流顶层是Reader和Writer这两个抽象类，&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;FileReader和FileWriter&lt;/span&gt;&lt;/p&gt;&lt;p&gt;FileReader类创建了一个可以读取文件内容的Reader类，最常用的构造方法是：&lt;/p&gt;&lt;p&gt;1、FileReader(String fileName)&lt;/p&gt;&lt;p&gt;2、FileReader(File file)&lt;/p&gt;&lt;p&gt;FileWriter创建了一个可以写文件的Writer类，最常用的构造方法是：&lt;/p&gt;&lt;p&gt;1、FileWriter(String fileName)&lt;/p&gt;&lt;p&gt;2、FileWriter(String fileName, boolean append)&lt;/p&gt;&lt;p&gt;3、FileWriter(File file)&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre&gt;package com.demo.io;&lt;br&gt;import java.io.File;&lt;br&gt;import java.io.FileReader;&lt;br&gt;import java.io.FileWriter;&lt;br&gt;import java.io.Reader;&lt;br&gt;import java.io.Writer;&lt;br&gt;public class FileReaderWriterTest {&lt;br&gt;&amp;nbsp; &amp;nbsp; public static void main(String[] args) throws Exception{&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; File file = new File(&quot;D:/Files/writer.txt&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Writer out = new FileWriter(file);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 声明一个String类型对象&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; String str = &quot;Hello World!!!&quot;;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; out.write(str);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; out.close();&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //读文件操作&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Reader in = new FileReader(file);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 开辟一个空间用于接收文件读进来的数据&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; char c0[] = new char[1024];&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int i = 0;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 将c0的引用传递到read()方法之中，同时此方法返回读入数据的个数&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; i = in.read(c0);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; in.close();&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if(i==-1){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println(&quot;文件中无数据&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }else{&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println(new String(c0,0,i));&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;FileWriter和FileReader的使用，和FileOutputStream和FileInputStream的使用差不多，不过实际操作中一般不会用FileWriter和FileReader&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;字符流进阶及BufferedWriter、BufferedReader&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;字符流和字节流的区别&lt;/b&gt;&lt;/p&gt;&lt;pre&gt;&amp;nbsp;public static void main(String[] args) throws Exception{&lt;br&gt;12&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;File file = new File(&quot;D:/Files/writer.txt&quot;);&lt;br&gt;13&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Writer out = new FileWriter(file);&lt;br&gt;14&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// 声明一个String类型对象&lt;br&gt;15&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;String str = &quot;Hello World!!!&quot;;&lt;br&gt;16&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;out.write(str);&lt;br&gt;17&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;out.close();&lt;br&gt;18&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;br&gt;19&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;//读文件操作&lt;br&gt;20&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Reader in = new FileReader(file);&lt;br&gt;21&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// 开辟一个空间用于接收文件读进来的数据&lt;br&gt;22&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;char c0[] = new char[1024];&lt;br&gt;23&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;int i = 0;&lt;br&gt;24&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// 将c0的引用传递到read()方法之中，同时此方法返回读入数据的个数&lt;br&gt;25&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;i = in.read(c0);&lt;br&gt;26&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;in.close();&lt;br&gt;27&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;if(i==-1){&lt;br&gt;28&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;System.out.println(&quot;文件中无数据&quot;);&lt;br&gt;29&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;}else{&lt;br&gt;30&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;System.out.println(new String(c0,0,i));&lt;br&gt;31&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;}&lt;br&gt;32&amp;nbsp; &amp;nbsp; &amp;nbsp;}&lt;/pre&gt;&lt;p&gt;第17行&quot;out.close()&quot;注释掉可以看一下效果，&quot;writer.txt&quot;一定是空的，控制台上输出的是&quot;文件中无数据&quot;，说明一下原因。&lt;/p&gt;&lt;p&gt;字符流和字节流非常相似，但也有区别，从网上找了一张图：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/upload/article/20191027/b7c30334891a7bda2882fc510de5d3f8.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 551px;&quot;&gt;&lt;/p&gt;&lt;p&gt;从图上看，字符流和字节流最大的区别在于，字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，而字符流操作时使用了缓冲区，通过缓冲区再操作文件。这也解释了上面程序的那个问题，为什么不对资源进行close()就无法写入文件的原因。因为在关闭字符流时会强制性地将缓冲区中的内容进行输出，但是如果没有关闭，缓冲区中的内容是无法输出的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;什么是缓冲区？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp;简单理解，缓冲区就是一块特殊的内存区域。&lt;/p&gt;&lt;p&gt;&lt;b&gt;为什么要使用缓冲区？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp;因为如果一个程序频繁操作一个资源（文件或数据库），则性能会很低，为了提升性能，就可以将一部分数据暂时读入（或写入）到内存的一块区域之中，以后直接从此区域读取数据即可，因为读取内存的速度要快于读取磁盘中文件内容的速度。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在字符流的操作中，所有的字符都是在内存中形成的，在输出前会将所有的内容暂时保存在内存之中，所以使用了缓冲区。&lt;/p&gt;&lt;p&gt;如果不想在关闭时再输出字符流的内容也行，使用Writer的&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;flush()&lt;/span&gt;方法就可以了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;字符流的原理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Java支持字符流和字节流，字符流本身就是一种特殊的字节流，之所以要专门有字符流，是因为Java中有大量对于字符的操作，所以专门有字符流。字节流和字符流的转换是以InputStreamReader和OutputStreamWriter为媒介的，InputStreamReader可以将一个字节流中的字节解码成字符，OutputStreamWriter可以将写入的字符编码成字节后写入一个字节流。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;InputStreamReader有两个主要的构造函数&lt;/span&gt;：&lt;/p&gt;&lt;p&gt;1、InputStreamReader(InputStream in)&lt;/p&gt;&lt;p&gt;2、InputStreamReader(InputStream in, String charsetName)&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;OutputStreamWriter也有两个主要的构造函数：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1、OutputStreamWriter(OutputStream out)&lt;/p&gt;&lt;p&gt;2、OutputStreamWriter(OutputStream out, String charsetName)&lt;/p&gt;&lt;p&gt;从构造函数就可以看出，字符流是利用字节流实现的。InputStreamReader和OutputStreamWriter的两个构造函数的区别在于：&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;一个是使用的默认字符集，一个可以指定字符集名称&lt;/span&gt;。其实FileReader和FileWriter可以看一下源码，很简单，只有构造函数，里面都是分别根据传入的文件绝对路径或者传入的File实例，new出FileInputStream和FileOutputStream，在调用InputStreamReader和OutputStreamWriter的构造方法。这么做，帮助开发者省去了实例化FileInputStream和FileOutputStream的过程，让开发者可以直接以fileName或file作为构造函数的参数。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;BufferedWriter、BufferedReader&lt;/span&gt;&lt;/p&gt;&lt;p&gt;为了达到最高的效率，避免频繁地进行字符与字节之间的相互转换，最好不要直接使用FileReader和FileWriter这两个类进行读写，而使用BufferedWriter包装OutputStreamWriter，使用BufferedReader包装InputStreamReader。同样，在D盘Files文件夹下没有&quot;buffered&quot;这个文件，代码示例为：&lt;/p&gt;&lt;pre&gt;package com.demo.io;&lt;br&gt;import java.io.BufferedReader;&lt;br&gt;import java.io.BufferedWriter;&lt;br&gt;import java.io.File;&lt;br&gt;import java.io.FileReader;&lt;br&gt;import java.io.FileWriter;&lt;br&gt;import java.io.Reader;&lt;br&gt;import java.io.Writer;&lt;br&gt;public class BufferedWriterReaderTest {&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; public static void main(String[] args) throws Exception{&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; File file = new File(&quot;D:/Files/buffered.txt&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Writer writer = new FileWriter(file);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; BufferedWriter bw = new BufferedWriter(writer);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; bw.write(&quot;1234\\n&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; bw.write(&quot;2345\\n&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; bw.write(&quot;3456\\n&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; bw.write(&quot;\\n&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; bw.write(&quot;4567\\n&quot;);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; bw.close();&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; writer.close();&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (file.exists() &amp;amp;&amp;amp; file.getName().endsWith(&quot;.txt&quot;)){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Reader reader = new FileReader(file);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; BufferedReader br = new BufferedReader(reader);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; String str = null;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; while ((str = br.readLine())!= null){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println(str);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; reader.close();&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; br.close();&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;运行一下，首先D盘Files文件夹下多出了&quot;buffered.txt&quot;这个文件，文件中的内容为：&lt;/p&gt;&lt;pre style=&quot;margin-bottom: 0px; padding: 0px; font-size: 12px; color: rgb(0, 0, 0); font-family: &amp;quot;Courier New&amp;quot; !important;&quot;&gt;1234\r\n2345\r\n3456\r\n\r\n4567&lt;/pre&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px;&quot;&gt;&lt;span style=&quot;font-family: &amp;quot;Courier New&amp;quot;; font-size: 12px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px;&quot;&gt;&lt;span style=&quot;font-family: &amp;quot;Courier New&amp;quot;; font-size: 12px;&quot;&gt;1、利用BufferedWriter进行写操作，写入的内容会放在缓冲区内，直到遇到close()、flush()的时候才会将内容一次性写入文件。另外注意close()的顺序，一定要先关闭BufferedWriter，再关闭Writer，不可以倒过来，因为BufferedWriter的写操作是通过Writer的write方法写的，如果先关闭Writer的话，就无法将缓冲区内的数据写入文件了，会抛出异常。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px;&quot;&gt;&lt;span style=&quot;font-family: &amp;quot;Courier New&amp;quot;; font-size: 12px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin-bottom: 0px; padding: 0px;&quot;&gt;&lt;span style=&quot;font-family: &amp;quot;Courier New&amp;quot;; font-size: 12px;&quot;&gt;2、利用BufferedReader进行读操作，不可以用父类Reader指向它，因为readLine()这个方法是BufferedReader独有的，readLine()的作用是逐行读取文件中的内容。&lt;/span&gt;&lt;/p&gt;\r\n                                                                                                                                                                            ',0,'2019-10-26 00:00:00','34',50),(226,1,'I/O模型的解析','','\n                                &lt;div&gt;&lt;b&gt;什么是同步？什么是异步？&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　同步就是：如果有多个任务或者事件要发生，这些任务或者事件必须逐个地进行，一个事件或者任务的执行会导致整个流程的暂时等待，这些事件没有办法并发地执行；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　异步就是：如果有多个任务或者事件发生，这些事件可以并发地执行，一个事件或者任务的执行不会导致整个流程的暂时等待。&lt;/div&gt;&lt;pre&gt;&lt;br&gt;void fun1() {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;}&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;void fun2() {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;}&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;void function(){&lt;br&gt;&amp;nbsp; &amp;nbsp; fun1();&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; fun2();&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; .....&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; .....&amp;nbsp;&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;这段代码就是典型的同步，在方法function中，fun1在执行的过程中会导致后续的fun2无法执行，fun2必须等待fun1执行完毕才可以执行。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;void fun1() {&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;}&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&lt;br&gt;void fun2() {&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;}&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;&lt;br&gt;void function(){&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; new Thread(){&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; public void run() {&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fun1();&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; }.start();&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; new Thread(){&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; public void run() {&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fun2();&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; }.start();&amp;nbsp;&lt;br&gt;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; .....&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; .....&amp;nbsp;&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;这段代码是一种典型的异步，fun1的执行不会影响到fun2的执行，并且fun1和fun2的执行不会导致其后续的执行过程处于暂时的等待。&lt;/div&gt;&lt;div&gt;&lt;b&gt;（上面使用多线程实现异步操作，并不是说只有多线程下才会实现异步操作，而是多线程时实现异步操作的一种方式而已）&lt;/b&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;什么是阻塞？什么是非阻塞？&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;在前面介绍了同步和异步的区别，这一节来看一下阻塞和非阻塞的区别。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　阻塞就是：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　非阻塞就是：当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　这就是阻塞和非阻塞的区别。也就是说阻塞和非阻塞的区别关键在于当发出请求一个操作时，如果条件不满足，是会一直等待还是返回一个标志信息。&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;什么是阻塞IO(BIO)? 什么是非阻塞IO(NIO)?&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　1）查看数据是否就绪；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　2）进行数据拷贝（内核将数据拷贝到用户线程）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　　那么阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;五种IO模型&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;五种IO模型包括：&lt;b&gt;阻塞IO、非阻塞IO、信号驱动IO、IO多路转接、异步IO&lt;/b&gt;。其中，前四个被称为同步IO。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;阻塞IO模型&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而此时的用户线程就会处于阻塞状态，用户线程交出CPU（失去了CPU执行权）。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态（解除当前线程的阻塞状态，此时线程会进入CPU就绪状态，等待下一次获取CPU执行权）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;典型的阻塞IO模型的例子为：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;data = socket.read();&amp;nbsp;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;如果数据没有就绪，就会一直阻塞在read方法。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;非阻塞IO模型&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; 当用户线程发起一个read操作后，并不需要等待（线程在执行过程中可以正常的获取CPU执行权，不会因为阻塞而失去获取CPU执行权的机会），而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回，此时当前的用户线程才算把任务执行完。&lt;/div&gt;&lt;div&gt;&lt;pre&gt;while(true){&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; data = socket.read();&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; if(data!= error){&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 处理数据&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; break;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;但是对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高（CPU会一直在工作），因此一般情况下很少使用while循环这种方式来读取数据。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;多路复用IO模型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;多路复用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。&lt;/p&gt;&lt;p&gt;　　在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。&lt;/p&gt;&lt;p&gt;　　在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。&lt;/p&gt;&lt;p&gt;&lt;b&gt;信号驱动IO模型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。&lt;/p&gt;&lt;p&gt;&lt;b&gt;异步IO模型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它收到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要知道实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。&lt;/p&gt;&lt;p&gt;　　也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n                                                                                        ',0,'2019-10-28 00:00:00','34',32),(227,1,'内存溢出与内存泄漏解析','','&lt;div&gt;&lt;b&gt;内存溢出（out of memory）：&lt;/b&gt;简单地说内存溢出就是指程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，于是就发生了内存溢出。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;内存泄漏（memory leak）：&lt;/b&gt;内存泄漏指程序运行过程中分配内存给临时变量，用完之后却没有被GC回收，始终占用着内存，既不能被使用也不能被GC回收，于是就发生了内存泄漏。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;内存泄漏会最终会导致内存溢出！&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;内存溢出有以下几种常见的情况：&lt;/b&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、java.lang.OutOfMemoryError: PermGen space (持久带溢出)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;我们知道jvm通过持久带实现了java虚拟机规范中的方法区，而运行时常量池就是保存在方法区中的，因此发生这种溢出可能是运行时常量池溢出，或是由于程序中使用了大量的jar或class，使得方法区中保存的class对象没有被及时回收或者class信息占用的内存超过了配置的大小。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、java.lang.OutOfMemoryError: Java heap space (堆溢出)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;发生这种溢出的原因一般是创建的对象太多，在进行垃圾回收之前对象数量达到了最大堆的容量限制。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;解决这个区域异常的方法一般是通过内存映像分析工具对Dump出来的堆转储快照进行分析，看到底是内存溢出还是内存泄漏。如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，定位出泄漏代码的位置，修改程序或算法；如果不存在泄漏，就是说内存中的对象确实都还必须存活，那就应该检查虚拟机的堆参数-Xmx(最大堆大小)和-Xms(初始堆大小)，与机器物理内存对比看是否可以调大。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3、虚拟机栈和本地方法栈溢出&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;常见的内存泄漏场景？&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1.静态集合类引起的内存泄漏：&lt;/div&gt;&lt;div&gt;像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，从而造成内存泄漏，因为他们也将一直被Vector等引用着。&lt;/div&gt;&lt;div&gt;&lt;pre&gt;Vector&amp;lt;Object&amp;gt; v=new Vector&amp;lt;Object&amp;gt;(100);&lt;br&gt;for (int i = 1; i&amp;lt;100; i++)&lt;br&gt;{&lt;br&gt;Object o = new Object();&lt;br&gt;v.add(o);&lt;br&gt;o = null;&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;2、修改HashSet中对象的参数值，且参数是计算哈希值的字段&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;当一个对象被存储到HashSet集合中以后，修改了这个对象中那些参与计算哈希值的字段后，这个对象的哈希值与最初存储在集合中的就不同了，这种情况下，用contains方法在集合中检索对象是找不到的，这将会导致无法从HashSet中删除当前对象，造成内存泄漏，举例如下：&lt;/div&gt;&lt;div&gt;&lt;pre&gt;public static void main(String[] args){&lt;br&gt;&amp;nbsp; &amp;nbsp; Set&amp;lt;Person&amp;gt; set = new HashSet&amp;lt;Person&amp;gt;();&lt;br&gt;&amp;nbsp; &amp;nbsp; Person p1 = new Person(&quot;张三&quot;,&quot;1&quot;,25);&lt;br&gt;&amp;nbsp; &amp;nbsp; Person p2 = new Person(&quot;李四&quot;,&quot;2&quot;,26);&lt;br&gt;&amp;nbsp; &amp;nbsp; Person p3 = new Person(&quot;王五&quot;,&quot;3&quot;,27);&lt;br&gt;&amp;nbsp; &amp;nbsp; set.add(p1);&lt;br&gt;&amp;nbsp; &amp;nbsp; set.add(p2);&lt;br&gt;&amp;nbsp; &amp;nbsp; set.add(p3);&lt;br&gt;&amp;nbsp; &amp;nbsp; System.out.println(&quot;总共有:&quot;+set.size()+&quot; 个元素!&quot;); //结果：总共有:3 个元素!&lt;br&gt;&amp;nbsp; &amp;nbsp; p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变&lt;br&gt;&amp;nbsp; &amp;nbsp; set.remove(p3); //此时remove不掉，造成内存泄漏&lt;br&gt;&amp;nbsp; &amp;nbsp; set.add(p3); //重新添加，可以添加成功&lt;br&gt;&amp;nbsp; &amp;nbsp; System.out.println(&quot;总共有:&quot;+set.size()+&quot; 个元素!&quot;); //结果：总共有:4 个元素!&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; for (Person person : set){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println(person);&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;3、监听器&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。&lt;/p&gt;&lt;p&gt;4、各种连接&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close() 方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去连接，在finally里面释放连接。&lt;/p&gt;&lt;p&gt;5、单例模式&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp;如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露。&lt;/p&gt;&lt;p&gt;&amp;nbsp; 不正确使用单例模式是引起内存泄露的一个常见问题，单例对象在被初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露，考虑下面的例子：&lt;/p&gt;&lt;pre&gt;class A{&lt;br&gt;&amp;nbsp; &amp;nbsp; public A(){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; B.getInstance().setA(this);&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; ....&lt;br&gt;}&lt;br&gt;//B类采用单例模式&lt;br&gt;class B{&lt;br&gt;&amp;nbsp; &amp;nbsp; private A a;&lt;br&gt;&amp;nbsp; &amp;nbsp; private static B instance=new B();&lt;br&gt;&amp;nbsp; &amp;nbsp; public B(){}&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; public static B getInstance(){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return instance;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; public void setA(A a){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.a=a;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; //getter...&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收，所以造成内存泄漏&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;避免内存泄漏的几点建议：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;1、尽早释放无用对象的引用。&lt;/p&gt;&lt;p&gt;2、避免在循环中创建对象。&lt;/p&gt;&lt;p&gt;3、使用字符串处理时避免使用String，应使用StringBuffer。&lt;/p&gt;&lt;p&gt;4、尽量少使用静态变量，因为静态变量存放在永久代，基本不参与垃圾回收。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;\n                                                            ',0,'2019-10-29 00:00:00','34',17),(228,1,'Java常见的几种内存溢出类型及解决方案','','\n                                &lt;div&gt;&lt;b&gt;1.JVM Heap（堆）溢出：java.lang.OutOfMemoryError: Java heap space （堆内存溢出型）&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;JVM在启动的时候会自动设置JVM Heap的值， 可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap的大小是Young Generation 和Tenured Generaion 之和。在JVM中如果98%的时间是用于GC,且可用的Heap size 不足2%的时候将抛出此异常信息。&lt;/div&gt;&lt;div&gt;解决方法：手动设置JVM Heap（堆）的大小。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Java堆用于储存对象实例。当需要为对象实例分配内存，而堆的内存占用又已经达到-Xmx设置的最大值。将会抛出OutOfMemoryError异常。例子如下：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;&lt;br&gt;package com.demo.test;&lt;br&gt;import java.util.ArrayList;&lt;br&gt;import java.util.List;&lt;br&gt;/**&lt;br&gt;&amp;nbsp;* VM Args: -Xms5m -Xmx5m&lt;br&gt;&amp;nbsp;*/&lt;br&gt;public class HeapOOM {&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; public static void main(String[] args) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int count = 0;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; List&amp;lt;Object&amp;gt; list = new ArrayList&amp;lt;Object&amp;gt;();&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; while(true){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; list.add(new Object());&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println(++count);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;然后在运行时通过工具设置jvm参数，如下：&lt;/p&gt;&lt;div&gt;设置-Xmx为5m。其中的一次测试结果为，当count的值累加到360145时，发生如下异常：&lt;/div&gt;&lt;div&gt;&lt;pre&gt;Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space&lt;br&gt;&amp;nbsp; &amp;nbsp; at java.util.Arrays.copyOf(Arrays.java:2245)&lt;br&gt;&amp;nbsp; &amp;nbsp; at java.util.Arrays.copyOf(Arrays.java:2219)&lt;br&gt;&amp;nbsp; &amp;nbsp; at java.util.ArrayList.grow(ArrayList.java:213)&lt;br&gt;&amp;nbsp; &amp;nbsp; at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:187)&lt;br&gt;&amp;nbsp; &amp;nbsp; at java.util.ArrayList.add(ArrayList.java:411)&lt;br&gt;&amp;nbsp; &amp;nbsp; at com.demo.test.HeapOOM.main(HeapOOM.java:12)&lt;/pre&gt;&lt;p&gt;修改-Xmx为10m。其中的一次测试结果为，当count的值累加到540217时，发生OutOfMemoryError异常。随着-Xmx参数值的增大，java堆中可以存储的对象也越多。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.PermGen space溢出： java.lang.OutOfMemoryError: PermGen space（持久带内存溢出型）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; PermGen space的全称是Permanent Generation space，是指内存的永久保存区域。为什么会内存溢出，这是由于这块内存主要是被JVM存放Class和Meta信息的，Class在被Load的时候被放入PermGen space区域，它和存放Instance的Heap区域不同，sun的 GC不会在主程序运行期对PermGen space进行清理，所以如果你的APP会载入很多CLASS的话，就很可能出现PermGen space溢出。一般发生在程序的启动阶段。&lt;/p&gt;&lt;p&gt;解决方法： 通过-XX:PermSize和-XX:MaxPermSize设置永久代大小即可。&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 方法区用于存放java类型的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。在类装载器加载class文件到内存的过程中，虚拟机会提取其中的类型信息，并将这些信息存储到方法区。当需要存储类信息而方法区的内存占用又已经达到-XX:MaxPermSize设置的最大值，将会抛出OutOfMemoryError异常。对于这种情况的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。这里需要借助CGLib直接操作字节码运行时，生成了大量的动态类。例子如下：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.栈溢出： java.lang.StackOverflowError : Thread Stack space（栈内存溢出）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp;栈溢出了，JVM依然是采用栈式的虚拟机，这个和C和Pascal都是一样的。函数的调用过程都体现在堆栈和退栈上了。调用构造函数的 “层”太多了，以致于把栈区溢出了。 通常来讲，一般栈区远远小于堆区的，因为函数调用过程往往不会多于上千层，而即便每个函数调用需要 1K的空间（这个大约相当于在一个C函数内声明了256个int类型的变量），那么栈区也不过是需要1MB的空间。通常栈的大小是1-2MB的。通俗一点讲就是单线程的程序需要的内存太大了。 通常递归也不要递归的层次过多，很容易溢出。&lt;/p&gt;&lt;p&gt;解决方法：1：修改程序。2：通过 -Xss: 来设置每个线程的Stack大小即可。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在Java虚拟机规范中，对这个区域规定了两种异常状况：&lt;b&gt;StackOverflowError&lt;/b&gt;和&lt;b&gt;OutOfMemoryError&lt;/b&gt;异常。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）StackOverflowError异常 （线程运行过程中出现）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;每当java程序代码启动一个新线程时，Java虚拟机都会为它&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;分配一个Java栈&lt;/span&gt;。Java栈以帧为单位保存线程的运行状态。&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;当线程调用java方法时，虚拟机压入一个新的栈帧到该线程的java栈中&lt;/span&gt;。只要这个方法还没有返回，它就一直存在。如果线程的方法嵌套调用层次太多(如递归调用)，随着java栈中帧的逐渐增多，最终会由于该线程java栈中所有栈帧大小总和大于-Xss设置的值，而产生StackOverflowError内存溢出异常。例子如下：&lt;/p&gt;&lt;pre&gt;package com.demo.test;&lt;br&gt;/**&lt;br&gt;&amp;nbsp;* VM Args: -Xss128k&lt;br&gt;&amp;nbsp;*/&lt;br&gt;public class JavaVMStackSOF {&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; private int count = 0;&lt;br&gt;&amp;nbsp; &amp;nbsp; public static void main(String[] args) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; new JavaVMStackSOF().method(); // 线程调用递归方法，在此过程中虚拟机会不断的向该线程的java栈中添加栈帧&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; public void method() {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println(++count);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; method();&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;（2）OutOfMemoryError异常（线程启动过程中出现）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;java程序代码启动一个新线程时，没有足够的内存空间为该线程分配java栈(一个线程java栈的大小由-Xss参数确定)，jvm则抛出OutOfMemoryError异常。例子如下：&lt;/p&gt;&lt;pre&gt;package com.demo.test;&lt;br&gt;/**&lt;br&gt;&amp;nbsp;* VM Args: -Xss128k&lt;br&gt;&amp;nbsp;*/&lt;br&gt;public class JavaVMStackOOM {&lt;br&gt;&amp;nbsp; &amp;nbsp; public static void main(String[] args) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int count = 0;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; while (true) { // 无限创建线程堆满内存空间，等到内存不足的时候，再创建线程时会抛出异常&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Thread thread = new Thread(new Runnable() {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; public void run() {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; while (true) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; try {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Thread.sleep(5000);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; } catch (Exception e) {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; });&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; thread.start();&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println(++count);&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;随着-Xss参数值的增大，java程序可以创建的总线程数越少。为&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;每个线程的Stack设置大小，而最佳值应该是128K,默认值好像是512k。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Server容器启动的时候我们经常关心和设置JVM的几个参数如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;-Xms：java Heap初始大小， 默认是物理内存的1/64。&lt;/p&gt;&lt;p&gt;-Xmx：java Heap最大值，不可超过物理内存。&lt;/p&gt;&lt;p&gt;-Xmn：young generation的heap大小，一般设置为Xmx的3、4分之一 。增大年轻代后，将会减小年老代大小，可以根据监控合理设置。&lt;/p&gt;&lt;p&gt;-Xss：每个线程的Stack大小，而最佳值应该是128K,默认值好像是512k。&lt;/p&gt;&lt;p&gt;-XX:PermSize：设定内存的永久保存区初始大小，缺省值为64M。&lt;/p&gt;&lt;p&gt;-XX:MaxPermSize：设定内存的永久保存区最大大小，缺省值为64M。&lt;/p&gt;&lt;p&gt;-XX:SurvivorRatio：Eden区与Survivor区的大小比值，设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1/10。&lt;/p&gt;&lt;p&gt;-XX:+UseParallelGC：F年轻代使用并发收集，而年老代仍旧使用串行收集。&lt;/p&gt;&lt;p&gt;-XX:+UseParNewGC：设置年轻代为并行收集，JDK5.0以上，JVM会根据系统配置自行设置，所无需再设置此值。&lt;/p&gt;&lt;p&gt;-XX:ParallelGCThreads：并行收集器的线程数，值最好配置与处理器数目相等 同样适用于CMS。&lt;/p&gt;&lt;p&gt;-XX:+UseParallelOldGC：年老代垃圾收集方式为并行收集(Parallel Compacting)。&lt;/p&gt;&lt;p&gt;-XX:MaxGCPauseMillis：每次年轻代垃圾回收的最长时间(最大暂停时间)，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。&lt;/p&gt;&lt;p&gt;-XX:+ScavengeBeforeFullGC：Full GC前调用YGC,默认是true。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;\n                                                                                        ',0,'2019-10-29 00:00:00','34',49),(229,1,'Java内存模型（JMM）解析','','\n                                \n                                &lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;什么是Java内存模型？&lt;/b&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在了解java内存模型之前，我们先来看看计算机的内存模型&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;CPU执行过程&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道，而计算机上面的临时数据，是储存在主存中的（计算机物理内存）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;计算机内存包括高速缓存和主存。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;我们知道CPU执行指令的速度比从主存读取数据和向主存写入数据快很多，所以为了高效利用CPU，在它们之间添加了一层缓存区（高速缓存(cache)）来匹配CPU的执行速度，最终程序的执行过程如下&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1.首先会将数据从主存中复制一份到CPU的高速缓存中&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.当CPU执行计算的时候就可以直接从高速缓存中读取数据和写入数据&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.当运算结束后，再将高速缓存的数据更新到主存中&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191030/56c4c952e7ca953e4be8ad433fc1b318.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 553px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;数据一致性问题&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;上面的执行过程在单线程情况下并没有问题，但是在多线程情况下就会出现问题，因为CPU如果含有多个核心，则每个核心都有自己独占高速缓存，如果出现多个线程同时执行同一个操作，那么结果是无法预知。例如2个线程同时执行i++，假设i的初始值是0，那么我们希望2个线程执行完成之后i的值变为2，但是在并发情况下，当线程1从主内存中读取i的值为0，把它改为1时，写入到&lt;span style=&quot;background-color: rgb(255, 255, 0); color: rgb(255, 0, 0);&quot;&gt;自己的高速缓存&lt;/span&gt;中，但是还没有写入主内存；当线程2读取i的值时，此时还是读取的是主内存的i(此时的i值还是为0)；当两个线程完成操作后，主内存的i可能会是1，而不是我们希望的2；出现这个情况，我们称为缓存不一致问题。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191030/06c3ba1d173f948e57e9e5fbe1c1c055.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 579px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;那么如何解决CPU出现的缓存不一致问题呢？通常使用的解决方法有2种：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1.通过给总线加锁&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.使用缓存一致性协议&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191030/ac3d614cc19ca435f4dbd09323a3a1e0.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 622px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;第1种方法虽然也达到了目的，但是在总线被锁住的期间，其他的CPU也无法访问主存，效率很低，所以就出现了缓存一致性协议&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;第2种方法，其中最出名的就是Intel的MESI协议，MESI协议保证每个CPU高速缓存中的变量都是一致的。它的核心思想是，当CPU写数据时候，如果发现操作的变量是共享变量&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;(即其他CPU上也存时，会立即刷到主内存中，然后通知其它CPU)&lt;/span&gt;，就会发出信号通知其他CPU将它高速缓存中缓存这个变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己高速缓存中缓存该变量的缓存行为无效状态，那么它就会从主存中重新读取。&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191030/bda53838124abe93f4ef28a79d8e9db1.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 537px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;处理器重排序问题&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在多线程场景下，CPU除了会出现缓存一致性问题，还会出现因为处理器重排序即处理器(CPU)为了提高效率可能会对输入的代码进行乱序执行，而造成多线程的情况下出现问题。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;例如：&lt;/div&gt;&lt;pre&gt;&lt;br&gt;//线程1:&lt;br&gt;context = getContext(); //语句1&lt;br&gt;inited = true; //语句2&lt;br&gt;//线程2:&lt;br&gt;while(!inited ){&lt;br&gt;sleep()&lt;br&gt;}&lt;br&gt;doSomethingByText(context);&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;线程1由于处理器重排序，先执行性了语句2，那么此时线程2会认为context已经初始化完成，那么跳出循环，去执行doSomethingByText(context)方法，实际上此时context并未初始化(即线程1的语句1还未执行)，而导致程序出错。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;什么是计算机内存模型&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;计算机中内存分为高速缓存内存和主内存，线程在执行过程中会将数据依次写入到两个内存中去&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;上面提到的缓存一致性问题、处理器重排序问题都是在多线程情况下CPU可能出现的问题，那我们应该怎么处理这些问题？&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;可见性即当一个变量修改后，这个变量会马上更新到主存中，其他线程会收到通知这个变量修改过了，使用这个变量的时候重新去主存获取&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Java内存模型(Java Memory Model，JMM)&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;JMM规定了所有的变量都存储在主存中，每个线程都有自己的工作区（相当于计算机中的高速缓存区），线程将使用到的变量从主存中复制一份到自己的工作区，线程对变量的所有操作(读取、赋值等)都必须在工作区，不同的线程也无法直接访问对方工作区，线程之间的消息传递都需要通过主存来完成。可以把jvm中的主存类比成计算机内存模型中的主存，工作区类比成计算机内存模型中的高速缓存。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;而我们知道JMM其实是工作在计算机主存中的，Java内存模型中的工作区也是计算机主存中的一部分，所以可以这样说Java内存模型解决的是内存一致性问题(java主存和计算机主存)而计算机内存模型解决的是缓存一致性问题(CPU高速缓存和主存)，这两个模型类似，但是作用域不一样，Java内存模型保证的是主存和主存之间的原子性、可见性、有序性，而计算机内存模型保证的是CPU高速缓存和主存之间的原子性、可见性、有序性。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191030/fa435b577f8cba3015aaa12f0a9b1831.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 594px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;工作内存与主内存（jvm主内存）之间交互操作&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191030/b7df9d39fa4a1ef8d5047a7f10c363f0.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 746px;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; 关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;1、lock（锁定）：作用于主内存中的变量，它把一个变量标识为一条线程独占的状态。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、unlock（解锁）：作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3、read（读取）：作用于主内存中的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;4、load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;5、use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;6、assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;7、store（存储）：作用于工作内存中的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;8、write（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量值放入主内存的变量中。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行以下两个操作：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;（1）由JVM主内存执行的读（read）操作；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;（2）由Java线程的工作内存执行相应的load操作。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;反过来，如果把变量从工作内存中同步回主内存中，也出现两个操作：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;（1）由Java线程的工作内存执行的存储（store）操作；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;（2）由JVM主内存执行的相应的写（write）操作。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;volatile型变量的作用&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 上面说过，read，load，store，write的操作都是原子的，即执行期间不会被中断！但是各个原子操作之间可能会发生中断！对于普通变量，如果一个线程中那份主内存变量值的拷贝更新了，并不能马上反应在其他变量中，因为Java的每个线程都私有一个工作内存，里面存储了该条线程需要用到的主内存中的变量拷贝！（比如实例的字段信息，类型的静态变量，数组，对象……）如图：&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191031/2c873c0fbe8a4071918383975941a5fd.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 530px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;A，B两条线程直接读or写的都是线程的工作内存！而A、B使用的数据从各自的工作内存传递到同一块主内存的这个过程是有时差的，或者说是有隔离的！通俗的说他们之间看不见！也就是之前说的一个线程中的变量被修改了，是无法立即让其他线程看见的！如果需要在其他线程中立即可见，需要使用 volatile 关键字。现在引出volatile关键字：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制。一个变量被定义为volatile后，它将具备两种特性：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1、&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;保证此变量对所有线程的&quot;可见性&quot;&lt;/span&gt;，所谓&quot;可见性&quot;是指当一条线程修改了这个变量的值，新值对于其它线程来说都是可以立即得知的，而普通变量不能做到这一点，普通变量的值在在线程间传递均需要通过主内存来完成。例如，线程A修改一个普通变量的值，然后将变量的值写回主内存，另外一个线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。另外，java里面的运算并非原子操作，会导致volatile变量的运算在并发下一样是不安全的。再强调一遍，&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;volatile只保证了可见性，并不保证基于volatile变量的运算在并发下是安全的&lt;/span&gt;。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2、&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;使用volatile变量的第二个语义是禁止指令重排序优化&lt;/span&gt;，普通变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0); font-weight: bold;&quot;&gt;可见性&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0); font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;1.每次读取前必须先从主内存刷新最新的值。（线程在读取使用volatile修饰的共享变量时，不会直接使用旧的工作内存中的拷贝值，而是先到主内存中把该变量的值重新拷贝一下到工作内存中，然后再使用）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.每次写入后必须立即同步回主内存当中。（线程只要改变了使用volatile修饰的共享变量时，就会立马同步刷新到主内存中，）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;public class MutableInteger {&lt;br&gt;&amp;nbsp; &amp;nbsp; private int value;&lt;br&gt;&amp;nbsp; &amp;nbsp; public int get(){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return value;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; public void set(int value){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.value = value;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;MutableInteger不是线程安全的，因为get和set方法都是在没有同步的情况下进行的。如果线程1调用了set方法，那么正在调用的get的线程2可能会看到更新后的value值，也可能看不到。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;解决方法很简单，将value声明为volatile变量：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;private volatile int value;&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;所以使用volatile修饰的共享变量，其它线程时可见的。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0); font-weight: bold;&quot;&gt;防止指令重排&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;a.重排序操作不会对存在数据依赖关系的操作进行重排序。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　 比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;行时这两个操作不会被重排序。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;b.重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;　 比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系， 所以可能会发&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果，下例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行status=true再执行a=2。而此时线程B会顺利到达4处，而线程A中a=2这个操作还未被执行，所以b=a+1的结果也有可能依然等于2。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;public class&amp;nbsp; Test{&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;int a = 1;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;boolean status = false;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;public void changeStatus(){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp;a = 2 // ----------01&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp;status = true // -----------02&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;public void run(){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;if(status){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;nbsp; &amp;nbsp;int b = a+1&amp;nbsp; // -----------03&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;&amp;nbsp; &amp;nbsp;System.out.println(b)&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;}&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序,volatile禁止指令重排序也有一些规则：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;a.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;面的操作可见；在其后面的操作肯定还没有进行；&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;b.在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;到其前面执行。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;量及其后面语句可见。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;原子性、可见性、有序性&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;什么是原子性？&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在Java中，对基本数据类型的变量的操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。看例子：&lt;/div&gt;&lt;pre&gt;int x = 10;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;//语句1&lt;br&gt;y = x;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;//语句2&lt;br&gt;x++;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //语句3&lt;br&gt;x = x + 1;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; //语句4&lt;/pre&gt;&lt;p&gt;其实只有语句1是原子性操作，其他三个语句都不是原子性操作。语句1是直接将数值10赋值给x，也就是说线程执行这个语句会直接将数值10写入到工作内存中。线程执行语句2实际上包含2个操作，它先要去主内存读取x的值，再将x的值写入工作内存，虽然读取x的值以及将x的值写入工作内存这2个操作都是原子性操作，但是合起来就不是原子性操作了。同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。所以上面4个语句只有语句1的操作具备原子性。也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;所以使用volatile关键字修饰上面的x变量，如果它们是执行语句2,3,4这样的操作时，也是不能保证原子性的&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;什么是可见性？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;就是一个线程修改了变量，其他线程可以立即能够知道。保证可见性可以使用之前提到的volatile关键字（强制立即写入主内存，使得其他线程共享变量缓存行失效），还有重量级锁synchronized （也就是线程间的同步，unlock之前，写变量值回主存，看作顺序执行的），最后就是常量——final修饰的(一旦初始化完成，其他线程就可见)。其实这里忍不住还是补充下，&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;关键字volatile 的语义除了保证不同线程对共享变量操作的可见性，还能禁止进行指令重排序！也就是保证有序性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;什么是有序性？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无须的。Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由&quot;一个变量在同一时刻只允许一条线程对其进行lock操作&quot;这条规则获得的，这条规则规定了持有同一个锁的两个同步块只能串行地进入。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; 工作内存和主内存同步延时（也就是线程A先后更新两个变量m和n，但是由于线程工作内存和JVM主内存之间的同步延时，线程B可能还没完全同步线程A更新的两个变量，可能先看到了n……对于B来说，它看A的操作就是无序的，顺序无法保证）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;\n                                                                                                                    ',0,'2019-10-30 00:00:00','34',21),(230,1,'Java中类加载机制解析','','\n                                &lt;div&gt;&lt;b&gt;什么是类的加载&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; 类的加载指的是将类的.class文件中的二进制数据读入到内存中（我们打包的项目最终在JVM运行的就是java源文件编译后的.class文件，当JVM运行时，就会把这些.class文件通过类加载器加载到内存当中。），将其放在运行时数据区的方法区内（比如：类名，类的方法，属性值等等就是放在这个区的），然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象（我们使用new创建的Class对象就是放在这个区的），Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口（比如我们使用对象调用方法，就是调用在方法区中保存的Class对应的方法）。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191031/2f2b7fc390dc3fafc004f842c87e87ae.jpg&quot; data-filename=&quot;img&quot; style=&quot;width: 853.818px; height: 417px;&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;类加载器&lt;/span&gt;加载类是按需加载的并不是一次性把所有的.class文件都加载到内存中去：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;比如继承的父类，实现的接口，声明的变量，方法的返回类型等。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;就是在使用当前的类时，缺少哪些必要的类都会立即加载。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\n                                                                                        ',0,'2019-09-18 00:00:00','34',10),(231,1,' vue中vue2-dropzone 多文件上传插件的使用','','\n                                \n                                \n                                &lt;div&gt;下载依赖包 推荐使用cnpm&amp;nbsp;&lt;/div&gt;&lt;div&gt;cnpm install vue2-dropzone --save&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;API文档 &lt;a href=&quot;https://rowanwins.github.io/vue-dropzone/docs/dist/index.html#/installation&quot;&gt;https://rowanwins.github.io/vue-dropzone/docs/dist/index.html#/installation&lt;/a&gt;&lt;/div&gt;&lt;div&gt;vue-dropzone的github地址 :&lt;a href=&quot;https://github.com/rowanwins/vue-dropzone&quot; target=&quot;_blank&quot;&gt;https://github.com/rowanwins/vue-dropzone&lt;/a&gt;&lt;/div&gt;&lt;div&gt;dropzone.js官网 ：&lt;a href=&quot;https://www.dropzonejs.com&quot;&gt;https://www.dropzonejs.com&lt;/a&gt;&lt;a href=&quot;https://www.dropzonejs.com/&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;vue2-dropzone有提供许多的events事件，但是在使用的时候我们一般只需要一个添加成功后的回调事件（&lt;b&gt;vdropzone-success&lt;/b&gt;）和删除文件的回调事件（&lt;b&gt;vdropzone-removed-file&lt;/b&gt;）基本上可以满足我们的一个业务需求&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;使用方式&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在一个.vue文件中直接引入vue2-dropzone组件&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;&amp;lt;vue-dropzone ref=&quot;myVueDropzone&quot; id=&quot;dropzonearea&quot;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; :options=&quot;dropzoneOptions&quot;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; :useCustomSlot=true&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; :include-styling=&quot;false&quot;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; v-on:vdropzone-success=&quot;uploadSuccess&quot;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; v-on:vdropzone-removed-file=&quot;removedFile&quot;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;lt;!--自定义拖拽区域中的提示信息--&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;resumeDragWrap defaultMessageWrap&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;resumeTipsBg&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;resumeTipsTitle&quot;&amp;gt;上传或拖拽上传&amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;resumeTipsCon&quot;&amp;gt;仅支持：.rar .zip .doc .docx .html .pdf .jpg .png格式的文件&amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;lt;/div&amp;gt;&lt;br&gt;&amp;lt;/vue-dropzone&amp;gt;&lt;br&gt;&lt;br&gt;import vue2Dropzone from \'vue2-dropzone\'&amp;nbsp; // 导入组件&lt;br&gt;export default {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;name: \'selfAddWrap\',&lt;br&gt;&amp;nbsp; &amp;nbsp; components: {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; vueDropzone: vue2Dropzone&lt;br&gt;&amp;nbsp; &amp;nbsp; },&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;data(){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; return{&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;dropzoneOptions: {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; url: \'/admin/add_resume/resumeEnclosureUpload\', // 文件上传接口&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; previewTemplate: this.template(),&amp;nbsp; // 自定义文件上传后显示的样式&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;},&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;methods:{&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; // 自定义文件上传后显示的样式&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;template(){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return `&amp;lt;div class=&quot;dz-preview dz-file-preview&quot;&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 必须在在这个容器中自定义布局样式&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;/div&amp;gt;`;&lt;br&gt;&amp;nbsp; &amp;nbsp; &lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;},&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; // 文件上传成功回调该方法，获取服务器响应信息&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; uploadSuccess(file, response){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if(response.code == 200) {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; file.upload.file_url = response.data&amp;nbsp; // 记录文件上传后保存在服务端的路径，用于后续提交存入数据库&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }else{&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; let errorEle,preview&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; errorEle = file.previewElement.querySelector(&quot;.error-message&quot;);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; errorEle.innerHTML= `&amp;lt;i class=&quot;el-icon-warning-outline&quot;&amp;gt;&amp;lt;/i&amp;gt;&amp;amp;nbsp;`+response.msg&amp;nbsp; &amp;nbsp;// 自定义显示异常提示&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; preview = file.previewElement&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; preview.style.background&amp;nbsp; = &quot;rgba(235,103,81,0.1)&quot;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; preview.style.borderColor = &quot;#fdefed&quot;&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; },&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; // 移除文件并在服务端删除该文件&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; removedFile(file, error, xhr){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if(file.upload.file_url){&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; let formData = new FormData(); // 通过FormData 传输file二进制文件数据&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; formData.append(\'filePath\', file.upload.file_url);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; let xhr = new XMLHttpRequest();&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 接收response信息&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; xhr.onload = function () {&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // var json = JSON.parse(xhr.responseText);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // console.log(json)&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // ... 这里处理返回的json数据&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; };&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; xhr.open(\'POST\', \'/admin/add_resume/remFileByPath\', true);&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; xhr.send(formData)&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;&amp;nbsp; &amp;nbsp; },&lt;br&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;}&lt;br&gt;}&lt;br&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;vue-dropzone 的几个属性解释&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;:useCustomSlot=true&amp;nbsp; &amp;nbsp;// 自定义拖拽区域的提示信息&lt;/div&gt;&lt;div&gt;:include-styling=&quot;false&quot;&amp;nbsp; &amp;nbsp;// 屏蔽插件自定的样式&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;v-on:vdropzone-success=&quot;uploadSuccess&quot;&amp;nbsp; &amp;nbsp; &amp;nbsp;// 自定义事件 上传成功后调用&amp;nbsp;&lt;/div&gt;&lt;div&gt;v-on:vdropzone-removed-file=&quot;removedFile&quot;&amp;nbsp; // 自定义事件 把文件从拖拽区域移除后调用&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;ref=&quot;myVueDropzone&quot;&amp;nbsp; &amp;nbsp;// 用于获取插件的dom节点，调用提供的方法；如提交表单时我们可以使用 ：let files = this.$refs.myVueDropzone.getAcceptedFiles()&amp;nbsp; // 获取全部的附件信息,根据需要获取有用的信息提交入库&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;自定义显示模版需要注意几个点 previewTemplate: this.template()&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果我们希望自定义的模版可以显示：异常提示、进度条、文件大小、自定义文件名等等需要在显示的标签上加对应的属性&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;template: function () {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return `&amp;lt;div class=&quot;dz-preview dz-file-preview&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;dz-image&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // data-dz-thumbnail-bg 显示base64格式的图&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;div data-dz-thumbnail-bg&amp;gt;&amp;lt;/div&amp;gt;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;dz-details&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // data-dz-size 显示文件大小&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;dz-size&quot;&amp;gt;&amp;lt;span data-dz-size&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // data-dz-name 显示文件名&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;dz-filename&quot;&amp;gt;&amp;lt;span data-dz-name&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // data-dz-uploadprogress 显示上传进度条&amp;nbsp; （注意 span 标签必须设置为inline-block）&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;dz-progress&quot;&amp;gt;&amp;lt;span class=&quot;dz-upload&quot; data-dz-uploadprogress&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // data-dz-errormessage 显示上传异常信息&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;dz-error-message&quot;&amp;gt;&amp;lt;span data-dz-errormessage&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // data-dz-remove 移除文件的，这个会触发 vdropzone-removed-file 事件调用 removedFile方法&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;dz-error-mark&quot;&amp;gt;&amp;lt;i class=&quot;fa fa-close&quot;&amp;nbsp; data-dz-remove&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; `;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; },&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;注：如果自定义模板样式不起作用，可以把样式全部写成行内样式&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;自己定义的模板&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;template(){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return `&amp;lt;div class=&quot;dz-preview dz-file-preview&quot; style=&quot;background:#F9FAFC;&quot;&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;enclosureUploadWrap&quot; style=&quot;position: relative;border:1px solid #EBEBEB;margin-bottom:7px;border-radius:4px;&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;i class=&quot;el-icon-picture-outline fileIconWrap&quot; style=&quot;margin-left: 10px; margin-right: 8px; font-size: 16px;vertical-align: sub;&quot;&amp;gt;&amp;lt;/i&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;resumeUploading&quot; style=&quot;display:inline-block;&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;span class=&quot;dz-filename&quot; data-dz-name&amp;gt;&amp;lt;/span&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;span style=&quot;color:#E66751;margin-left:20px;display:inline-block;&quot; class=&quot;dz-error-message&quot;&amp;gt;&amp;lt;span data-dz-errormessage class=&quot;error-message&quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;dz-progress&quot; style=&quot;display:inline-block;width:100px;height:8px;border-radius:4px;position:absolute;top:11px;right:20%;background:#ebeef5;&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;span&amp;nbsp; class=&quot;dz-upload &quot; style=&quot;display:inline-block;background: rgb(176, 189, 201);width:0%;height:100%;position:absolute;top:0px;left:0px;border-radius:4px;&quot; data-dz-uploadprogress&amp;gt;&amp;lt;/span&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;dz-size&quot;&amp;nbsp; style=&quot;position:absolute;top:0px;right:15%;display:inline-block;height:30px;line-height:30px;&quot;&amp;gt;&amp;lt;span data-dz-size&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;div class=&quot;resumeDealIcon &quot; style=&quot;position:absolute;top:0px;right:20px;color:red;inline-block;font-size:14px;padding-left:20px;&quot;&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;span&amp;gt;&amp;lt;i class=&quot;el-icon-delete&quot; data-dz-remove&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/span&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;/div&amp;gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;lt;/div&amp;gt;`;&lt;br&gt;&amp;nbsp; &amp;nbsp; },&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;后端服务器接收上传的二进制文件（TP5为例）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;虽然说是多文件上传，但是调用上传接口时，并不是一次性把所有文件的二进制数据都传到服务端，而是分块上传，即上传多少个文件就会调用多少次接口，单独上传二进制文件数据到后端&lt;br&gt;&lt;/p&gt;&lt;div style=&quot;color: rgb(248, 248, 242); background-color: rgb(39, 40, 34); font-family: Consolas, &amp;quot;Courier New&amp;quot;, monospace; font-size: 14px; line-height: 19px; white-space: pre;&quot;&gt;&lt;div&gt;&lt;span style=&quot;color: #75715e;&quot;&gt;/**&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #75715e;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*&amp;nbsp;des:简历附件上传&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: #75715e;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*/&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;function&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #a6e22e;&quot;&gt;resumeEnclosureUpload&lt;/span&gt;()&amp;nbsp;{&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$file&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #a6e22e;&quot;&gt;request&lt;/span&gt;()&lt;span style=&quot;color: #f92672;&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;file&lt;/span&gt;(&lt;span style=&quot;color: #e6db74;&quot;&gt;\'file\'&lt;/span&gt;);  // 获取上传的二进制文件数据&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$uploadObjec&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #66d9ef;font-style: italic;&quot;&gt;UploadFileController&lt;/span&gt;();&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$info&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;=&lt;/span&gt;&amp;nbsp;$uploadObjec&lt;span style=&quot;color: #f92672;&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;fileUpload&lt;/span&gt;($file);&lt;/div&gt;&lt;br&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color: #a6e22e;&quot;&gt;json&lt;/span&gt;($info);&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/upload/article/20191101/79437f2a8fd7e1468e5b59fbad77e77a.png&quot; data-filename=&quot;img&quot; style=&quot;width: 827.612px; height: 115px;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;\n                                                                                                                                                ',0,'2019-11-01 00:00:00','22,38',21),(232,1,'Docker安装PHP7.2.*-fpm运行在nginx服务上','','\n                                \n                                \n                                \n                                \n                                \n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;1.假设已经使用docker安装了nginx&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;2.docker pull php:7.2.9-fpm&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;在上一篇nginx的安装教程时我们已经创建了网站根目录 /docker-container/docker-nginx/www&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;（http://www.localliu.com/index/index/articledetail.html?article_id=225）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;下面我们来创建php镜像容器并启动&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;docker run -p 9000:9000 --name my-php -v /docker-container/docker-nginx/www:/var/www/html --privileged=true -d php:7.2.9-fpm&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;-p 9000:9000 &lt;/b&gt;： 宿主机的9000端口映射到容器的9000端口&lt;/div&gt;&lt;div&gt;&lt;b&gt;--name my-php &lt;/b&gt;： 给创建的php容器命名&lt;/div&gt;&lt;div&gt;&lt;b&gt;-d php:7.1.0-fpm&lt;/b&gt;&amp;nbsp; ： 后台运行php-fpm服务&lt;/div&gt;&lt;div&gt;&lt;b&gt;--privileged=true &lt;/b&gt;： 没有权限访问容器目录时，可以加上该参数&lt;/div&gt;&lt;div&gt;&lt;b&gt;-v /docker-container/docker-nginx/www:/var/www/html&lt;/b&gt; ： 映射网站根目录到php的容器目录(/var/www/html)中&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;\\upload\\article\\20191102\\0be5ff5efb476d7b3334b3a518273069.png&quot; data-filename=&quot;img&quot; style=&quot;width: 805.274px; height: 50.8px;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;#查看php镜像的ip地址&lt;/div&gt;&lt;pre&gt;docker inspect --format=\'{{.NetworkSettings.IPAddress}}\' my-php    // 172.17.0.3&lt;/pre&gt;&lt;p&gt;&lt;b&gt;最重要的一步：配置nginx文件，使得nginx支持php-fpm&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们在&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;/docker-container/docker-nginx/conf.d &lt;/span&gt;目录下新建www.dockertest.com.conf (之前nginx搭建说错了，conf.d/ 目录下不是必须要default.conf这个文件的，这个默认文件可以拿来参考或则做一个配置格式备份用)&lt;/p&gt;&lt;p&gt;1.我们先把conf.d/ 目录下的 default.conf 拷贝一份到&amp;nbsp; www.dockertest.com.conf&amp;nbsp;, 然后我们可以直接把default.conf 改名为 &lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;default.conf.bak&lt;/span&gt;作为备份用而不影响nginx的配置&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;span style=&quot;background-color: rgb(255, 255, 255); color: rgb(42, 100, 150); text-decoration-line: underline; outline-color: initial; outline-style: initial;&quot;&gt;www.dockertest.com.conf&lt;/span&gt;&amp;nbsp; &amp;nbsp;内容：&lt;/p&gt;&lt;pre&gt;server {&lt;br&gt;&amp;nbsp; &amp;nbsp; listen&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;80;&lt;br&gt;&amp;nbsp; &amp;nbsp; #server_name&amp;nbsp; localhost;&lt;br&gt;&amp;nbsp; &amp;nbsp; server_name&amp;nbsp; www.dockertest.com;   //域名&lt;br&gt;&amp;nbsp; &amp;nbsp; #charset koi8-r;&lt;br&gt;&amp;nbsp; &amp;nbsp; #access_log&amp;nbsp; /var/log/nginx/host.access.log&amp;nbsp; main;&lt;br&gt;&amp;nbsp; &amp;nbsp; location / {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; root&amp;nbsp; &amp;nbsp;/usr/share/nginx/html/test;  // 指定站点的网站根目录 ， 注意：/docker-container/docker-nginx/www 与 /usr/share/nginx/html 是一个挂载的关系，所以我们在 /docker-container/docker-nginx/www/ 下新建站点的test目录  这里也需要指定出来   &lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; index&amp;nbsp; index.html index.htm index.php;  // 默认站点通过域名访问时，显示的首页 可以调整顺序&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; #error_page&amp;nbsp; 404&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; /404.html;&lt;br&gt;&amp;nbsp; &amp;nbsp; # redirect server error pages to the static page /50x.html&lt;br&gt;&amp;nbsp; &amp;nbsp; #&lt;br&gt;&amp;nbsp; &amp;nbsp; error_page&amp;nbsp; &amp;nbsp;500 502 503 504&amp;nbsp; /50x.html;&lt;br&gt;&amp;nbsp; &amp;nbsp; location = /50x.html {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; root&amp;nbsp; &amp;nbsp;/usr/share/nginx/html/test;   // 这里也可以指定 http错误状态吗对应的错误页面   &lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; # proxy the PHP scripts to Apache listening on 127.0.0.1:80&lt;br&gt;&amp;nbsp; &amp;nbsp; #&lt;br&gt;&amp;nbsp; &amp;nbsp; #location ~ \\.php$ {&lt;br&gt;&amp;nbsp; &amp;nbsp; #&amp;nbsp; &amp;nbsp; proxy_pass&amp;nbsp; &amp;nbsp;http://127.0.0.1;&lt;br&gt;&amp;nbsp; &amp;nbsp; #}&lt;br&gt;&amp;nbsp; &amp;nbsp; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000&lt;br&gt;&amp;nbsp; &amp;nbsp; #&lt;br&gt;&amp;nbsp; &amp;nbsp; location ~ \\.php(.*)$ {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; root&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; /var/www/html/test; // 由于php-fpm的根目录 /var/www/html 和nginx的根目录/usr/share/nginx/html 挂载的都是同一个宿主机下的目录 /docker-container/docker-nginx/www ；这里也同样的也需要指定到站点test目录&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fastcgi_pass&amp;nbsp; &amp;nbsp;172.17.0.3:9000;   //   172.17.0.3 这个是容器php-fpm的IP地址；&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fastcgi_split_path_info&amp;nbsp; ^((?U).+\\.php)(/?.+)$;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fastcgi_param&amp;nbsp; SCRIPT_FILENAME&amp;nbsp; $document_root$fastcgi_script_name;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fastcgi_param&amp;nbsp; PATH_INFO&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; $fastcgi_path_info;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fastcgi_param&amp;nbsp; PATH_TRANSLATED&amp;nbsp; $document_root$fastcgi_path_info;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; include&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fastcgi_params;&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; # deny access to .htaccess files, if Apache\'s document root&lt;br&gt;&amp;nbsp; &amp;nbsp; # concurs with nginx\'s one&lt;br&gt;&amp;nbsp; &amp;nbsp; #&lt;br&gt;&amp;nbsp; &amp;nbsp; #location ~ /\\.ht {&lt;br&gt;&amp;nbsp; &amp;nbsp; #&amp;nbsp; &amp;nbsp; deny&amp;nbsp; all;&lt;br&gt;&amp;nbsp; &amp;nbsp; #}&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;配置完后记得重启nginx容器&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;我们在window的hosts中配置 域名映射到虚拟机的IP地址，然后就可以通过浏览器 使用域名&amp;nbsp;&lt;/span&gt;www.dockertest.com&amp;nbsp;访问了&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;配置多站点域名访问：&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;一样的步骤，可以把 www.dockertest.com.conf&amp;nbsp; 拷贝一份到 www.dockertest02.com.conf （注意修改一下 serve_name 和root 的指向）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;注意：如果通过上面的教程安装完nginx和php-fpm镜像容器后，还不能正常访问站点出现一些情况比如（可以访问php文件的页面，不能访问html文件的页面。）要是出现这种情况的话，可能是由于我们在网上复制粘贴了一些配置信息到*.conf中，可能导致了一些乱码或者格式错误。可以尝试把nginx镜像删除了，再从头下载下来，重新拷贝里面的配置文件进行配置&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;在容器中安装PHP扩展&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;pdo_mysql (TP5数据库连接驱动)&lt;/b&gt;&lt;/div&gt;&lt;pre&gt;docker-php-ext-install pdo_mysql&lt;/pre&gt;&lt;div&gt;&lt;b&gt;GD库&lt;/b&gt;&lt;/div&gt;&lt;div&gt;在容器中先下载下面的依赖包&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;&quot;&gt;apt-get update&lt;br&gt;apt-get install libpng libpng-devel&lt;/pre&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;（如果下载失败考虑更换apt源）&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;否则直接安装gd会报错&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;&quot;&gt;If configure fails try --with-webp-dir=&amp;lt;DIR&amp;gt;&lt;br&gt;If configure fails try --with-jpeg-dir=&amp;lt;DIR&amp;gt;&lt;br&gt;configure: error: png.h not found.&lt;/pre&gt;&lt;div style=&quot;font-weight: 700;&quot;&gt;最后在安装gd库&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;pre style=&quot;line-height: 1.42857;&quot;&gt;docker-php-ext-install gd&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;（需改php,ini来开启gd扩展）&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b style=&quot;&quot;&gt;在容器中修改php配置文件(&lt;/b&gt;创建的容器中是没有php.ini文件的，需要自己创建&lt;b style=&quot;&quot;&gt;)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;&quot;&gt;进入容器 在/usr/local/etc/php 目录下我们可以 &lt;/div&gt;&lt;pre style=&quot;&quot;&gt;cp php.ini-production&amp;nbsp; php.ini&lt;/pre&gt;&lt;div style=&quot;&quot;&gt;然后我们重启容器后，会发现之前phpinfo打印的信息中&amp;nbsp;Loaded Configuration File 表示已经加载了配置文件php.ini&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;table style=&quot;border: 0px; width: 934px; box-shadow: rgb(204, 204, 204) 1px 2px 3px; margin: 1em auto; font-family: sans-serif; background-color: rgb(255, 255, 255);&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;e&quot; style=&quot;border: 1px solid rgb(102, 102, 102); font-size: 12px; vertical-align: baseline; padding: 4px 5px; background-color: rgb(204, 204, 255); width: 300px; font-weight: bold;&quot;&gt;Configuration File (php.ini) Path&lt;/td&gt;&lt;td class=&quot;v&quot; style=&quot;border: 1px solid rgb(102, 102, 102); font-size: 12px; vertical-align: baseline; padding: 4px 5px; background-color: rgb(221, 221, 221); max-width: 300px; overflow-x: auto; overflow-wrap: break-word;&quot;&gt;/usr/local/etc/php&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;e&quot; style=&quot;border: 1px solid rgb(102, 102, 102); font-size: 12px; vertical-align: baseline; padding: 4px 5px; background-color: rgb(204, 204, 255); width: 300px; font-weight: bold;&quot;&gt;Loaded Configuration File&lt;/td&gt;&lt;td class=&quot;v&quot; style=&quot;border: 1px solid rgb(102, 102, 102); font-size: 12px; vertical-align: baseline; padding: 4px 5px; background-color: rgb(221, 221, 221); max-width: 300px; overflow-x: auto; overflow-wrap: break-word;&quot;&gt;/usr/local/etc/php/php.ini&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;然后修改配置文件时，就是修改php.ini文件（修改完配置文件记得重启容器）&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;注：项部署项目的时候可能在运行时出现没有权限的情况 ，&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;pre&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;在服务器上面。运行docker时，php目录会发生权限问题解决方法如下：&lt;br&gt;docker exec -it my-php /bin/bash #进入php容器&lt;br&gt;&amp;nbsp;&lt;br&gt;chown -R www-data:www-data /var/www/html&amp;nbsp; &amp;nbsp;#给定权限  &lt;/span&gt;php-fpm如果是官方镜像，php-fpm用户组应该是&lt;code style=&quot;font-family: &amp;quot;Source Code Pro&amp;quot;, Consolas, Menlo, Monaco, &amp;quot;Courier New&amp;quot;, monospace; font-size: 0.93em; padding: 2px 4px; color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); border-radius: 4px; white-space: normal;&quot;&gt;www-data&lt;/code&gt;&lt;span style=&quot;color: rgb(66, 66, 66);&quot;&gt;&lt;br&gt;&lt;br&gt;/var/www/html/ #是你代码存放的目录&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;nginx部署TP5时，可能出现只能访问首页其它页面出现404，需要修改一下www.xx.conf的配置&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;pre style=&quot;&quot;&gt;&amp;nbsp; location / {&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; root&amp;nbsp; &amp;nbsp;/usr/share/nginx/html/yxadmin/public;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; index&amp;nbsp; index.php&amp;nbsp; index.html index.htm ;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp; #添加下面两个判断条件&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if ( -f $request_filename){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; break;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if ( !-e $request_filename){&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; rewrite ^(.*)$ /index.php/$1 last;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; break;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;br&gt;&amp;nbsp; &amp;nbsp; }&lt;br&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;\n                                                                                                                                                                                                                                    ',0,'2018-06-02 00:00:00','35',42),(233,1,'使用docker安装Msql5.7.*','','\n                                \n                                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;1 拉取mysql镜像&lt;/b&gt;&lt;/p&gt;&lt;pre&gt;&amp;nbsp; docker pull mysql:5.7.26&lt;/pre&gt;&lt;p&gt;&lt;b&gt;2.创建用于挂载的目录&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在宿主机中比如：/docker-container/docker-mysql 目录下创建三个目录&lt;/p&gt;&lt;pre&gt;mkdir -p {conf.d,data}&lt;/pre&gt;&lt;p&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;目录解释：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;data :&lt;/span&gt; 该目录映射容器中的mysql数据目录&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;conf.d&lt;/span&gt;：该目录映射容器中的mysql配置文件（注意：该目录下所有文件必须以.cnf为后缀）&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;创建MySQL映射配置文件&lt;/span&gt;&lt;/p&gt;&lt;p&gt;MySQL(5.7.19)的默认配置文件是在容器中 /etc/mysql/my.cnf 文件。如果想要自定义配置，建议向 /docker-container/docker-mysql/conf.d 目录中创建 .cnf 文件。新建的文件可以任意起名，只要保证后缀名是 .cnf 即可。新建的文件中的配置项可以覆盖 /etc/mysql/my.cnf 中的配置项。&lt;/p&gt;&lt;p&gt;在 /docker-container/docker-mysql/conf.d/ 创建my.cnf ,my.cnf里的内容可以进入到容器/etc/mysql/my.cnf 拷贝一份&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（注：通过docker cp 容器ID：*****这样可能复制不了，所以进入容器后可以使用cat 然后手动复制）&lt;/p&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;3 使用镜像创建容器&lt;/b&gt;&lt;/p&gt;&lt;p&gt;(将容器中MySQL的3306端口映射到本地的3306端口，并设置登录密码为：123456（默认就是123456，需要后续进入MySQL后通过命令修改root登录密码）&lt;/p&gt;&lt;pre&gt;docker run --name mysql5.7 -p 3306:3306 -v /docker-container/docker-mysql/data:/var/lib/mysql -v /docker-container/docker-mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7.26&lt;/pre&gt;&lt;p&gt;&lt;b&gt;4 命令解析：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;--name：容器名&lt;/li&gt;&lt;li&gt;--p：映射宿主主机端口&lt;/li&gt;&lt;li&gt;-v：挂载宿主目录到容器目录&lt;/li&gt;&lt;li&gt;-e：设置环境变量，此处指定root密码&lt;/li&gt;&lt;li&gt;-d：后台运行容器&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;(&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;注：宿主机的防火墙需要开启3306端口&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;开启3306端口：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;添加3306端口&lt;/p&gt;&lt;pre&gt;firewall-cmd --zone=public --add-port=3306/tcp --permanent&lt;/pre&gt;&lt;p&gt;重启防火墙&lt;/p&gt;&lt;pre&gt;systemctl restart firewalld.service&lt;/pre&gt;&lt;p&gt;查看&lt;/p&gt;&lt;pre&gt;firewall-cmd --list-ports&amp;nbsp;&lt;/pre&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;进入容器需改root密码：&lt;/span&gt;&lt;/div&gt;&lt;pre&gt;docker exec -it my-mysql bash&lt;br&gt;mysql -uroot -p123456&lt;/pre&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;修改数据库访问密码(mysql5.7以后mysql.user表中没有了password字段，而是使用authentication_string来代替)&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;mysql&amp;gt; update mysql.user set authentication_string=password(\'root\') where user=\'root\' and Host = \'localhost\';&lt;br&gt;mysql&amp;gt; flush privileges;&lt;/pre&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;开启远程连接mysql&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;mysql&amp;gt; GRANT ALL PRIVILEGES&amp;nbsp; ON *.* TO \'root\'@\'%\'&amp;nbsp; IDENTIFIED BY \'root\' WITH GRANT OPTION;&amp;nbsp;&amp;nbsp;&lt;br&gt;mysql&amp;gt; flush privileges;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;\n                                                            &lt;/p&gt;                                                        ',0,'2018-06-02 00:00:00','35',17),(234,1,'解决Docker容器中不能用vim编辑文件1','','\n                                \n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;进入容器&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;更新来源：&lt;/div&gt;&lt;pre&gt;apt-get update&lt;/pre&gt;&lt;div&gt;安装vim&lt;/div&gt;&lt;pre&gt;apt-get install -y vim&lt;/pre&gt;&lt;p&gt;或者：&lt;/p&gt;&lt;pre&gt;apt-get update&amp;amp;&amp;amp; apt-get install -y vim&lt;/pre&gt;\n                                                                                                                    ',0,'2018-02-01 00:00:00','35',37),(235,1,'TP5.1.*使用PHPExcel','','&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先我们使用composer下载PHPExcel到TP5的项目目录下&lt;/p&gt;&lt;p&gt;&lt;strong&gt;下载&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1.步骤：进入到TP5的项目目录，通过composer require phpoffice/phpexcel （由于phpexcel 不在维护，推荐使用phpspreadsheet，百度具体的使用方法）&lt;/p&gt;&lt;p&gt;2.下载完后我们可以在TP5项目目录下的vendor下看到phpoffice目录&lt;/p&gt;&lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1.通过composer下载phpexcel 后，我们在控制器中使用phpexcel&amp;nbsp;&lt;/p&gt;&lt;p&gt;代码：&lt;/p&gt;&lt;p&gt;&lt;span data-cke-copybin-start=&quot;1&quot;&gt;​&lt;/span&gt;&lt;/p&gt;&lt;div tabindex=&quot;-1&quot; contenteditable=&quot;false&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; class=&quot;cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_wrapper_has cke_widget_focused cke_widget_selected&quot; data-cke-display-name=&quot;代码段&quot; data-cke-widget-id=&quot;0&quot; role=&quot;region&quot; aria-label=&quot;代码段 小部件&quot;&gt;&lt;pre class=&quot;has cke_widget_element&quot; data-cke-widget-data=&quot;{&amp;amp;quot;lang&amp;amp;quot;:&amp;amp;quot;php&amp;amp;quot;,&amp;amp;quot;code&amp;amp;quot;:&amp;amp;quot;namespace app\\\\admin\\\\controller;\\n// 使用composer下载PHPExcel到vendor目录下不需要通过use引入\\n// use Classes\\\\PHPExcel_IOFactory; \\n// use PHPExcel;\\n// use PHPExcel_IOFactory;\\n\\nclass Test\\n{\\n  \\n    /**\\n     * des: 读取Excel文件数据\\n     */\\n    public function readExcelFileByPath($filePath){\\n\\n        // 文件地址\\n        $filename = $filePath;\\n           \\n        // 获取Excel文件的后缀名\\n        $extension = strtolower( pathinfo($filename, PATHINFO_EXTENSION) );\\n        \\n        //根据后缀名实例化对象\\n        if ($extension ==\'xlsx\') {\\n            $objReader = new \\\\PHPExcel_Reader_Excel2007();\\n            $objExcel = $objReader -&amp;amp;gt;load($filename);\\n\\n        } else if ($extension ==\'xls\') {\\n\\n            $objReader = new \\\\PHPExcel_Reader_Excel5();\\n            $objExcel = $objReader-&amp;amp;gt;load($filename);\\n        }\\n\\n        $excel_array=$objExcel-&amp;amp;gt;getsheet(0)-&amp;amp;gt;toArray();   //转换为数组格式\\n\\n        return $excel_array; // 返回的是一个二维数组\\n    }\\n\\n    /**\\n     * des : 导出数据到Excel并下载文件\\n     */\\n    public function downloadExcel() {\\n\\n        // 根据需要创建不同的对象\\n        $objExcel = new \\\\PHPExcel();\\n       \\n        $objWriter = \\\\PHPExcel_IOFactory::createWriter($objExcel, \'Excel2007\');\\n\\n        $objExcel-&amp;amp;gt;setActiveSheetIndex(0);\\n\\n        $objActSheet = $objExcel-&amp;amp;gt;getActiveSheet();// 获取sheet\\n\\n        $setColor = new \\\\PHPExcel_Style_Color(); //设置颜色的对象\\n\\n        $letter =array(\\&amp;amp;quot;A\\&amp;amp;quot;,\\&amp;amp;quot;B\\&amp;amp;quot;,\\&amp;amp;quot;C\\&amp;amp;quot;); \\n        //设置每列宽度\\n        $objActSheet-&amp;amp;gt;getColumnDimension(\'A\')-&amp;amp;gt;setWidth(15); // 姓名\\n        $objActSheet-&amp;amp;gt;getColumnDimension(\'B\')-&amp;amp;gt;setWidth(50); //应聘岗位\\n        $objActSheet-&amp;amp;gt;getColumnDimension(\'C\')-&amp;amp;gt;setWidth(20); //需求公司  \\n        \\n        //列名称 \\n        $arrHeader = array(\'姓名\',\'应聘岗位\',\'需求公司\');\\n\\n        $lenth =  count($arrHeader);\\n        \\n        /**\\n        * 设置备注信息样式\\n        */\\n        //有时候我们需要在第一行备注信息，所以需要合并一下单元格\\n        $objActSheet-&amp;amp;gt;mergeCells(\'A1:\'.$letter[count($letter)-1].\'1\');//合并单元格\\n        \\n        // 备注信息内容\\n        $objActSheet-&amp;amp;gt;setCellValue(\\&amp;amp;quot;A1\\&amp;amp;quot;,\\&amp;amp;quot;备注：1.红色字段为必填项；2.字段为下拉选项，请勿修改。（请勿改变单元格的顺序以及增删单元格）\\&amp;amp;quot;);\\n\\n        $objActSheet-&amp;amp;gt;getRowDimension(1)-&amp;amp;gt;setRowHeight(40); //设置高度\\n        $objActSheet-&amp;amp;gt;getStyle(\'A1\')-&amp;amp;gt;getAlignment()-&amp;amp;gt;setHorizontal(\\\\PHPExcel_Style_Alignment::HORIZONTAL_LEFT);//设置文字居左（HORIZONTAL_LEFT，默认值）中（HORIZONTAL_CENTER）右（HORIZONTAL_RIGHT）\\n        \\n        $objActSheet-&amp;amp;gt;getStyle(\'A1\')-&amp;amp;gt;getAlignment()-&amp;amp;gt;setVertical(\\\\PHPExcel_Style_Alignment::VERTICAL_CENTER);//垂直居中\\n\\n        $objActSheet-&amp;amp;gt;getStyle(\\&amp;amp;quot;A1\\&amp;amp;quot;)-&amp;amp;gt;getFont()-&amp;amp;gt;setColor($setColor-&amp;amp;gt;setRGB(\'FF0000\'));// 设置文字颜色，这个颜色可以通过浏览器样式调色器获取，只要把前面的“#”去掉就行\\n        \\n        /**\\n        * 设置表头信息样式\\n        */\\n        for($i = 0;$i &amp;amp;lt; $lenth ;$i++) {\\n            $objActSheet-&amp;amp;gt;setCellValue(\\&amp;amp;quot;$letter[$i]2\\&amp;amp;quot;,\\&amp;amp;quot;$arrHeader[$i]\\&amp;amp;quot;); // 设置列字段值（由于第一列是备注信息占用了，所以是从第二列开始的）\\n\\n            $objActSheet-&amp;amp;gt;getStyle(\\&amp;amp;quot;$letter[$i]2\\&amp;amp;quot;)-&amp;amp;gt;getFont()-&amp;amp;gt;setBold(true);//设置是否加粗\\n\\n            $objActSheet-&amp;amp;gt;getStyle(\\&amp;amp;quot;$letter[$i]2\\&amp;amp;quot;)-&amp;amp;gt;getAlignment()-&amp;amp;gt;setHorizontal(\\\\PHPExcel_Style_Alignment::HORIZONTAL_CENTER); //文字居中\\n\\n            $objActSheet-&amp;amp;gt;getRowDimension($i+2)-&amp;amp;gt;setRowHeight(15); //行高\\n\\n            $objActSheet-&amp;amp;gt;getStyle(\\&amp;amp;quot;$letter[$i]2\\&amp;amp;quot;)-&amp;amp;gt;getFont()-&amp;amp;gt;setColor($setColor-&amp;amp;gt;setRGB(\'FF0000\'));// 设置表头文字颜色\\n\\n            $objActSheet-&amp;amp;gt;getStyle(\\&amp;amp;quot;$letter[$i]2\\&amp;amp;quot;)-&amp;amp;gt;getFill()-&amp;amp;gt;setFillType(\\\\PHPExcel_Style_Fill::FILL_SOLID);//设置填充背景类型\\n            $objActSheet-&amp;amp;gt;getStyle(\\&amp;amp;quot;$letter[$i]2\\&amp;amp;quot;)-&amp;amp;gt;getFill()-&amp;amp;gt;getStartColor()-&amp;amp;gt;setARGB(\'aad1da\');//设置填充背景颜色\\n\\n            //由于填充背景颜色，边框线消失了，所以重新设置边框\\n            $objActSheet-&amp;amp;gt;getStyle(\\&amp;amp;quot;A2:\\&amp;amp;quot;.$letter[count($letter)-1].\'2\')-&amp;amp;gt;applyFromArray(\\n                array(\\n                    \'borders\'=&amp;amp;gt;array(\\n                        \'allborders\'=&amp;amp;gt;array(\\n                            \'style\'=&amp;amp;gt; \\\\PHPExcel_Style_Border::BORDER_THIN\\n                        )\\n                    )\\n                )\\n            );//设置边框\\n\\n             //设置下拉选项（有时候我们导出的excel表格需要在某一列实现下拉选项功能）\\n            if($i == 1) {\\n                $objValidation =  $objActSheet-&amp;amp;gt;getCell(\\&amp;amp;quot;$letter[$i]3\\&amp;amp;quot;)-&amp;amp;gt;getDataValidation();// 从第几列开始\\n                $objValidation-&amp;amp;gt;setType(\\\\PHPExcel_Cell_DataValidation::TYPE_LIST )\\n                -&amp;amp;gt;setErrorStyle(\\\\PHPExcel_Cell_DataValidation::STYLE_INFORMATION )\\n                -&amp;amp;gt;setAllowBlank(false)\\n                -&amp;amp;gt;setShowInputMessage(true)\\n                -&amp;amp;gt;setShowErrorMessage(true)\\n                -&amp;amp;gt;setShowDropDown(true)\\n                -&amp;amp;gt;setErrorTitle(\'输入的值有误\')\\n                -&amp;amp;gt;setError(\'您输入的值不在下拉框列表内.\')\\n                -&amp;amp;gt;setPromptTitle(\'\')\\n                -&amp;amp;gt;setPrompt(\'\')\\n                -&amp;amp;gt;setFormula1(\'\\&amp;amp;quot;\' . $sex . \'\\&amp;amp;quot;\'); // 这个$sex值就是下拉选项的数据（格式：$sex = \\&amp;amp;quot;男,女\\&amp;amp;quot;）。下拉选项的值是一个以英文逗号隔开的字符串\\n\\n                $objActSheet-&amp;amp;gt;setDataValidation(\\&amp;amp;quot;$letter[$i]:$letter[$i]\\&amp;amp;quot;,$objValidation); // 设置整列为下拉（如果不这么设置只有一行有下拉，其它行的没有下拉）\\n            }\\n        }\\n\\n        /**\\n        * 这里可以导出我们需要的数据\\n        */\\n        $exportData = //从数据库取出的二维数据数据\\n        $index =3;  // 由于第一行和第二行都已被占用，所以我们导出的数据是从第三行开始的\\n        foreach ($exportData as $k =&amp;amp;gt; $v) {\\n            $objActSheet-&amp;amp;gt;setCellValue(\\&amp;amp;quot;A$index\\&amp;amp;quot;,$v[\'name\']);\\n&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; $objActSheet-&amp;amp;gt;setCellValue(\\&amp;amp;quot;B$index\\&amp;amp;quot;, $v[\'job\']);\\n&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; $objActSheet-&amp;amp;gt;setCellValue(\\&amp;amp;quot;C$index\\&amp;amp;quot;, $v[\'company\']);\\n            \\n           $index++; // 每次循环完就增加一行\\n        }\\n        \\n        // 设置输出的header头部信息\\n         $outfile = \\&amp;amp;quot;招聘数据模板.xlsx\\&amp;amp;quot;; // 文件名（由于使用的是Excel2007，所以后缀名为:xlsx）\\n         ob_end_clean(); // 避免出现乱码\\n         header(\\&amp;amp;quot;Content-Type: application/force-download\\&amp;amp;quot;);\\n         header(\\&amp;amp;quot;Content-Type: application/octet-stream\\&amp;amp;quot;);\\n         header(\\&amp;amp;quot;Content-Type: application/download\\&amp;amp;quot;);\\n         header(\'Content-Disposition:inline;filename=\\&amp;amp;quot;\'.$outfile.\'\\&amp;amp;quot;\');\\n         header(\\&amp;amp;quot;Content-Transfer-Encoding: binary\\&amp;amp;quot;);\\n         header(\\&amp;amp;quot;Cache-Control: must-revalidate, post-check=0, pre-check=0\\&amp;amp;quot;);\\n         header(\\&amp;amp;quot;Pragma: no-cache\\&amp;amp;quot;);\\n         $objWriter-&amp;amp;gt;save(\'php://output\');\\n    }\\n \\n}&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;codeSnippet&quot;&gt;&lt;code class=&quot;language-php hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;app&lt;/span&gt;\\&lt;span class=&quot;hljs-title&quot;&gt;admin&lt;/span&gt;\\&lt;span class=&quot;hljs-title&quot;&gt;controller&lt;/span&gt;;\n&lt;span class=&quot;hljs-comment&quot;&gt;// 使用composer下载PHPExcel到vendor目录下不需要通过use引入&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// use Classes\\PHPExcel_IOFactory; &lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// use PHPExcel;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// use PHPExcel_IOFactory;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt;\n&lt;/span&gt;{\n  \n    &lt;span class=&quot;hljs-comment&quot;&gt;/**\n     * des: 读取Excel文件数据\n     */&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;readExcelFileByPath&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;($filePath)&lt;/span&gt;&lt;/span&gt;{\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;// 文件地址&lt;/span&gt;\n        $filename = $filePath;\n           \n        &lt;span class=&quot;hljs-comment&quot;&gt;// 获取Excel文件的后缀名&lt;/span&gt;\n        $extension = strtolower( pathinfo($filename, PATHINFO_EXTENSION) );\n        \n        &lt;span class=&quot;hljs-comment&quot;&gt;//根据后缀名实例化对象&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ($extension ==&lt;span class=&quot;hljs-string&quot;&gt;\'xlsx\'&lt;/span&gt;) {\n            $objReader = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; \\PHPExcel_Reader_Excel2007();\n            $objExcel = $objReader -&amp;gt;load($filename);\n\n        } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ($extension ==&lt;span class=&quot;hljs-string&quot;&gt;\'xls\'&lt;/span&gt;) {\n\n            $objReader = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; \\PHPExcel_Reader_Excel5();\n            $objExcel = $objReader-&amp;gt;load($filename);\n        }\n\n        $excel_array=$objExcel-&amp;gt;getsheet(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)-&amp;gt;toArray();   &lt;span class=&quot;hljs-comment&quot;&gt;//转换为数组格式&lt;/span&gt;\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; $excel_array; &lt;span class=&quot;hljs-comment&quot;&gt;// 返回的是一个二维数组&lt;/span&gt;\n    }\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;/**\n     * des : 导出数据到Excel并下载文件\n     */&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;downloadExcel&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;// 根据需要创建不同的对象&lt;/span&gt;\n        $objExcel = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; \\PHPExcel();\n       \n        $objWriter = \\PHPExcel_IOFactory::createWriter($objExcel, &lt;span class=&quot;hljs-string&quot;&gt;\'Excel2007\'&lt;/span&gt;);\n\n        $objExcel-&amp;gt;setActiveSheetIndex(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n\n        $objActSheet = $objExcel-&amp;gt;getActiveSheet();&lt;span class=&quot;hljs-comment&quot;&gt;// 获取sheet&lt;/span&gt;\n\n        $setColor = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; \\PHPExcel_Style_Color(); &lt;span class=&quot;hljs-comment&quot;&gt;//设置颜色的对象&lt;/span&gt;\n\n        $letter =&lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;A&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;B&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;C&quot;&lt;/span&gt;); \n        &lt;span class=&quot;hljs-comment&quot;&gt;//设置每列宽度&lt;/span&gt;\n        $objActSheet-&amp;gt;getColumnDimension(&lt;span class=&quot;hljs-string&quot;&gt;\'A\'&lt;/span&gt;)-&amp;gt;setWidth(&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// 姓名&lt;/span&gt;\n        $objActSheet-&amp;gt;getColumnDimension(&lt;span class=&quot;hljs-string&quot;&gt;\'B\'&lt;/span&gt;)-&amp;gt;setWidth(&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;//应聘岗位&lt;/span&gt;\n        $objActSheet-&amp;gt;getColumnDimension(&lt;span class=&quot;hljs-string&quot;&gt;\'C\'&lt;/span&gt;)-&amp;gt;setWidth(&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;//需求公司  &lt;/span&gt;\n        \n        &lt;span class=&quot;hljs-comment&quot;&gt;//列名称 &lt;/span&gt;\n        $arrHeader = &lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;\'姓名\'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;\'应聘岗位\'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;\'需求公司\'&lt;/span&gt;);\n\n        $lenth =  count($arrHeader);\n        \n        &lt;span class=&quot;hljs-comment&quot;&gt;/**\n        * 设置备注信息样式\n        */&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;//有时候我们需要在第一行备注信息，所以需要合并一下单元格&lt;/span&gt;\n        $objActSheet-&amp;gt;mergeCells(&lt;span class=&quot;hljs-string&quot;&gt;\'A1:\'&lt;/span&gt;.$letter[count($letter)&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;].&lt;span class=&quot;hljs-string&quot;&gt;\'1\'&lt;/span&gt;);&lt;span class=&quot;hljs-comment&quot;&gt;//合并单元格&lt;/span&gt;\n        \n        &lt;span class=&quot;hljs-comment&quot;&gt;// 备注信息内容&lt;/span&gt;\n        $objActSheet-&amp;gt;setCellValue(&lt;span class=&quot;hljs-string&quot;&gt;&quot;A1&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;备注：1.红色字段为必填项；2.字段为下拉选项，请勿修改。（请勿改变单元格的顺序以及增删单元格）&quot;&lt;/span&gt;);\n\n        $objActSheet-&amp;gt;getRowDimension(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)-&amp;gt;setRowHeight(&lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;//设置高度&lt;/span&gt;\n        $objActSheet-&amp;gt;getStyle(&lt;span class=&quot;hljs-string&quot;&gt;\'A1\'&lt;/span&gt;)-&amp;gt;getAlignment()-&amp;gt;setHorizontal(\\PHPExcel_Style_Alignment::HORIZONTAL_LEFT);&lt;span class=&quot;hljs-comment&quot;&gt;//设置文字居左（HORIZONTAL_LEFT，默认值）中（HORIZONTAL_CENTER）右（HORIZONTAL_RIGHT）&lt;/span&gt;\n        \n        $objActSheet-&amp;gt;getStyle(&lt;span class=&quot;hljs-string&quot;&gt;\'A1\'&lt;/span&gt;)-&amp;gt;getAlignment()-&amp;gt;setVertical(\\PHPExcel_Style_Alignment::VERTICAL_CENTER);&lt;span class=&quot;hljs-comment&quot;&gt;//垂直居中&lt;/span&gt;\n\n        $objActSheet-&amp;gt;getStyle(&lt;span class=&quot;hljs-string&quot;&gt;&quot;A1&quot;&lt;/span&gt;)-&amp;gt;getFont()-&amp;gt;setColor($setColor-&amp;gt;setRGB(&lt;span class=&quot;hljs-string&quot;&gt;\'FF0000\'&lt;/span&gt;));&lt;span class=&quot;hljs-comment&quot;&gt;// 设置文字颜色，这个颜色可以通过浏览器样式调色器获取，只要把前面的“#”去掉就行&lt;/span&gt;\n        \n        &lt;span class=&quot;hljs-comment&quot;&gt;/**\n        * 设置表头信息样式\n        */&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;($i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;$i &amp;lt; $lenth ;$i++) {\n            $objActSheet-&amp;gt;setCellValue(&lt;span class=&quot;hljs-string&quot;&gt;&quot;$letter[$i]2&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;$arrHeader[$i]&quot;&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// 设置列字段值（由于第一列是备注信息占用了，所以是从第二列开始的）&lt;/span&gt;\n\n            $objActSheet-&amp;gt;getStyle(&lt;span class=&quot;hljs-string&quot;&gt;&quot;$letter[$i]2&quot;&lt;/span&gt;)-&amp;gt;getFont()-&amp;gt;setBold(&lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;);&lt;span class=&quot;hljs-comment&quot;&gt;//设置是否加粗&lt;/span&gt;\n\n            $objActSheet-&amp;gt;getStyle(&lt;span class=&quot;hljs-string&quot;&gt;&quot;$letter[$i]2&quot;&lt;/span&gt;)-&amp;gt;getAlignment()-&amp;gt;setHorizontal(\\PHPExcel_Style_Alignment::HORIZONTAL_CENTER); &lt;span class=&quot;hljs-comment&quot;&gt;//文字居中&lt;/span&gt;\n\n            $objActSheet-&amp;gt;getRowDimension($i+&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)-&amp;gt;setRowHeight(&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;//行高&lt;/span&gt;\n\n            $objActSheet-&amp;gt;getStyle(&lt;span class=&quot;hljs-string&quot;&gt;&quot;$letter[$i]2&quot;&lt;/span&gt;)-&amp;gt;getFont()-&amp;gt;setColor($setColor-&amp;gt;setRGB(&lt;span class=&quot;hljs-string&quot;&gt;\'FF0000\'&lt;/span&gt;));&lt;span class=&quot;hljs-comment&quot;&gt;// 设置表头文字颜色&lt;/span&gt;\n\n            $objActSheet-&amp;gt;getStyle(&lt;span class=&quot;hljs-string&quot;&gt;&quot;$letter[$i]2&quot;&lt;/span&gt;)-&amp;gt;getFill()-&amp;gt;setFillType(\\PHPExcel_Style_Fill::FILL_SOLID);&lt;span class=&quot;hljs-comment&quot;&gt;//设置填充背景类型&lt;/span&gt;\n            $objActSheet-&amp;gt;getStyle(&lt;span class=&quot;hljs-string&quot;&gt;&quot;$letter[$i]2&quot;&lt;/span&gt;)-&amp;gt;getFill()-&amp;gt;getStartColor()-&amp;gt;setARGB(&lt;span class=&quot;hljs-string&quot;&gt;\'aad1da\'&lt;/span&gt;);&lt;span class=&quot;hljs-comment&quot;&gt;//设置填充背景颜色&lt;/span&gt;\n\n            &lt;span class=&quot;hljs-comment&quot;&gt;//由于填充背景颜色，边框线消失了，所以重新设置边框&lt;/span&gt;\n            $objActSheet-&amp;gt;getStyle(&lt;span class=&quot;hljs-string&quot;&gt;&quot;A2:&quot;&lt;/span&gt;.$letter[count($letter)&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;].&lt;span class=&quot;hljs-string&quot;&gt;\'2\'&lt;/span&gt;)-&amp;gt;applyFromArray(\n                &lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;(\n                    &lt;span class=&quot;hljs-string&quot;&gt;\'borders\'&lt;/span&gt;=&amp;gt;&lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;(\n                        &lt;span class=&quot;hljs-string&quot;&gt;\'allborders\'&lt;/span&gt;=&amp;gt;&lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;(\n                            &lt;span class=&quot;hljs-string&quot;&gt;\'style\'&lt;/span&gt;=&amp;gt; \\PHPExcel_Style_Border::BORDER_THIN\n                        )\n                    )\n                )\n            );&lt;span class=&quot;hljs-comment&quot;&gt;//设置边框&lt;/span&gt;\n\n             &lt;span class=&quot;hljs-comment&quot;&gt;//设置下拉选项（有时候我们导出的excel表格需要在某一列实现下拉选项功能）&lt;/span&gt;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;($i == &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) {\n                $objValidation =  $objActSheet-&amp;gt;getCell(&lt;span class=&quot;hljs-string&quot;&gt;&quot;$letter[$i]3&quot;&lt;/span&gt;)-&amp;gt;getDataValidation();&lt;span class=&quot;hljs-comment&quot;&gt;// 从第几列开始&lt;/span&gt;\n                $objValidation-&amp;gt;setType(\\PHPExcel_Cell_DataValidation::TYPE_LIST )\n                -&amp;gt;setErrorStyle(\\PHPExcel_Cell_DataValidation::STYLE_INFORMATION )\n                -&amp;gt;setAllowBlank(&lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;)\n                -&amp;gt;setShowInputMessage(&lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;)\n                -&amp;gt;setShowErrorMessage(&lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;)\n                -&amp;gt;setShowDropDown(&lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;)\n                -&amp;gt;setErrorTitle(&lt;span class=&quot;hljs-string&quot;&gt;\'输入的值有误\'&lt;/span&gt;)\n                -&amp;gt;setError(&lt;span class=&quot;hljs-string&quot;&gt;\'您输入的值不在下拉框列表内.\'&lt;/span&gt;)\n                -&amp;gt;setPromptTitle(&lt;span class=&quot;hljs-string&quot;&gt;\'\'&lt;/span&gt;)\n                -&amp;gt;setPrompt(&lt;span class=&quot;hljs-string&quot;&gt;\'\'&lt;/span&gt;)\n                -&amp;gt;setFormula1(&lt;span class=&quot;hljs-string&quot;&gt;\'&quot;\'&lt;/span&gt; . $sex . &lt;span class=&quot;hljs-string&quot;&gt;\'&quot;\'&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// 这个$sex值就是下拉选项的数据（格式：$sex = &quot;男,女&quot;）。下拉选项的值是一个以英文逗号隔开的字符串&lt;/span&gt;\n\n                $objActSheet-&amp;gt;setDataValidation(&lt;span class=&quot;hljs-string&quot;&gt;&quot;$letter[$i]:$letter[$i]&quot;&lt;/span&gt;,$objValidation); &lt;span class=&quot;hljs-comment&quot;&gt;// 设置整列为下拉（如果不这么设置只有一行有下拉，其它行的没有下拉）&lt;/span&gt;\n            }\n        }\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;/**\n        * 这里可以导出我们需要的数据\n        */&lt;/span&gt;\n        $exportData = &lt;span class=&quot;hljs-comment&quot;&gt;//从数据库取出的二维数据数据&lt;/span&gt;\n        $index =&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;// 由于第一行和第二行都已被占用，所以我们导出的数据是从第三行开始的&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; ($exportData &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; $k =&amp;gt; $v) {\n            $objActSheet-&amp;gt;setCellValue(&lt;span class=&quot;hljs-string&quot;&gt;&quot;A$index&quot;&lt;/span&gt;,$v[&lt;span class=&quot;hljs-string&quot;&gt;\'name\'&lt;/span&gt;]);\n&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; $objActSheet-&amp;gt;setCellValue(&lt;span class=&quot;hljs-string&quot;&gt;&quot;B$index&quot;&lt;/span&gt;, $v[&lt;span class=&quot;hljs-string&quot;&gt;\'job\'&lt;/span&gt;]);\n&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; $objActSheet-&amp;gt;setCellValue(&lt;span class=&quot;hljs-string&quot;&gt;&quot;C$index&quot;&lt;/span&gt;, $v[&lt;span class=&quot;hljs-string&quot;&gt;\'company\'&lt;/span&gt;]);\n            \n           $index++; &lt;span class=&quot;hljs-comment&quot;&gt;// 每次循环完就增加一行&lt;/span&gt;\n        }\n        \n        &lt;span class=&quot;hljs-comment&quot;&gt;// 设置输出的header头部信息&lt;/span&gt;\n         $outfile = &lt;span class=&quot;hljs-string&quot;&gt;&quot;招聘数据模板.xlsx&quot;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// 文件名（由于使用的是Excel2007，所以后缀名为:xlsx）&lt;/span&gt;\n         ob_end_clean(); &lt;span class=&quot;hljs-comment&quot;&gt;// 避免出现乱码&lt;/span&gt;\n         header(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Content-Type: application/force-download&quot;&lt;/span&gt;);\n         header(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Content-Type: application/octet-stream&quot;&lt;/span&gt;);\n         header(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Content-Type: application/download&quot;&lt;/span&gt;);\n         header(&lt;span class=&quot;hljs-string&quot;&gt;\'Content-Disposition:inline;filename=&quot;\'&lt;/span&gt;.$outfile.&lt;span class=&quot;hljs-string&quot;&gt;\'&quot;\'&lt;/span&gt;);\n         header(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Content-Transfer-Encoding: binary&quot;&lt;/span&gt;);\n         header(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Cache-Control: must-revalidate, post-check=0, pre-check=0&quot;&lt;/span&gt;);\n         header(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Pragma: no-cache&quot;&lt;/span&gt;);\n         $objWriter-&amp;gt;save(&lt;span class=&quot;hljs-string&quot;&gt;\'php://output\'&lt;/span&gt;);\n    }\n \n}&lt;/code&gt;&lt;/pre&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot; style=&quot;background: url(&amp;quot;https://csdnimg.cn/release/blog_editor_html/release1.5.8/ckeditor/plugins/widget/images/handle.png&amp;quot;) rgba(220, 220, 220, 0.5); top: -15px; left: 0px; display: block;&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; data-cke-widget-drag-handler=&quot;1&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; width=&quot;15&quot; title=&quot;点击并拖拽以移动&quot; height=&quot;15&quot; role=&quot;presentation&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;p&gt;&lt;span data-cke-copybin-end=&quot;1&quot;&gt;​&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;\n                                                            &lt;/p&gt;',0,'2018-01-01 00:00:00','23',22),(236,1,'Docker 之 Docker Compose安装','','\n                                \n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Docker-Compose 是 Docker 的一种编排服务，是一个用于在 Docker 上定义并运行复杂应用的工具，可以让用户在集群中部署分布式应用。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;通过 Docker-Compose 用户可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;比如说我们有一个web项目，需要用到nginx，mysql,redis等等这些服务，我们可以通过配置文件，定义这些容器，然后使用Docker-Compose来进行统一的安装和管理这些服务。而不需要单独的一个一个服务的安装&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;安装方式：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;（1）使用curl 从github上拉取二进制文件（由于一些原因，下载实在太慢了）&lt;/b&gt;&lt;/div&gt;&lt;div&gt;1.从github上下载安装二进制文件&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.设置权限&lt;/div&gt;&lt;pre&gt;chmod +x /usr/local/bin/docker-compose&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b style=&quot;color: rgb(255, 0, 0);&quot;&gt;3.卸载方&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;rm /usr/local/bin/docker-compose&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;（2）使用pip安装docker-compose&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;#安装pip&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;yum -y install epel-release&lt;br&gt;yum -y install python-pip&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;#确认版本&lt;/div&gt;&lt;pre&gt;pip --version&lt;/pre&gt;&lt;div&gt;#更新pip&lt;/div&gt;&lt;pre&gt;pip install --upgrade pip&lt;/pre&gt;&lt;div&gt;#安装docker-compose&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;pip install docker-compose&lt;/pre&gt;&lt;p&gt;（&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;注意：&lt;/span&gt;由于pip安装模块默认是访问国外的镜像源地址，所以需要改成国内的，要不然会报&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp;错误一.：&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;ReadTimeoutError: HTTPSConnectionPool(host=\'pypi.python.org\', port=443): Read timed out.&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;把源换为清华的镜像站&lt;/p&gt;&lt;pre&gt;&amp;nbsp; pip install --index https://mirrors.ustc.edu.cn/pypi/web/simple/ virtualenv&amp;nbsp;&lt;/pre&gt;&lt;p&gt;错误二：&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;ERROR: Cannot uninstall \'requests\'. It is a distutils installed project and thus we cannot accuratel&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;pre&gt;&amp;nbsp; pip install --ignore-installed requests&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;）&lt;/p&gt;&lt;div&gt;#查看版本&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;docker-compose version&lt;/pre&gt;&lt;p&gt;#查看通过pip安装的docker-compose所在的路径地址&lt;/p&gt;&lt;pre&gt;[root@localhost /]#find / -name docker-compose&lt;br&gt;/usr/bin/docker-compose&lt;br&gt;&lt;/pre&gt;&lt;div&gt;&lt;div&gt;&lt;b style=&quot;color: rgb(255, 0, 0);&quot;&gt;#卸载&lt;/b&gt;&lt;/div&gt;&lt;pre&gt;pip uninstall docker-compose&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;\n                                                                                                                    ',0,'2018-07-02 00:00:00','35',55),(237,1,'docker-compose搭建nginx+php+mysql环境','','\n                                \n                                \n                                \n                                &lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;注意：确保你已经安装了Docker和Docker-Compose&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;使用docker-compos.yml来管理我们所需要的容器服务&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;准备工作，我们首先创建一个目录 如：docker-compose-lnmp&lt;/div&gt;&lt;div&gt;目录结构为：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;|-- docker-compose.yml\n|-- nginx\n|   |-- conf.d\n|   |-- logs\n|   `-- nginx.conf\n|-- php\n|  `-- Dockerfile\n|   |-- php-fpm.d\n|   `-- www.conf\n|   `-- php.ini\n|-- mysql\n|   `-- data\n|-- www\n    `-- index.html&lt;br&gt;&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;部署nginx&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;vi docker-compose.yml&lt;/pre&gt;&lt;div&gt;配置信息：&lt;/div&gt;&lt;pre&gt;version: \'3.0\'&lt;br&gt;services:&lt;br&gt;&amp;nbsp; nginx:&lt;br&gt;&amp;nbsp; &amp;nbsp; restart: always&lt;br&gt;&amp;nbsp; &amp;nbsp; image: nginx:latest&lt;br&gt;&amp;nbsp; &amp;nbsp; ports:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - 80:80&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - 443:443&lt;br&gt;&amp;nbsp; &amp;nbsp; volumes:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - ./nginx/conf.d:/etc/nginx/conf.d:ro&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - ./nginx/logs:/var/log/nginx:rw&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - ./www:/usr/share/nginx/html:rw&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - /etc/letsencrypt:/etc/letsencrypt&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;参数解释：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;version：&lt;/b&gt;指定 compose 文件的版本&lt;/div&gt;&lt;div&gt;ompose和Docker兼容性：Compose 文件格式有3个版本,分别为1, 2.x 和 3.x；目前主流的为 3.x 其支持 docker 1.13.0 及其以上的版本&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;service：&lt;/b&gt;就是要定义的docker容器&lt;/div&gt;&lt;div&gt;&lt;b&gt;nginx:&lt;/b&gt;容器的名称&lt;/div&gt;&lt;div&gt;&lt;b&gt;restart：&lt;/b&gt;设置为always，表明此容器应该在停止的情况下总是重启，比如，服务器启动时，这个容器就跟着启动，不用手动启动，服务器启动之后，进入到docker-compose.yml文件路径下，执行docker-compose ps可以看到，该容器正在运行。&lt;/div&gt;&lt;div&gt;&lt;b&gt;image：&lt;/b&gt;这个是需要依赖的容器，也就是nginx软件，可以到docker官方镜像上找到最新版的镜像。&lt;/div&gt;&lt;div&gt;&lt;div&gt;例如image格式可以是：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;image: redis&lt;br&gt;image: ubuntu:14.04&lt;br&gt;image: tutum/influxdb&lt;br&gt;image: example-registry.com:4000/postgresql&lt;br&gt;image: a4bc65fd&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;ports：&lt;/b&gt;这个是容器自己运行的端口号和需要暴露的端口号。比如： - 8080:80，表示容器内运行着的端口是80，把端口暴露给宿主机的8080端口，从外面访问的是8080端口，就能自动映射到80端口上。&lt;/div&gt;&lt;div&gt;&lt;b&gt;volumes:&lt;/b&gt;这个是数据卷。表示数据、配置文件等存放的位置。（- . 这个表示docker-compose.yml当前目录位置开始创建这个文件）&lt;/div&gt;&lt;div&gt;&lt;b&gt;depends_on&lt;/b&gt;:服务启动的优先级关系，比如：先启动mysql在启动nginx&lt;/div&gt;&lt;div&gt;&lt;b&gt;ro&lt;/b&gt;(只读) &lt;b&gt;rw&lt;/b&gt;(读写)&lt;br&gt;&lt;/div&gt;&lt;div&gt;(除了上面的这几个还有其它的参数)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;在启动之前我们先把两个配置文件配置好：（nginx.conf default.conf）&lt;/b&gt;&lt;/div&gt;&lt;div&gt;这两个文件的配置信息我们可以通过镜像 进入到目录中找到对应的配置文件然后复制到我们自己创建的文件夹中（在容器中用不了vi vim所以需要使用yum先安装它们）&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Menlo, Monaco, Consolas, &amp;quot;Liberation Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;pre&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Menlo, Monaco, Consolas, &amp;quot;Liberation Mono&amp;quot;, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;docker run -i -t nginx /bin/bash  # nginx 镜像 或者镜像ID&lt;/span&gt;&lt;/pre&gt;&lt;div&gt;nginx.conf ：在容器中的 /etc/nginx/nginx.conf&lt;br&gt;&lt;/div&gt;&lt;div&gt;default.conf：在容器中的/etc/nginx/conf.d/default.conf&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;在docker-compose.yml所在目录中启动：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;docker-compose up -d&amp;nbsp;&amp;nbsp;&lt;/pre&gt;&lt;div&gt;up(启动yml定义的所有服务）&lt;/div&gt;&lt;div&gt;stop(停止yml中定义的所有服务）&lt;/div&gt;&lt;div&gt;start(启动被停止的yml中的所有服务）&lt;/div&gt;&lt;div&gt;restart(重启yml中定义的所有服务）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;通过docker ps 或者 docker-compose ps 可以查看启动的服务&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;\\upload\\article\\20191116\\10c5e7cf7bfcd43ad7e070bff69cea0d.png&quot; data-filename=&quot;img&quot; style=&quot;width: 826px; height: 80.2974px;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;从State可以看出，此容器正在运行，状态为UP，Ports上可以看出，容器运行着的端口和暴露的端口。&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;启动、停止容器&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;停止：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;docker-compose stop&lt;/div&gt;&lt;div&gt;说明：docker-compose stop，如果没有指定容器，则会把docker-compose.yml文件中配置的所有容器停止。如果只想停止某个容器，则需要指定容器名。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;使用docker-compose ps列出所有容器：&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;pre&gt;[root@VM_0_14_centos conf.d]# docker-compose ps&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Name&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Command&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; State&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Ports&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;br&gt;-----------------------------------------------------------------------------------------------------&lt;br&gt;docker-compose-lnmp_nginx_1&amp;nbsp; &amp;nbsp;nginx -g daemon off;&amp;nbsp; &amp;nbsp;Up&amp;nbsp; &amp;nbsp; &amp;nbsp; 0.0.0.0:443-&amp;gt;443/tcp, 0.0.0.0:80-&amp;gt;80/tcp&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;看得出，容器名为nginx,注意，是&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;nginx &lt;/span&gt;,不是&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;docker-compose-lnmp_nginx_1&amp;nbsp;&lt;/span&gt;。然后就可以停止容器了。（重启使用start 服务名）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;重启某个服务&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;[root@VM_0_14_centos conf.d]#docker-compose&amp;nbsp; restart nginx&lt;br&gt;Restarting docker-compose-lnmp_nginx_1 ... error&lt;br&gt;ERROR: for docker-compose-lnmp_nginx_1&amp;nbsp; Cannot restart container f99dd80f3207d63a557800ab8583df067994ab0145e9fe433bf22efndpoint docker-compose-lnmp_nginx_1 (f127cd6d5e8c9a6de7ff9cf0adc6f546c4ee91a276a1a45b8cc9a9c5d6543ca1):&amp;nbsp; (iptables failej DNAT --to-destination 172.18.0.2:443 ! -i br-0bb7a52553a6: iptables: No chain/target/match by that name.&lt;br&gt;&amp;nbsp;(exit status 1))&lt;br&gt;[root@VM_0_14_centos conf.d]# systemctl restart docker&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;（如果报错 重启docker）&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;删除容器&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;如果不需要这个容器或者容器运行中需要重新构建，则可以删除这个容器。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;pre&gt;[root@rainbow nginx]# docker-compose rm nginx&lt;br&gt;Going to remove nginx_nginx_1&lt;br&gt;Are you sure? [yN] y&lt;br&gt;Removing nginx_nginx_1 ... done&lt;/pre&gt;&lt;div&gt;删除之后，重新使用docker-compose up -d构建即可。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;php-fpm部署&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;pre&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;version: \'3.0\'&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;services:&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;  nginx:&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;    restart: always&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;    image: nginx:latest&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;    container_name: mynginx&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;    ports:&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;      - 80:80&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;      - 443:443&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;    volumes:&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;      - ./nginx/conf.d:/etc/nginx/conf.d:ro&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;      - ./nginx/logs:/var/log/nginx:rw&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;      - ./www:/usr/share/nginx/html:rw&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;      - /etc/letsencrypt:/etc/letsencrypt&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;    networks:&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;      - front&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;\n&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;  phpfpm:&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;      build: ./php  &lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;      container_name: myphp&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;      ports:&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;        - &quot;9000:9000&quot;&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;      volumes:&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;        - ./www:/var/www/html:rw&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;        - ./php/php.ini:/usr/local/etc/php/php.ini:ro&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;        - ./php/php-fpm.d/www.conf:/usr/local/etc/php-fpm.d/www.conf:rw&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;        - ./php/log:/var/log:rw:rw&lt;br&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;      networks:&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;        - front&lt;br&gt;&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245);&quot;&gt;&lt;font color=&quot;#333333&quot; face=&quot;Monaco, Menlo, Consolas, Courier New, monospace&quot;&gt;&lt;span style=&quot;white-space: pre-wrap;&quot;&gt;        - backend&lt;/span&gt;&lt;/font&gt;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/pre&gt;&lt;div&gt;几个需要注意的地方：&lt;/div&gt;&lt;div&gt;由于部署PHP-fpm我们需要安装很多的扩展库，所以我们要用到Dockerfile 进行php-fpm的信息配置&lt;/div&gt;&lt;div&gt;&lt;b&gt;1.build : &lt;/b&gt;加载php目录下的Dockerfile&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;2.同样的需要在php目录下创建几个文件或文件夹&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold; color: rgb(0, 0, 255);&quot;&gt;php.ini &lt;/span&gt;(这个我们需要在容器中拷贝一份php.ini&amp;nbsp; 容器中的位置：/usr/local/etc/php/&amp;nbsp; )&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;(容器中/usr/local/etc/php/ 下一般是没有php.ini这个文件的。我们需要把该目录的php.ini-production 拷贝一份 并命名为php.ini)&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;pre&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;docker cp 1b31c4d6fe70:/usr/local/etc/php/php.ini&amp;nbsp; /docker-compose-lnmp/php   # &lt;/span&gt;1b31c4d6fe70  php容器ID&lt;/pre&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold; color: rgb(0, 0, 255);&quot;&gt;php-fpm.d/www.conf&amp;nbsp;&lt;/span&gt;(这个我们需要在容器中拷贝一份www.conf&amp;nbsp; 容器中的位置：/usr/local/etc/php-fpm.d ，没有就拷贝一份该目录下的&amp;nbsp;www.conf.default&amp;nbsp;并命名为www.conf)&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;line-height: 1.42857;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 0);&quot;&gt;docker cp 1b31c4d6fe70:/usr/local/etc/php-fpm.d/www.conf  /docker-compose-lnmp/php/php-fpm.d   # &lt;/span&gt;1b31c4d6fe70  php容器ID&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold; color: rgb(0, 0, 255);&quot;&gt;log &lt;/span&gt;日志目录&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div style=&quot;&quot;&gt;因为PHP-FPM构建稍微复杂，涉及到很多扩展。&lt;/div&gt;&lt;div style=&quot;&quot;&gt;所以单独用Dockerfile文件构建PHP-FPM：&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;在php目录下创建Dockerfile&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&quot;&quot;&gt;FROM php:7.2.9-fpm \n# Install any custom system requirements here\nRUN apt-get update \\\n    apt-get upgrade \\\n  &amp;amp;&amp;amp; apt-get install -y --no-install-recommends \\\n    libicu-dev \\\n    libmemcached-dev \\\n    libz-dev \\\n    libpq-dev \\\n    libjpeg-dev \\\n    libpng-dev \\\n    libfreetype6-dev \\\n    libssl-dev \\\n    libmcrypt-dev \\\n    libxml2-dev \\\n    libbz2-dev \\\n    libjpeg62-turbo-dev \\\n    curl \\\n  &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*\n \n# Install various PHP extensions\nRUN docker-php-ext-configure bcmath --enable-bcmath \\\n    &amp;amp;&amp;amp; docker-php-ext-configure pcntl --enable-pcntl \\\n    &amp;amp;&amp;amp; docker-php-ext-configure pdo_mysql --with-pdo-mysql \\\n    &amp;amp;&amp;amp; docker-php-ext-configure pdo_pgsql --with-pgsql \\\n    &amp;amp;&amp;amp; docker-php-ext-configure mbstring --enable-mbstring \\\n    &amp;amp;&amp;amp; docker-php-ext-configure soap --enable-soap \\\n    &amp;amp;&amp;amp; docker-php-ext-install \\\n        bcmath \\\n        intl \\\n        mbstring \\\n        mcrypt \\\n        mysqli \\\n        pcntl \\\n        pdo_mysql \\\n        pdo_pgsql \\\n        soap \\\n        sockets \\\n        zip \\\n  &amp;amp;&amp;amp; docker-php-ext-configure gd \\\n    --enable-gd-native-ttf \\\n    --with-jpeg-dir=/usr/lib \\\n    --with-freetype-dir=/usr/include/freetype2 &amp;amp;&amp;amp; \\\n    docker-php-ext-install gd \\\n  &amp;amp;&amp;amp; docker-php-ext-install opcache \\\n  &amp;amp;&amp;amp; docker-php-ext-enable opcache\n&lt;/pre&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;部署mysql&lt;/span&gt;&lt;/p&gt;&lt;p&gt;同样的先编辑 docker-compose.yml&lt;/p&gt;&lt;pre&gt;version: \'3.0\'&lt;br&gt;services:&lt;br&gt;&amp;nbsp; nginx:&lt;br&gt;&amp;nbsp; &amp;nbsp; restart: always&lt;br&gt;&amp;nbsp; &amp;nbsp; image: nginx:latest&lt;br&gt;&amp;nbsp; &amp;nbsp; container_name: my-nginx&lt;br&gt;&amp;nbsp; &amp;nbsp; ports:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - 80:80&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - 443:443&lt;br&gt;&amp;nbsp; &amp;nbsp; volumes:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - ./nginx/conf.d:/etc/nginx/conf.d:ro&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - ./nginx/logs:/var/log/nginx:rw&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - ./www:/usr/share/nginx/html:rw&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - /etc/letsencrypt:/etc/letsencrypt&lt;br&gt;&amp;nbsp; &amp;nbsp; networks:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - front&lt;br&gt;&amp;nbsp; phpfpm:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; build: ./php&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; container_name: my-php&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; ports:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; - 9000:9000&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; volumes:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; - ./www:/var/www/html:rw&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; - ./php/php.ini:/usr/local/etc/php/php.ini:ro&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; - ./php/php-fpm.d/www.conf:/usr/local/etc/php-fpm.d/www.conf:rw&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; - ./php/log:/var/log:rw&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; networks:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; - front&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; - backend&lt;br&gt;&amp;nbsp; mysql:&lt;br&gt;&amp;nbsp; &amp;nbsp; image: mysql:5.7.26&lt;br&gt;&amp;nbsp; &amp;nbsp; container_name: my-mysql&lt;br&gt;&amp;nbsp; &amp;nbsp; ports:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - 3306:3306&lt;br&gt;&amp;nbsp; &amp;nbsp; volumes:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - ./mysql/data/:/var/lib/mysql/&lt;br&gt;&amp;nbsp; &amp;nbsp; environment:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; MYSQL_ROOT_PASSWORD : wq540074./&lt;br&gt;networks:&lt;br&gt;&amp;nbsp; front:&lt;br&gt;&amp;nbsp; backend:&lt;br&gt;&lt;/pre&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;environment :&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;&amp;nbsp; &amp;nbsp;&lt;/span&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;MYSQL_ROOT_PASSWORD 设置root 账号的密码&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;docker-compose.yml 配置 nginx+php+mysql 完整信息&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;pre style=&quot;&quot;&gt;version: \'3.0\'&lt;br&gt;services:&lt;br&gt;&amp;nbsp; nginx:&lt;br&gt;&amp;nbsp; &amp;nbsp; restart: always&lt;br&gt;&amp;nbsp; &amp;nbsp; image: nginx:latest&lt;br&gt;&amp;nbsp; &amp;nbsp; container_name: my-nginx&lt;br&gt;&amp;nbsp; &amp;nbsp; ports:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - 80:80&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - 443:443&lt;br&gt;&amp;nbsp; &amp;nbsp; volumes:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - ./nginx/conf.d:/etc/nginx/conf.d:ro&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - ./nginx/logs:/var/log/nginx:rw&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - ./www:/usr/share/nginx/html:rw&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - /etc/letsencrypt:/etc/letsencrypt&lt;br&gt;&amp;nbsp; &amp;nbsp; networks:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - front&lt;br&gt;&amp;nbsp; phpfpm:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; build: ./php&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; container_name: my-php&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; ports:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; - 9000:9000&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; volumes:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; - ./www:/var/www/html:rw&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; - ./php/php.ini:/usr/local/etc/php/php.ini:ro&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; - ./php/php-fpm.d/www.conf:/usr/local/etc/php-fpm.d/www.conf:rw&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; - ./php/log:/var/log:rw&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; networks:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; - front&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; - backend&lt;br&gt;&amp;nbsp; mysql:&lt;br&gt;&amp;nbsp; &amp;nbsp; image: mysql:5.7.26&lt;br&gt;&amp;nbsp; &amp;nbsp; container_name: my-mysql&lt;br&gt;&amp;nbsp; &amp;nbsp; ports:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - 3306:3306&lt;br&gt;&amp;nbsp; &amp;nbsp; volumes:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; - ./mysql/data/:/var/lib/mysql/&lt;br&gt;&amp;nbsp; &amp;nbsp; environment:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; MYSQL_ROOT_PASSWORD : wq540074./&lt;br&gt;networks:&lt;br&gt;&amp;nbsp; front:&lt;br&gt;&amp;nbsp; backend:&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;最后在&lt;/span&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;docker-compose.yml所在目录中运行&amp;nbsp; docker-compose up -d 可以开始创建在&lt;/span&gt;&lt;span style=&quot;font-weight: 700;&quot;&gt;docker-compose.yml配置的相关的服务&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold; color: rgb(0, 0, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold; color: rgb(0, 0, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold; color: rgb(0, 0, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold; color: rgb(0, 0, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold; color: rgb(0, 0, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold; color: rgb(0, 0, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold; color: rgb(0, 0, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold; color: rgb(0, 0, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold; color: rgb(0, 0, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-weight: bold; color: rgb(0, 0, 255);&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &amp;quot;Courier New&amp;quot;, monospace; white-space: pre-wrap;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n\n                                                                                                                                                                            ',0,'2018-07-11 00:00:00','35',57);

/*Table structure for table `yx_index_menu` */

DROP TABLE IF EXISTS `yx_index_menu`;

CREATE TABLE `yx_index_menu` (
  `menu_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `menu_name` varchar(50) NOT NULL DEFAULT '',
  `menu_pid` int(11) NOT NULL DEFAULT '0',
  `menu_status` tinyint(1) NOT NULL DEFAULT '0' COMMENT '1为删除状态 0为使用状态',
  `menu_sort` tinyint(3) NOT NULL DEFAULT '0',
  `type` varchar(10) NOT NULL DEFAULT 'tag' COMMENT 'type: menu | tag',
  PRIMARY KEY (`menu_id`)
) ENGINE=MyISAM AUTO_INCREMENT=40 DEFAULT CHARSET=utf8mb4;

/*Data for the table `yx_index_menu` */

insert  into `yx_index_menu`(`menu_id`,`menu_name`,`menu_pid`,`menu_status`,`menu_sort`,`type`) values (18,'后端开发',0,0,2,'menu'),(19,'服务器',0,0,3,'menu'),(20,'前端开发',0,0,1,'menu'),(21,'CSS',20,0,0,'tag'),(22,'JavaScript',20,0,0,'tag'),(23,'PHP',18,0,0,'tag'),(24,'Python',18,0,0,'tag'),(25,'Apache',19,0,0,'tag'),(26,'Nginx',19,0,0,'tag'),(10,'数据库',0,0,4,'menu'),(11,'mysql',10,0,0,'tag'),(12,'mongodb',10,0,0,'tag'),(16,'redis',10,0,0,'tag'),(17,'Linux',19,0,0,'tag'),(29,'HTML',20,0,0,'tag'),(30,'memcache',10,0,0,'tag'),(31,'开发工具',0,0,5,'menu'),(32,'GIT',31,0,0,'tag'),(33,'计算机',18,0,0,'tag'),(34,'JAVA',18,0,0,'tag'),(35,'docker',19,0,0,'tag'),(36,'编辑器',31,0,0,'tag'),(37,'spring',18,0,0,'tag'),(38,'vue',20,0,0,'tag'),(39,'中间件',18,0,0,'tag');

/*Table structure for table `yx_role` */

DROP TABLE IF EXISTS `yx_role`;

CREATE TABLE `yx_role` (
  `role_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `role_name` varchar(30) NOT NULL COMMENT '角色名',
  `role_describe` text NOT NULL COMMENT '角色描述',
  `role_auth` text NOT NULL COMMENT '角色权限',
  `role_status` tinyint(1) NOT NULL DEFAULT '0' COMMENT '角色状态 0:正常',
  `role_add_time` datetime NOT NULL DEFAULT '0000-00-00 00:00:00' COMMENT '角色添加时间',
  PRIMARY KEY (`role_id`)
) ENGINE=MyISAM AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4;

/*Data for the table `yx_role` */

insert  into `yx_role`(`role_id`,`role_name`,`role_describe`,`role_auth`,`role_status`,`role_add_time`) values (1,'超级管理员','整站权限','all',0,'2018-07-21 22:02:45'),(2,'管理员','编辑查看部分权限','admin/Order,admin/Article/articleList,admin/Article/addArticle,admin/Article/updateArticle',0,'2018-07-18 22:08:13');

/*Table structure for table `yx_user` */

DROP TABLE IF EXISTS `yx_user`;

CREATE TABLE `yx_user` (
  `user_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `user_login` varchar(60) NOT NULL COMMENT '用户登入名',
  `user_pass` varchar(255) NOT NULL COMMENT '用户密码',
  `user_nicename` varchar(50) NOT NULL COMMENT '用户别名',
  `user_email` varchar(100) NOT NULL COMMENT '用户邮箱',
  `user_phone` varchar(30) NOT NULL COMMENT '用户电话',
  `user_status` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '用户状态',
  `user_role` int(11) unsigned NOT NULL COMMENT '用户所属角色ID',
  `user_registered` datetime NOT NULL DEFAULT '0000-00-00 00:00:00' COMMENT '用户注册时间',
  PRIMARY KEY (`user_id`)
) ENGINE=MyISAM AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4;

/*Data for the table `yx_user` */

insert  into `yx_user`(`user_id`,`user_login`,`user_pass`,`user_nicename`,`user_email`,`user_phone`,`user_status`,`user_role`,`user_registered`) values (1,'admin','$P$BxQ7fBK/nlKyw2niuTJilLUUkeRwAk0','','admin@sina.com','15889745718',0,1,'2018-07-21 22:01:32');

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
